<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="https://cofree.coffee/~verity/rss.xml" rel="self" type="application/rss+xml" />
<title>MonoidMusicianʼs blog</title>
<link>https://cofree.coffee/~verity</link>
<description>MonoidMusicianʼs blog</description>
<language>en-US</language>
<copyright>GPLv3</copyright>
<docs>https://www.rssboard.org/rss-specification</docs>
<generator>pandoc-rss</generator>
<item>
<title>Pickling Tasty Data</title>
<pubDate>Sun, 28 Jan 2024 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/pickling.html</guid>
<description><![CDATA[<p>I want to talk about data today. In particular, I want to talk about runtime representations of data, <strong>real</strong> data – data that can be mutable and referentially opaque at runtime – and demystify what they actually are in terms of more familiar notions of data.</p>
<p>You shouldnʼt just throw up your hands once you have cyclic references! Itʼs possible and worthwhile to design tools to work with the raw graph of runtime data, no matter its shape. With the proper metaprogramming hooks, you could save and restore a whole runtime environment <em>from the inside</em>, which is pretty amazing to think about.</p>
<p>(Well, okay, you might give up at things like functions, if there isnʼt enough metaprogramming, or running sockets, for example – thatʼs okay!)</p>
<p>The main thing we will work up to (and go beyond) is Pythonʼs <a href="https://docs.python.org/3/library/pickle.html"><code class="python">pickle</code> module</a>, including my own implementation of it for the <a href="https://wiki.flightgear.org/Nasal_scripting_language">Nasal scripting language</a> (which I believe is cleaner in some respects, although obviously less industrial).</p>
<h2 id="background">Background</h2>
<p>This post has spent a long time marinating in my mind, so Iʼm happy to finally get it on the page!</p>
<p>Iʼve identified some basic aspects of data:</p>
<ol>
<li>Pure (immutable) data
<ul>
<li>Either acyclic …</li>
<li>… or allowed to be cyclic</li>
</ul></li>
<li>Mutable data (say, in-memory)
<ul>
<li>Youʼre basically forced to allow cyclic references!<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li>Sharing matters!</li>
</ul></li>
<li>Data defined in reference to external things (like file or socket handles)
<ul>
<li>External is relative – as it should be!</li>
<li>Your need to think about capturing intent
<ul>
<li><span data-t="" data-widget="">e.g.</span> file paths are probably your best indicator of intent – but if it was a temporary file, you could probably create a new temporary file instead! but oh now what if a different string is storing the path of the file, now you donʼt know how those pieces of data relate anymore and cannot update that string …</li>
</ul></li>
</ul></li>
<li>Functions? <em>Are</em> functions data?? (Iʼm including closures and procedures and routines and all that stuff in my definition of functions, btw.)</li>
<li>Quotiented data (Agda, Lean, Rocq)
<ul>
<li>see <a href="https://cofree.coffee/~verity/adt_lies_for_truth.html">Subtypes/Quotients: Lies Told in Defense of the Truth</a> (<span data-t="" data-widget="">WIP</span>)</li>
</ul></li>
</ol>
<p>It will be important to think about what notions of equality are useful and adequate for these kinds of data!</p>
<p>We will talk about runtimes, including what garbage collectors do. Garbage collection is pretty special, since it gets into all the nitty gritty implementation details of a runtime: it essentially pins down the data model of most languages that have garbage collection.</p>
<p>It is also important to talk about what capabilities the language provides for working with and thus distinguishing data. If the difference cannot be observed, it does not exist! (And we may be “morally” justified in ignoring it anyways.)</p>
<h3 id="serialization-deserialization">Serialization, deserialization</h3>
<p>Serializing in its basic form – for pure data – means writing it out to a string such that it can be recovered from that string. (Bitstring, bytestring, Unicode string, even a bignum – the exact details do not matter. It also does not matter if it is a well packed encoding or a sparse encoding with lots of invalid strings that do not deserialize.)</p>
<p>Pickling is more general: it means serializing non-pure data by taking a snapshot of mutable data, preserving referential identity in the process (this is hard!), and doing your best with external references, and maybe giving up on functions.</p>
<p>Part of my argument is that serializing and pickling is very tied up in what data means!</p>
<p>Like, What is the essence of data? I hope it is something you can grasp fully, explain fully, and write out to a file and fully reconstruct in a new runtime context. (Mumble mumble: decidable equality, computation, countability.)</p>
<h3 id="equivalent-vs-equal">Equivalent vs equal</h3>
<p>I think I have definitions of equal and equivalent that are useful.</p>
<p>Equality in the classical sense<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is going to be too strict, I argue, for the notion of data I want to consider. First of all, it is hard to compare values across runtimes, which is silly! Data does not only exist for an instant in time! And two mutable objects can be <em>interchangeable</em> even if they are not <em>identical</em> references.</p>
<p>This discrepancy happens as soon as you have mutable references, which you could tell apart if you have both to compare, but otherwise would act similar.</p>
<div class="Key_Idea">
<p>So I will use “equal” to mean “values that live within the same run of the runtime and will definitely act the same, thus equal in all ways the language could distinguish<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>”.</p>
<p>And I will use “equivalent” to mean “values that, if they exist in the same run of the runtime, would cause no difference if all references to them were swapped and then their children were shallowly swapped; otherwise, values that would act as similar as possible across different runs of the runtime”.</p>
</div>
<div class="Example">
<p>We definitely need to walk through an example of what “equivalent” means to unpack my definition. Hereʼs one in JavaScript, although the particulars of JavaScript do not matter:</p>
<pre class="javascript"><code>// Set up some data
let shared = [];
let v0 = { 0: shared, 1: [], 2: 2 };
v0[3] = v0;
let v1 = { 0: shared, 1: [], 2: 2 };
v1[3] = v1;
shared.push(v0, v1);

// I hope you agree that this characterizes
// the state of the data, most or less
for (let v of [v0, v1]) {
  // shared reference
  assert(v[0] === shared);
  // equivalent empty arrays,
  // though not equal
  assert(v[1].length === 0);
  // index 2 is 2
  assert(v[2] === 2);
  // self reference
  assert(v[3] === v);
}
// and they are referenced by shared in order
assert(shared[0] === v0);
assert(shared[1] === v1);

// they are not equal:
assert(v0 !== v1);

// but we can swap them, ...
[v0, v1] = [v1, v0];
// ... all references to them, ...
[v0[3], v1[3]] = [v1[3], v0[3]]; // yes, self references count
[shared[0], shared[1]] = [shared[1], shared[0]];
// ... and the immediate references they hold,
// since they have the same shallow structure
[v0[0], v1[0]] = [v1[0], v0[0]];
[v0[1], v1[1]] = [v1[1], v0[1]];
[v0[2], v1[2]] = [v1[2], v0[2]];
[v0[3], v1[3]] = [v1[3], v0[3]];
// this last one fixes up their self references again!

// Now we have the same observable state of the world!
for (let v of [v0, v1]) {
  // shared reference
  assert(v[0] === shared);
  // equivalent empty arrays,
  // though not equal
  assert(v[1].length === 0);
  // index 2 is 2
  assert(v[2] === 2);
  // self reference
  assert(v[3] === v);
}
// and they are still referenced by shared, in the
// order corresponding to the same variable names
assert(shared[0] === v0);
assert(shared[1] === v1);

// so we conclude that `v0` and `v1` are equivalent!</code></pre>
</div>
<div class="Note">
<p>Note that “equal” and “equivalent” are, strictly speaking, external notions. However, “equal” is often testable internally, such as by <code class="javascript">===</code>. (Except for the case of <code class="javascript">NaN</code> – you technically have to use <code class="javascript">a === b || (a !== a &amp;&amp; b !== b)</code> to detect <code class="javascript">NaN ==== NaN</code>, and I believe that different <code class="javascript">NaN</code>s are indistinguishable.)</p>
<p>“Equivalent” is much harder to test: for functions it will be impossible, but even for data made out of simple JSON-like structures it takes a fair amount of bookkeeping and some trickery to truly decide it.</p>
</div>
<p>In Dhall, equal and equivalent happen to be the same!<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> Unfortunately this is more a reflection of the rather stagnant notion of data in Dhall – no mutability, no references, no cyclic structures.</p>
<p>As soon as you have mutable references, equality and equivalence will not be the same.</p>
<p>(This is because you can always<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> use test mutations to tell when two references are identical or not, so you cannot just outlaw referential equality and hope that they become indiscernable.)</p>
<p>And practically speaking, there are always wrinkles.</p>
<div class="Details" data-box-name="Rambling">
<p>Maybe there are bignums who can be observed to have different encoding by esoteric functions, but both encode the same number – you would be justified in wanting to consider them equal. (Especially if this is a distinction that can be observed by those esoteric functions but not reflected by a pickling function, for example. That is, if you could know that one number has an overlong encoding by virtue of being observably <em>different</em> from the other number, but not know which number is overlong, or, indeed, how overlong it is. Well, I suppose pickling would mean you have a canonical, short form, so it would just be a question of not knowing how overlong it is – maybe even being able to reconstruct an overlong form without trying a bunch of weird math operations to force decanonicalization, which would potentially get undecidable.)</p>
</div>
<h2 id="by-concept">By Concept</h2>
<p>Letʼs talk about concepts of data that exist across specific languages and runtimes!</p>
<h3 id="strings">Strings</h3>
<p>As a warm-up to thinking about references and pointers: Letʼs observe that immutable strings are treated specially by a lot of runtimes!</p>
<p>V8 has a lot of different representations of strings, and it is free to change representation between them, <span data-t="" data-widget="">e.g.</span> while garbage collecting. It is free to make these changes since they arenʼt observable from JavaScript (outside of performance characteristics).</p>
<p>Erlang likewise has immutable binaries (bytestrings) which serve similar purposes although they only support fast slicing (no fast concatenation). To get fast concatenation, users are expected to build up nested lists and flatten it out into one binary at the end of all the concatenation operations. (Luckily it is rare to want to index back into a binary as your are building it up, so this is acceptable for most use-cases.)</p>
<p>The thing that the Erlang garbage collector is specifically allowed to do is to delete old binaries whose contents are only partially referenced. Then it has the task of fixing up the references to those slices to refer to the new binaries with adjusted indices. This is definitely mutating data at some level (<span data-t="" data-widget="">e.g.</span> the level of raw memory), but it is not visible from Erlang at all.</p>
<p>Anyways, this is just a nicer example of stuff the runtime can do behind the scenes that has a very precise semantic description. It happens “behind the scenes” because changes occur in memory that do not effect equality, as seen from the language. As we start to think about references and managed pointers and external references and functions, it gets more complicated!</p>
<p>It is also a good warning to be careful about what “immutable” means: since every runtime uses mutation at some level, we only care about immutability as viewed from the language itself.</p>
<h3 id="mutability-or-purity">Mutability or purity</h3>
<p>Mutability should be one of the first things you think of when you think about data, especially if you have had some exposure to ideas from Functional Programming (FP).</p>
<p>The really nice thing about pure languages like Haskell and PureScript is that they separate out <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-IORef.html#t:IORef">mutable</a> <a href="https://pursuit.purescript.org/packages/purescript-refs/6.0.0/docs/Effect.Ref#t:Ref">references</a> from pure data, and dispense with mutable variables altogether. It affords us a much nicer toolbox for expressing these concepts, in theory and in code.</p>
<h4 id="referential-identity-vs-referential-transparency">Referential identity vs referential transparency</h4>
<p>One way to say it is that pure data is characterized by its serialization. If it makes no reasonable difference whether you keep using the original value versus the value after it has been serialized and deserialized, then that is pure data. (This is a reformulation of referential transparency.)</p>
<p>Mutable data cares about its referential <strong>identity</strong>, on the other hand. (Note that “reference” most often means something like “pointer”, but it doesnʼt have to be restricted to that.)</p>
<h4 id="sharing-references">Sharing references</h4>
<p>The thing about pure data is that it essentially doesnʼt really care if it is a tree or a DAG. I mean, it matters in terms of efficiency and storage space! (Though this is rarely exposed at a useful level.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>) But the results of an algorithm wonʼt be changed just by sharing more or less internal structure among the immutable data.</p>
<p>Mutable data pretty obviously cares about sharing.</p>
<h3 id="functions">Functions</h3>
<p>Functions are tough. When viewed from above (mathematically) and below (most runtime implementations), they cannot be sensibly serialized.</p>
<p>One thing that is always true<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> is that you <strong>cannot</strong> expect to know when two functions are equivalent. They may happen to be equivalent in a obvious way, but if they arenʼt, you cannot necessarily find out that they actually have distinct behavior. (In other words: equivalence is semidecidable [reference needed].)</p>
<p>If you have the original syntax defining the functions, you <em>do</em> have a snowballʼs chance in hell of deciding that two functions are equivalent, by doing some procedures to normalize the syntactic definitions of the functions. (One difficulty is that you will also have to keep track of closures, including captured variables and open variables.)</p>
<p>But once the syntax is forgotten (<span data-t="" data-widget="">viz.</span> at runtime), the best you can do is a pointer comparison, which is a very poor decider of equivalence.</p>
<p>The funny thing is that, although all functions start out as syntax, syntactic normalization is very rare for languages.</p>
<p>Only a few term-based languages like Dhall will always keep functions as syntax<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>, and only theorem provers like Agda/Lean/Rocq will keep the function syntax around for their core operation (whereas code extraction and runtime is almost entirely a separate issue).</p>
<p>(Aside: In theory you could defunctionalize a whole closed-system program right? At least for pure data? Maybe for mutable too?)</p>
<p>However, in languages like Agda, each function definition is considered distinct, so it might as well be a pointer check. (This is true for almost all theorem prover languages, certainly for recursively-defined functions – Dhall just avoids the issue by not having recursive functions!)</p>
<h2 id="by-language">By Language</h2>
<p>To really talk about data, we have to talk about specific runtimes. Weʼll work our way up from simplest to more thorny.</p>
<h3 id="fantasy">Fantasy</h3>
<p>Languages that nobody actually runs. Theyʼre just too academic or something. (Joking.)</p>
<h4 id="json">JSON</h4>
<p>JSON is a pretty great place to start.</p>
<p>JSON is pure, immutable data. It is acyclic and unshared. If you want to represent sharing, you need to represent it at a different level! By encoding some notion of identities and references, that is.</p>
<p>Many other things (like binary data/bitstrings) are mathematically equivalent to JSON in this regard. They are “just” pure data, in which you can encode any other pure data, with more or less help from existing structure like arrays and objects.</p>
<p>There are some wrinkles, like the fact that numeric precision is not specified, and the order of keys may matter to some runtimes and not others (okay, practically all runtimes <a href="https://stackoverflow.com/a/5525820">mostly</a> preserve order by now).</p>
<p>Note that JSON is often deserialized to <em>mutable</em> data. This means that <em>mutable</em> data may not roundtrip through JSON: shared values will be unshared. But Iʼm getting ahead of myself.</p>
<h4 id="dhall"><a href="https://dhall-lang.org/">Dhall</a></h4>
<p>From an abstract perspective, Dhall is pretty much like JSON, with a couple key differences:</p>
<ul>
<li>The data is strictly typed.</li>
<li>You can serialize functions!</li>
</ul>
<p>Dhall comes with a good notion of equality – judgmental equality – which applies normalization to open terms (expressions with free variables – in particular, functions). By applying algebraic reasoning, judgmental equality can sometimes show that two functions are equal, but not always!</p>
<h4 id="agda"><a href="https://agda.readthedocs.io/en/latest/">Agda</a></h4>
<p>(I use this mostly as a catch-all for theorem provers.)</p>
<p>Agda is kind of like Dhall, but its emphasis is different, and it has more features. As mentioned somewhere here, recursive functions mean that it gives up even earlier on detecting equality of functions. The other important new feature is quotients.</p>
<p>Quotients are interesting: they are – at some level – represented by the same (runtime) data as everything else, but some of the underlying data has to be treated as equal by <em>everything</em> (in particular, by equality, and thus by the rest of the theory, since everything has to preserve equality).</p>
<p>Specifically, Higher Inductive Types and Observational Type Theory are interesting topics here, but way too deep to get into at the moment (and well covered by others – not something I feel much need to opine on in this context).</p>
<h3 id="real-world">Real World</h3>
<p>Okay maybe some people actually run these languages and interact with their runtimes.</p>
<h4 id="erlangelixirbeam">Erlang/Elixir/BEAM</h4>
<p>Erlang is pretty interesting, for an untyped language. Data is fundamentally immutable<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> and acyclic and this has influenced many aspects of its design.</p>
<p>This enables somewhat exotic features like non-linear pattern matching and deep equality, which are unheard of in untyped, mutable languages. (These are the same feature, actually. Non-linear pattern matching is implemented via deep equality.)</p>
<p>In fact, Erlang specifies a very specific serialization format for data, for seamlessly communicating across distributed systems.</p>
<h5 id="what-are-processes">What are processes?</h5>
<p>It is not the case that Erlang processes are data. That is, processes themselves are not just a kind of data. Erlang does not claim to let you save the full state of a process off to disk and restart it from the saved data. That would be a little silly – what would happen to all the other processes it was bound to? No, processes are part of a dynamic runtime system.</p>
<p>However, a <em>reference</em> to a process <em>is</em> “just” data still, and can be compared for equality like any other data, and it can be serialized.</p>
<p>(The same for BEAM functions and closures, btw. Their references are opaque in some sense, but still just data.)</p>
<p>And interestingly, the dynamic, asynchronous nature of processes means that they <em>must</em> expose mutation.</p>
<p>Indeed, one way to implement a mutable reference is to spin up a process that holds the “current” value<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> and returns it when queried and purely updates it in its state. That is, its state is immutable, but external callers can see fresh data whenever they query the process.</p>
<h4 id="haskell">Haskell</h4>
<p>Haskell is actually one of the most complex ones here, since there are many levels you can talk about data at.</p>
<p>One the one hand, you can talk about pure data all day long. You can pretend that it operates like Agda or Dhall – totally pure! (Except you cannot compare functions for equality [except you can].)</p>
<p>You can even add mutable references (again with equality [again with the exception]). Itʼs actually really beneficial to have this separation between mutable references and immutable data that they contain, but I didnʼt get into it here.</p>
<p>Mutable references form a possibly cyclic directed graph, just like the imperative languages we will be talking about. But Haskell can also form cyclic data references via laziness: <a href="https://wiki.haskell.org/Tying_the_Knot">“tying the knot”</a>, as it is called.</p>
<p>However, Haskell is a bit weird in that you can also peek inside the machine, and compare pointers and do other “naughty” stuff. This can be used to short-circuit deep equality comparisons via referential equality, memoize functions on uncomparable types, and other <a href="https://acatalepsie.fr/posts/overloading-lambda">legitimate</a> <a href="https://dl.acm.org/doi/pdf/10.1145/3409002">uses</a><a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>. Except it isnʼt so naughty (if you do it right), it is just a different layer of abstraction.</p>
<p>In fact, if you drill down, Haskell has some kind of data model that its runtime operates on. This will tell you when it is okay to use <code class="haskell">unsafeCoerce</code>, for example. Itʼs maybe worth talking about the way Haskell evaluates, what its thunks represent, how mutable and immutable data work, <a href="https://hackage.haskell.org/package/stm-2.5.3.0/docs/Control-Concurrent-STM.html">STM</a>, FFI,— but it just goes on for ages.</p>
<p>I think itʼs really worth thinking about this deeply, taking seriously the kinds of data that Haskell uses at runtime, and how references to them interact, how the garbage collector makes sense of it all.</p>
<p>But as we will see, an awful lot of runtimes seem to be about managing the graph of references of data, and itʼs useful to be able to work with those graphs at some point, even if the language is hesitant to give it up so easily. (Allowing a program unmanaged access to its own heap would be a disaster. Itʼs understandable, really.)</p>
<h4 id="javascript">JavaScript</h4>
<p>JavaScript will be our stand-in for a scripting language with a simple, dynamically typed, mutable data model (and garbage collector).</p>
<p>Everyoneʼs familiar with the JSON side of JavaScript: it stands for JavaScript Object Notation, after all. But once you embed in the larger language, you can get things like cyclic references via mutation. Even things like arrays work differently than JSON promised.<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></p>
<p>As a silly example,</p>
<pre class="javascript"><code>// this is the “weird” JS `const`
// where the variable reference is
// constant, but the data is mutable!
const selfRef = [];
selfRef.push(selfRef);
console.log(selfRef[0] === selfRef);

console.log(JSON.stringify(selfRef));
// Uncaught TypeError: cyclic object value</code></pre>
<p>This is no longer JSON serializable!</p>
<p>This one is still JSON serializable, but it no longer behaves the same after deserialization:</p>
<pre class="javascript"><code>const twin = {name: "Lo"};
const twins = [twin, twin];
const gemini = JSON.parse(JSON.stringify(twins));
twins[1].name = "Hi";
gemini[1].name = "Hi";
console.log(JSON.stringify(twins)); // [{name: "Hi"}, {name: "Hi"}]
console.log(JSON.stringify(gemini)); // [{name: "Lo"}, {name: "Hi"}]</code></pre>
<p>So JavaScript, by allowing mutation, can observe cyclic and shared references that JSON simply does not have.</p>
<p>Most people donʼt reckon with this aspect of the runtime at a deep level! Obviously they throw mutable references around all the time and understand that they are shared, and will design some kind of serialization format that uses IDs or something and then reconstruct the right shared references on top of that. But they donʼt build debugging tools for JavaScript itself that would work with arbitrary data.</p>
<p>But what if you didnʼt have to?</p>
<p>Thereʼs actually a way to make a serialization so that <code class="javascript">gemini</code> behaves like <code class="javascript">twins</code>. I call this pickling, after the Python library. More on this later.</p>
<h5 id="functions-1">Functions</h5>
<p>Not much worth saying about functions. You can get their source code in JavaScript (why??), but you cannot observe their closure, so you cannot pickle them up thoroughly.</p>
<h5 id="globals-such-as-dom-references">Globals, such as DOM references</h5>
<p>As will be the theme, references to foreign data (not strings, numbers, objects, arrays) are tough.</p>
<p>Global object types are worth thinking about. They are opaque to code, but in theory they live in predictable places in the global namespace each time, so the proper reference to them can be reconstructed. However, thereʼs still complications, such as that different runtimes will expose different ones (Chrome, Firefox, Node, Deno, …).</p>
<p>By far the most common types of foreign objects will be from the DOM. Some can be serialized pretty directly – at least snapshotted if they arenʼt immutable (like all the little attribute list or node list types, or bounding box type).</p>
<p>If you have a reference to an element with an <code class="html:Attribute">id</code>, you might expect that you could serialize it, and then reload the page, and have it still refer to “that” element. But “that” element doesnʼt exist anymore. Maybe thereʼs a new one with the same <code class="html:Attribute">id</code> – maybe the <code class="html:Attribute">id</code> doesnʼt exist anymore! Well, it is sort of the best marker of intent there is.</p>
<p>And so we come to the conclusion that we will always be struggling with the API boundaries of runtimes, of data that isnʼt constructed from within the language itself. Once you have data inside your system that references things outside, how do you deal with it? What kind of guarantees could you still get when persisting it?</p>
<h5 id="debugging-cyclic-structures">Debugging cyclic structures</h5>
<p>It is worth noting that NodeJS debugging facilities finally implemented support for detecting cyclic references when printing out structures and letting you know what the reference is.</p>
<p>Itʼs a simple thing, but itʼs a barrier that most people throw up their hands when encountering.</p>
<p>Itʼs also funny that when debugging things interactively, via point and click stuff, lazily expanding, that you donʼt care too much whether the data structure is cyclic or shared: nothing will blow up since it does not recurse automatically.</p>
<h5 id="pickling-javascript-runtime-values">Pickling JavaScript runtime values</h5>
<p>You can imagine an algorithm (well, I could write it if I wasnʼt sleepy) that pickles JSON-like objects, but in a way that respects mutability and sharing. It would write out a function definition to reconstruct a new mutable object equivalent to the one it was given.</p>
<p>In JavaScript you would have to do this the slow way. You would maintain a list of <strong>all</strong> mutable objects you have seen, along with where you saw them as a path down from the root object. You would then output code that reconstructs an object incrementally, by adding properties in order, and grabbing shared references from other parts of the object as necessary (or caching them in variables).</p>
<p>The cool thing is that you can do it all with <code class="javascript">const</code>! You donʼt need mutability at the variable level, you can (and should) do it all at the mutable value level.</p>
<p>The algorithm I decscribed can do this for data that is simple in structure, but complicated in terms of references, and with extensions it could handle more things (like regular expressions would be easy to add, <code class="javascript">undefined</code> would be trivial). Actually, it is funny – it would also need to be extended to handle sparse arrays, and all of these little details tell you about how simplified JSON is from the actual data model of JavaScript.</p>
<p>This would give you your own faithful, accurate slice of the runtime heap as viewed from the perspective of one objectʼs watershed of references. The resulting reconstructed value would behave the same with regards to mutability of its children. It just would not compare equal with <code class="javascript">===</code>, since it is a newly allocated value (and all of its children are too).</p>
<p>However, if nobody else remembered the old object, and you substituted in the new object very sneakily … nobody would know 🤫</p>
<h4 id="python">Python</h4>
<p>Python is pretty similar to JavaScript, in the rough kinds of mutable data it supports, but worth talking about separately.</p>
<p>It has more explicit boundaries around mutability and immutability in its data types. (Although still not as nice as Haskell. And I suppose JavaScript has been getting a little more in the way of immutability and actual data types.)</p>
<p>Python also provides the pickling library that is one of the main subjects of this article. More on this later.</p>
<p>Some wrinkles:</p>
<ul>
<li><p>The fact that <a href="https://docs.python.org/3.3/using/cmdline.html#envvar-PYTHONHASHSEED">the hashing function rotates each run</a> is really interesting! It technically is an observable difference between runs, but it isnʼt some essential semantic feature of the data. And you would have the same sort of thing if you are allowed to see an ordering on pointers.</p></li>
<li><p>External references, like files and sockets and other stuff – talked about elsewhere.</p></li>
<li><p>Regexes are really interesting. Theyʼre pointers to foreign object (compiled regexes in some library implementation). But they can be reconsistuted into equivalent objects very easily.</p></li>
</ul>
<h5 id="pickling-python-runtime-values">Pickling Python runtime values</h5>
<p>Itʼs worth getting to know the <a href="https://docs.python.org/3/library/pickle.html"><code class="python">pickle</code> module</a>ʼs capabilities and limitations, so I will just copy and paste the juicy bits here:</p>
<blockquote>
<p>The <code>pickle</code> module keeps track of the objects it has already serialized, so that later references to the same object won’t be serialized again. […]</p>
<p>This has implications both for recursive objects and object sharing. Recursive objects are objects that contain references to themselves. […] Object sharing happens when there are multiple references to the same object in different places in the object hierarchy being serialized. <code>pickle</code> stores such objects only once, and ensures that all other references point to the master copy. Shared objects remain shared, which can be very important for mutable objects.</p>
</blockquote>
<blockquote>
<p><code>pickle</code> can save and restore class instances transparently, however the class definition must be importable and live in the same module as when the object was stored.</p>
</blockquote>
<blockquote>
<p>Note that functions (built-in and user-defined) are pickled by fully <a href="https://docs.python.org/3/glossary.html#term-qualified-name">qualified name</a>, not by value. <a href="https://docs.python.org/3/library/pickle.html#id8">[2]</a> This means that only the function name is pickled, along with the name of the containing module and classes. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. <a href="https://docs.python.org/3/library/pickle.html#id9">[3]</a></p>
</blockquote>
<blockquote>
<p>Similarly, when class instances are pickled, their class’s code and data are not pickled along with them. Only the instance data are pickled. This is done on purpose, so you can fix bugs in a class or add methods to the class and still load objects that were created with an earlier version of the class. If you plan to have long-lived objects that will see many versions of a class, it may be worthwhile to put a version number in the objects so that suitable conversions can be made by the class’s <code>__setstate__()</code> method.</p>
</blockquote>
<p>This last quote raises an important point: there is some aspect of intent when restoring data to a new runtime. Just because you named the class or function the same, does not mean it is the same class or function! But it is a good marker of intent and worth preserving.</p>
<h3 id="others">Others</h3>
<h4 id="go-java">Go, Java, …</h4>
<p>I actually donʼt know a whole lot about Go or Java.</p>
<p>But they need some structure, at least for garbage collection purposes!</p>
<p>“Heap layout”.</p>
<p>Basically every runtime <em>at least</em> needs to keep track of which piece of data is a pointer or not.</p>
<h4 id="rust">Rust</h4>
<p>dunno?</p>
<h4 id="cc">C/C++</h4>
<p>Uh, yeah. Good luck.</p>
<p>Pointers “are” numbers? What the fuck?!</p>
<p>Clearly thereʼs nothing much we can say about coherent semantics … without getting really deep into the weeds of what is and isnʼt undefined behavior and why.</p>
<p>However, it does reinforce the point: at a very very basic level, OSes and memory management and stuff are about managing the graph of live pointers –&nbsp;it is just very very hard to determine what bytes are actually live pointers at any given point in a C program, and what bytes are other kinds of data.</p>
<h2 id="nasal-scripting-language">Nasal Scripting Language</h2>
<p>Yeah, it gets its own section and backstory!!</p>
<p><a href="https://wiki.flightgear.org/Nasal_scripting_language">Nasal</a> is a small embedded scripting language. Its name stands for “Not another scripting language”.<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> Its only notable use is in the <a href="https://wiki.flightgear.org/Main_Page">FlightGear open-source flight simulator</a>, although <a href="https://kymatica.com/apps/algoscore">AlgoScore</a> and a tiny handful of other tiny projects use it.</p>
<p>Its data model is basically JavaScript, but simpler and better. (Arrays are their own data type, are not allowed to be sparse, and you can actually iterate over collections in a sensible manner. Good riddance to Lua and JavaScript. Ugh.)</p>
<p>It has some metaprogramming facilities by default, plus I prototyped some more of my own, including full bytecode decompilation.</p>
<p>Finally it has this one special function: <code class="javascript">id(obj)</code>. It returns a string representation of the (stable) pointer for any object!</p>
<pre class="javascript" data-lang="Nasal"><code>&gt;&gt;&gt; id([])
'vec:0x7fea11014c40'</code></pre>
<p>I mean, I guess it is like the <code class="python">id()</code> function in Python … Yeah, both use mark/sweep GCs, so pointers are stable.</p>
<p>Anyways, the other great thing about Nasal is that objects donʼt have constructors! It is so liberating.</p>
<h3 id="pickling-nasal-runtime-values">Pickling Nasal runtime values</h3>
<p>Pickling consists of writing out a file that, when executed, returns an equivalent object. (The body of a file is simply a function. Plus all statements are expressions – they have a return value, although sometimes it is a pretty useless return value.)</p>
<ul>
<li>You initialize a hashmap of object ids that have been seen.</li>
<li>For each object you see, you look at the hashmap:
<ul>
<li>If not, you add the reference to the hashmap, and add a variable to the file to save the reference in case you need it later.</li>
<li>If it exists, you insert code to reference the existing variable and stop walking the structure.</li>
</ul></li>
<li>For non-recursive data, you just set it directly.</li>
<li>For recursive data (objects and arrays), to handle cyclic references you may need to initialize it to an empty value and add items via mutation. Thus when those items mention their (grand)parent, that reference already exists in a variable, and the rest of the structure will continue to be built as necessary.</li>
</ul>
<p>In lieu of a hashmap, you could even use a list of objects, and traverse it in linear time to compare referential identity. This is possible in most dynamic languages, just really slow.</p>
<h3 id="functions-builtins-bootstrapping">Functions, builtins, bootstrapping</h3>
<p>I also tried to work on a bootstrapping system for Nasal. I never completed it.</p>
<p>Anyways, this is relevant because I did add bytecode decompilation for functions. You could already inspect bound scopes of closures, and callers and local scopes of the call stack. All that was left was builtins (which donʼt have bytecode).</p>
<p>If you have a contract with the bootstrapping system, you could look up the globally accessible names for the builtin functions that you could not decompile, and hopefully assume that equivalent builtin functions would live in those same spots on the next bootstrapping too.</p>
<p>The problem, still, is builtin external references, like files and such. Some could be supported on a case-by-case basis, but not everything.</p>
<p>Also, ideally you would airgap<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> the builtins, since some builtins are fake builtins. That is, they are wrappers over actual builtin functions, but you could only access those builtins through the closure of the wrapped function – so you might as well stop bytecode decompilation for the wrapped functions (by wrapping the decompiler!) and treat them as builtins.</p>
<p>Anyways, in theory you would almost be able to save the entire state of a running Nasal system and fully reconstitute it under an equivalent bootstrapped environment. At the very least, you would expect to be able to save complicated data with simple functions.</p>
<h3 id="equivalence">Equivalence</h3>
<p>The pickling process points towards a method of determining equivalence. Obviously you should sort the file in some semantic way, and rename variables to less arbitrary things. Maybe normalize the bytecode for functions.</p>
<p>After that, you should just be able to compare your resulting files and use that as a notion of equivalence!</p>
<p>Alternatively, you could write out a direct algorithm: take two objects at runtime and walk them recursively with the same kind of hashmap trick, comparing at which paths you see the objects, and then just make sure the shared references appear at the same minimal-paths from the root across their sharings. (You want to avoid cyclic recursions, of course, which does mean you will only look at minimal paths.)</p>
<p>Iʼll call this … “graph equality”? “Stable equality”? It is what Iʼve meant by “equivalence” all along.</p>
<h3 id="ghost-objects-foreigns-property-tree">Ghost objects (foreigns), property tree</h3>
<p>Nasal has a concept of “ghost” objects which are pointers to foreign objects, literally just C pointers with some associated data to help the garbage collector.</p>
<p>These are constructed by C APIs, and the only way to reconstruct them would be if you can call those APIs again to produce equivalent objects – which may not always be possible.</p>
<p>One of the main foreign interfaces of Nasal is <a href="https://wiki.flightgear.org/Property_tree">FlightGearʼs property tree</a> – a central store of important simulator values that is accessible from all of FlightGearʼs subsystems, not just Nasal. References to these nodes can be stored (making use of ghost objects) and manipulated through <a href="https://wiki.flightgear.org/Nasal_library/props">an API</a>, in a way that is somewhat like accessing the DOM in JavaScript.</p>
<p>This is one type of ghost reference that could easily be handled by a pickling script: since the path of the node is available, you just have to serialize that, and then obtain the node again when deserializing. However, there still is some rough edges: what if the node doesnʼt exist when it is getting loaded again? It could be possibly recreated, but now the deserialization has side-effects, which is weird. Or a separate property tree could be created to sandbox the script, and relevant nodes created there.</p>
<p>Property trees can also be saved to XML and loaded from there, although there are various details that donʼt translate well regardless of serialization format. One example is properties that are managed by C++ code, instead of having their data be managed by the property tree – but those properties typically exist by the time Nasal is initialized.</p>
<p>So thereʼs always some details that need to be figured out or approximated when dealing with external APIs and data that is not managed in the language itself.</p>
<h3 id="strings-1">Strings</h3>
<p>Nasal strings were actually a fun challenge. It has mutable strings!</p>
<p>It has immutable interned strings, which are cached in a global lookup table. This is used for identifiers (including object keys), to speed up comparisons.</p>
<p>It also has mutable strings (and I believe they can be mutated to be immutable? it is a little weird).</p>
<p>The referential identity of strings is not exposed – the equality operator ignores it. However, you can still determine whether two mutable strings are the same reference, by using test mutation: if you mutate one and the other stays the same, they are different references.</p>
<p>(You can even use missed fast comparisons to determine if a string is interned or not.)</p>
<h2 id="broader-thoughts">Broader Thoughts</h2>
<p>The main thing I want you to take away is that dynamic runtimes donʼt have to be scary places filled with spaghetti data flying around all over the place. Itʼs actually possible to tame mutable references in many ways!</p>
<p>The concrete lesson is that there are three useful notions of equivalence, that are used for characterizing what levle of abstraction of “data” we want to be looking at, and I think the middle one is much more important than we give it credit for:</p>
<ul>
<li>Referential equality, which treats everything as live, mutable references, but is too fine-grained and doesnʼt make sense across restarting the program. This is the notion of equality that your runtime (and particularly its garbage collector) is tasked with preserving for your code.</li>
<li>My new notion of equivalence, which I will call “graph equality of mutable data”, which keeps track of shared mutable references and so on.</li>
<li>The notion of <a href="https://lodash.com/docs/#isEqual">“deep equality”</a> of objects, which treats them mostly as if they are immutable data. (I didnʼt talk about it at all, whoops, but I assume you are familiar with it.) It can be very useful, but it acts a lot like traditional serialization, and isnʼt comprehensive enough to actually probe the whole of a running system.</li>
</ul>
<p>So while referential equality forms your basic data model of a language, I encourage thinking about equivalence. <strong>If you could swap out two objects completely</strong> (including <em>existing</em> references to them), <strong>would you be able to notice?</strong></p>
<p>And then you need to keep abstracting away what you care about. Do you care about exact hash values? Do you store those hash values in a way that would make reconstruction fail to mean the same thing with a different random seed? And so on.</p>
<p>So thereʼs still domain-specific work to be done, as there always is.</p>
<div class="Key_Idea">
<p>But if we can expose the underlying graph of referential relationships, we have a much much MUCH larger toolbox for working with data and data serialization.</p>
</div>
<h3 id="graph-equality-of-mutable-data">Graph equality of mutable data</h3>
<div class="Key_Idea">
<p>Is (shallow) referential equality the best we can do? What about deep (explicitly non-referential) equality?</p>
<p>Emphatically no – but, it is probably not worth it.</p>
<p>See, we could have the notion of equality that pickling and unpickling preserve. Graph equality, where the sharing of mutable references is tracked and tabulated by their role, instead of exact referential identity.<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></p>
<p>If you have two data graphs where pointers are shared in equivalent ways, sure, they could totally be considered parallel universes and interchangeable amongst themselves. (Obviously if something external holds references to them and you donʼt have a way to swap them out, this can break.)</p>
</div>
<p>The only problem is that it is pretty expensive, it requires a <em>lot</em> of bookkeeping, and most people generally donʼt care – they are fine either writing the equality comparison they need, or settling for the standard deep equality.</p>
<p>However, it is very useful!</p>
<p>Like, as one example, this is literally what <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-StableName.html">stable names</a> are used for.</p>
<div class="Key_Idea">
<p>Runtimes are literally built on graphs!</p>
<p>We want to be able to touch this. To expose it, to hold it in our hands. To work with it, to meld it to our own needs. To chart our own course through the graph, traversing references and recording where weʼve already visited.</p>
<p>We can have very nice things if we give up the dichotomy of referential identity versus deep equality, and embrace the graph nature of runtimes.</p>
</div>
<h3 id="constructors">Constructors</h3>
<p>As part of these musings on data, I subscribe to the idea that the only objects that should have constructors (at the level of data – obviously client code will want different abstractions) are objects that are constructed from external references, FFI.</p>
<p>Idk, constructors in the sense of mainstream OOP are mostly a distraction for this view of data I want to talk about. They just arenʼt good, arenʼt necessary, they get in the way – especially since the arguments to the constructors donʼt have to correspond to the runtime data of the object at all.</p>
<h2 id="appendix">Appendix</h2>
<p>Miscellaneous thoughts that donʼt belong in the conclusion but do belong at the end.</p>
<h3 id="uses-of-references">Uses of references</h3>
<p>You really should not be able to ask for two references to be ordered against each other: it doesnʼt mean anything with regards to the <em>meaning</em> of the program (although it may record some historical data about how the program <em>did</em> happen to run). But you kind of should be able to put them into a map efficiently, and ordering/hashing is potentially important for that, but only if it can be stable.</p>
<p>Mark/sweep GC is good for stability of pointers (and thus comparisons). I think mark/compact still can preserve comparisons.</p>
<p>Weak references are interesting. Every time Iʼve wanted weak references, Iʼve always actually wanted to do them as reverse references: data stored on the key object, instead of in a map indexed by the key object. (Of course this may leak memory if the map you want to store is not long-term/global.)</p>
<h3 id="abstract-model-for-gcable-data">Abstract model for <span data-t="" data-widget="">GCable</span> data</h3>
<p>I think itʼs instructive to pin down a model of garbage collectable data in Haskell/PureScript, where we can talk about references separately from pure data structures.</p>
<p>This is enough to model the fragment of JavaScript values I said should be covered by the pickling function I sketched. (Well, you could easily add <code class="javascript">undefined</code>.)</p>
<details class="Details">
<summary>
Code
</summary>
<pre class="haskell"><code>-- The managed heap for the runtime data.
-- I believe this is what rustaceans
-- call an arena?
newtype Heap s metadata shape = Heap
  (MVector s (RuntimeData shape, metadata))

data RuntimeData shape
  -- Runtime data is given by a pure shape
  -- (which needs to be `Traversable`!)
  -- which contains runtime references
  -- in a known way
  = RuntimeData (shape RuntimeRef)
  -- It can also be an external “ghost”
  -- reference that we have a function
  -- to destruct (or dereference, if
  -- it is shared data)
  | ExternalGhost Ptr (IO ())

-- A managed reference we control,
-- thus it is an opaque pointer
-- into the opaque memory heap
data RuntimeRef
  = ManagedOpaque Int
  deriving (Eq, Ord)
  -- ^ the user is allowed `Eq`
  --   but not `Ord`

-- An example shape for mutable data
-- in the spirit of JSON (the only
-- reason it is not JSON is that JSON
-- is immutable, being a serialization
-- format, strictly speaking)

-- A JSON value, either a plain value
-- or a reference to a mutable value
data JSONValue ref
  = Null
  | Number Scientific
  | String Text
  | ByRef ref
  deriving (Eq, Ord, Functor, Foldable, Traversable)

-- What data lies behind a mutable value?
data JSONShape ref
  = Array [JSONValue ref]
  | Object [(Text, JSONValue ref)]
  deriving (Eq, Ord, Functor, Foldable, Traversable)

-- If we take the immediate fixpoint,
-- without mutable references in the
-- loop, we get plain immutable JSON data,
-- except that it is lazy, so it is
-- potentially infinite
newtype JSON = JSON (JSONValue JSON)

data Idx
  = ArrayIdx Int
  | ObjectIdx Text

-- A machine for creating a graph in
-- the mutable JSON structure
data Machine ref
  = SetKey ref Text (JSONValue ref) (Machine ref)
  | Push ref (JSONValue ref) (Machine ref)
  | Get ref Idx (JSONValue ref -&gt; Machine ref)
  | NewArray (ref -&gt; Machine ref)
  | NewObject (ref -&gt; Machine ref)
  | Return (JSONValue ref)</code></pre>
<p>Now we can talk about the concepts from above.</p>
<pre class="haskell"><code>equal :: Eq ref =&gt;
  JSONValue ref -&gt;
  JSONValue ref -&gt;
  Boolean
equal = (==)

-- Since Haskell is lazy,
-- JSON is a greatest fixpoint,
-- so, with some care, I believe
-- you could even reify recursive
-- data into the JSON type
-- (but `Eq` would not terminate)
snapshot ::
  (ref -&gt; m (JSONShape ref)) -&gt;
  JSONValue ref -&gt; m JSON

deepEq ::
  (ref -&gt; m (JSONShape ref)) -&gt;
  JSONValue ref -&gt;
  JSONValue ref -&gt;
  m Boolean
deepEq read x y = do
  m &lt;- snapshot read x
  n &lt;- snapshot read y
  -- compare as JSON
  pure (m == n)

equivalent :: Ord ref =&gt;
  (ref -&gt; m (JSONShape ref)) -&gt;
  JSONValue ref -&gt;
  JSONValue ref -&gt;
  m Boolean
equivalent read l0 r0 =
  runStateT (comparing [] (l0, r0)) empty
  where
  comparing ::
    [Idx] -&gt;
    (JSONValue ref, JSONValue ref) -&gt;
    StateT (Map ref [Idx], Map ref [Idx]) m Boolean
  comparing path (l, r) =
    -- Try to match up the values
    case zipMatch l r of
      -- They are both references
      Just (ByRef (ll, rr)) -&gt; do
        -- First we check if we should short circuit
        -- if they have been seen before
        (seenL, seenR) &lt;- get
        case (lookup ll seenL, lookup rr seenR) of
          -- Seen both
          (Just p1, Just p2) -&gt; do
            -- We have to have seen them at the same path,
            -- since we are traversing in the same order
            pure (p1 == p2)
          -- Seen neither
          Nothing, Nothing -&gt; do
            -- Keep track of where we saw this
            -- reference, separately for left and right
            -- (since it is valid for both to use the
            -- same reference for different purposes)
            modify
              (insert ll path *** insert rr path)
            -- Read the current values of the reference
            x &lt;- lift (read ll)
            y &lt;- lift (read rr)
            -- Try to match them up
            case zipMatch x y of
              -- Failed: different types
              Nothing -&gt; pure False
              -- Similar arrays: recurse into children
              Just (Array xys) -&gt;
                allM (uncurry comparing)
                  -- Add the index onto the path
                  (intoArray path &lt;$&gt; enumerate xys)
              -- Similar objects: recurse into children
              Just (Object xys) -&gt;
                allM (uncurry comparing)
                  -- Add the key onto the path
                  (intoObject path &lt;$&gt; xys)
          -- Failed: seen one but not the other
          _, _ -&gt; pure False
      -- Succeed if it is a pure value
      -- that is equal on both sides
      lr -&gt; pure (isJust lr)

intoArray path = first $ \idx -&gt; ArrayIdx idx : path
intoObject path = first $ \key -&gt; ObjectIdx key : path</code></pre>
</details>
<p>Hopefully you can see from the implementation of the <code class="haskell">equivalent</code> function how two distinct references can still be interchangeable for all intents and purposes. We could write out this interchange formally, since all the references are visible on the heap, and then state some theorems about some functions.</p>
<p>However, for other processing, we donʼt even really need this arena/managed heap. We can use the Haskell runtime itself!</p>
<p>I havenʼt worked out the details (<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-StableName.html">stable names</a>?), but we should be able to reify the graph of a cyclic <code class="haskell">JSON</code> value too.</p>
<div class="Warning">
<p>The main difference is that, in Haskell, the infinite <code class="haskell">JSON</code> could be truly infinite (like, procedurally generated) – it does not need to be backed by a finite amount of data like it would be in JavaScript.</p>
</div>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Except in Rust, I think?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Leibniz equality, “Identity of indiscernibles”<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>besides performance – we always disregard performance here<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Citation needed.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Sighs in <a href="https://cofree.coffee/~verity/tmttmt.html">tmTTmt</a> …<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Even in non-Turing-complete languages!<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>This is slightly unfair, considering that Dhall now uses <span data-t="" data-widget="">NbE</span>, but it amounts to the same thing.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>BEAM uses mutation to construct data locally, but this is only an implementation detail that cannot be observed from Erlang.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>inasmuch as a concurrent system can have a current state …<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>See §3.2 “Stable Names”.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>JS arrays can be sparse. Still mad about that.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p><a href="https://github.com/andyross/nasal/blob/088be4d3642f696ad99bad3c79d15b692b368934/www/index.html#L182-L186">“Nasl” was already taken</a><a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Sorry, wrong word.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>think: pointer<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
<item>
<title>A Semiring From Any Semilattice</title>
<pubDate>Sat, 28 Oct 2023 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/semilattice_semiring.html</guid>
<description><![CDATA[<p>Iʼve been working on some theoretical aspects of programming recently. Writing new compiler optimization passes. Thinking about <a href="https://github.com/MonoidMusician/blog/blob/main/PureScript/src/Parser/Languages/Talk.purs">parsers</a> through the lens of <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective">selective applicative functors</a>, and tweaking them to encode <a href="https://github.com/MonoidMusician/blog/blob/main/PureScript/src/Parser/Selective.purs">exclusive choice</a>.</p>
<p>If you go far enough down the rabbit hole, it turns out that you want semirings for static analysis. This is not unheard of in compilers! Itʼs a really good technique for analyzing control flow, for example: information about exclusive branches are combined additively, and information from sequential operations are combined multiplicatively. It is especially appropriate because, semantically speaking, you want those sequential operations to distribute over the branching.</p>
<p>(You can already see this in more typical typeclasses like <code class="haskell">Alternative</code>, which is naturally analyzed by taking <code class="haskell">&lt;*&gt;</code> to <code class="haskell">*</code> and <code class="haskell">&lt;|&gt;</code> to <code class="haskell">+</code>. Itʼs just that Iʼm interested in augmenting <code class="haskell">Selective</code> to encode exclusive choice too.)</p>
<p>This led me to come up with this construction: how to make a semiring out of a semilattice.</p>
<p>This construction answers the question, “if you need a semiring for static analysis, how do you also keep other data around that does not care about the branching structure?” (like, say, a monoid).</p>
<div class="Details">
<p>Specifically in selective applicative parsers, I need it to answer the question of why aggregating information about the grammar is a valid thing to do across parser combinator segments, no matter how they are combined.</p>
<p>And in the compiler pass I was doing, I was implementing demand analysis via semirings (especially the <a href="https://en.wikipedia.org/wiki/Tropical_semiring">min tropical semiring</a>). I actually donʼt have specific information I was considering aggregating as a semilattice, but it was a possibility that might come up, especially if I want to fuse some passes together. Right now my one pass is really three traversals of the tree, with various monad stacks of reader, writer, and state. (Yes I used all three.)</p>
</div>
<p>I don’t know if this construction is well-known! Let me know if you have a reference for it.</p>
<div class="Key_Idea" data-box-name="tl;dr">
<p>You can make a semiring out of a semilattice by adjoining a new zero element. Lifting the semilattice operation in the two obvious ways gives you <code class="haskell">+</code> and <code class="haskell">*</code>. Idempotence gives distributivity(!).</p>
</div>
<h2 id="background">Background</h2>
<p>(Bounded) semilattices are commutative monoids whose operation is also idempotent: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \diamond x = x</annotation></semantics></math></span> for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span>.</p>
<p>I will write the monoid operation as <code class="haskell">x &lt;&gt; y</code> and as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \diamond y</annotation></semantics></math></span>, and the empty element as <code class="haskell">mempty</code> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span>. </p>
<div class="Bonus">
<p>Semilattices have deep connections to order theory: they induce a really nice preorder given by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \leq y</annotation></semantics></math></span> when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \diamond y = x</annotation></semantics></math></span> (or vice-versa, depending on whether you are talking about meet or join semilattices – and no, I cannot keep them straight 🏳️‍🌈). But we donʼt need the order theory here.</p>
</div>
<p>Semirings are rings without subtraction: just addition and multiplication and their identities, zero and one, respectively. And <a href="#distributivity">distributivity</a> and <a href="#annihilation">annihilation</a> laws to intertwine these two monoids.</p>
<p>The funny part of this is that “semi-” means different things: semirings are just missing subtraction (kind of a weird use of semi, which is why some call them <a href="https://ncatlab.org/nlab/show/rig">rigs</a>), but semilattices are literally half of a lattice (one idempotent commutative monoid instead of two interlinked).</p>
<p>(Lattices are actually closely related to semirings: they have the same shape of operations, and you can turn every bounded <em>distributive</em> lattice into a semiring – in two ways, in fact, since you can make a lattice with the opposite order.)</p>
<p>So itʼs like a mathematical joke that they can be related to each other at all!</p>
<p>How do we get two monoids out of one??</p>
<h2 id="description">Description</h2>
<p>The key idea is to adjoin a zero. Thatʼs it.</p>
<p>The rest of the moves can be determined from that premise, so letʼs see how it works:</p>
<pre class="purescript"><code>data WithZero t = Zero | NonZero t

-- Imagine that `t` is really a `Semilattice`
-- (this does not exist as a class in PureScript)
instance Monoid t =&gt; Semiring (WithZero t) where
  zero = Zero
  one = NonZero mempty

  add Zero Zero = Zero
  add Zero r = r
  add l Zero = l
  add (NonZero l) (NonZero r) = NonZero (l &lt;&gt; r)

  mul (NonZero l) (NonZero r) = NonZero (l &lt;&gt; r)
  mul _ _ = Zero</code></pre>
<p>The two operations are the semilattice operation lifted through <code class="haskell">Maybe</code> in the two possible ways:</p>
<ul>
<li><code class="haskell">add</code> follows the pattern of the default <code class="haskell">Semigroup a =&gt; Monoid (Maybe a)</code> instance, that uses <code class="haskell">Nothing</code> as its identity. This makes sense since weʼre adding <code class="haskell">Zero</code>, the identity for <code class="haskell">add</code>. Indeed, it is forced by the laws, and the fact that we only have one binary operation to use.</li>
<li><code class="haskell">mul</code> is like the other possible instance, <code class="haskell">Monoid a =&gt; Monoid (App Maybe a)</code>, formed by <code class="haskell">(&lt;&gt;) = lift2 (&lt;&gt;)</code>. This is likewise forced by the annihilation law and the fact that we only have one binary operation to use.</li>
</ul>
<h2 id="laws">Laws</h2>
<p>Iʼm going to be lazy and use math notation for the laws, with the understanding that when I say <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \neq 0</annotation></semantics></math></span> for example, it means in Haskell/PureScript that <code class="haskell">x = NonZero x' :: WithZero t</code> for some unique <code class="haskell">x' :: t</code>, and if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x, y \neq 0</annotation></semantics></math></span> then <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \diamond y</annotation></semantics></math></span> means <code class="haskell">NonZero (x' &lt;&gt; y')</code>.</p>
<h3 id="distributivity">Distributivity</h3>
<p>The fun part is the left and right distributivity laws:</p>
<p>To prove left distributivity, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>∗</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x * (y + z) = x * y + x * z</annotation></semantics></math></span>, we look at some cases:</p>
<ul>
<li>If <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span>, then we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo>=</mo><mn>0</mn><mo>∗</mo><mi>y</mi><mo>+</mo><mn>0</mn><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">0 * (y + z) = 0 = 0 * y + 0 * x</annotation></semantics></math></span>.</li>
<li>If <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y = 0</annotation></semantics></math></span>, then we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mn>0</mn><mo>+</mo><mi>x</mi><mo>∗</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x * (0 + z) = x * z = x * 0 + x * z</annotation></semantics></math></span>.</li>
<li>If <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z = 0</annotation></semantics></math></span>, then we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo>+</mo><mi>x</mi><mo>∗</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x * (y + 0) = x * y = x * y + x * 0</annotation></semantics></math></span> similarly.</li>
<li>So now we can assume that all three variables are nonzero. But that means we fall back to the underlying semilattice operation: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>⋄</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x \diamond (y \diamond z) = (x \diamond y) \diamond (x \diamond z).</annotation></semantics></math></span> But by commutativity and associativity, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(x \diamond y) \diamond (x \diamond z) = (x \diamond x) \diamond (y \diamond z).</annotation></semantics></math></span> And finally we finish off with idempotence: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>⋄</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">x \diamond (y \diamond z).</annotation></semantics></math></span></li>
</ul>
<p>We prove right distributivity in the same way <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mi>z</mi><mo>+</mo><mi>y</mi><mo>∗</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">(x * y) + z = x * z + y * z</annotation></semantics></math></span>, based on the calculation <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⋄</mo><mo stretchy="false">(</mo><mi>z</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(x \diamond z) \diamond (y \diamond z) = (x \diamond y) \diamond (z \diamond z).</annotation></semantics></math></span></p>
<p>The takeaway is that <strong>idempotence of the semilattice gives us distributivity of the semiring</strong>. This is why having a semilattice and not merely a monoid is essential.</p>
<p>This does make some sense: if weʼre aggregating information that does not care about branching structure at all, well, semilattices are great models for accumulating knowledge. Idempotence says you only learn a fact once.</p>
<div class="Bonus" data-box-name="Generalizing">
<p>We donʼt require multiplication to be commutative, so if you drop the left-distributivity law, you could get away with a <a href="https://en.m.wikipedia.org/wiki/Band_(algebra)#Right-regular_bands">right-regular band</a> with the law <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mi>y</mi><mo>⋄</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>⋄</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \diamond y \diamond x = y \diamond x</annotation></semantics></math></span>.</p>
<p>I think left-distributivity is a bit weirder than right-distributivity, in the context of control flow. Right distributivity just says you can copy any training code into each case branch.</p>
<p>However, in general Iʼm a fan of left-regular bands, since they intuitively preserve order.</p>
<p>Also, to be fair, you could absolutely disregard some semiring laws for the sake of static analysis of programs: you donʼt always want to treat programs as purely algebraic structures, and often want to dig into the details of how they were constructed.</p>
<p>Like, if youʼve factored out common control flow, thatʼs almost always for a reason! So your static analysis should reflect that.</p>
</div>
<h3 id="annihilation">Annihilation</h3>
<p>We made this true by definition of <code class="haskell">mul</code>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∗</mo><mi>x</mi><mo>=</mo><mn>0</mn><mo>=</mo><mi>x</mi><mo>∗</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 * x = 0 = x * 0</annotation></semantics></math></span>.</p>
<h3 id="additive-monoid">Additive monoid</h3>
<h4 id="identity">Identity</h4>
<p>We also made <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>+</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0 + x = x = x + 0</annotation></semantics></math></span> true by definition of <code class="haskell">add</code>.</p>
<h4 id="associativity">Associativity</h4>
<p>So we just need to prove that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x + (y + z) = (x + y) + z</annotation></semantics></math></span> for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x, y, z \neq 0</annotation></semantics></math></span>. But that follows from the semilatticeʼs associativity: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mo stretchy="false">(</mo><mi>y</mi><mo>⋄</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy="false">)</mo><mo>⋄</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x \diamond (y \diamond z) = (x \diamond y) \diamond z</annotation></semantics></math></span>.</p>
<h4 id="commutativity">Commutativity</h4>
<p>Yes.</p>
<h3 id="multiplicative-monoid">Multiplicative monoid</h3>
<h4 id="identity-1">Identity</h4>
<p>For <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 * x = x = x * 1</annotation></semantics></math></span>, we need two cases: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \neq 0</annotation></semantics></math></span>. But if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x = 0</annotation></semantics></math></span>, it is trivial still. (This is the nice way the identities and annihilator elements interact. They donʼt add any proof burden to the other.)</p>
<p>So for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \neq 0</annotation></semantics></math></span> (and since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">1 \neq 0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span> is given by the semilatticeʼs identity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span>), we look at the underlying semilattice and find that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>⋄</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>=</mo><mi>x</mi><mo>⋄</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">e \diamond x = x = x \diamond e</annotation></semantics></math></span> as we want.</p>
<h4 id="associativity-1">Associativity</h4>
<p>Same case analysis as usual: if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x, y, z \neq 0</annotation></semantics></math></span> then we get associativity from the semilattice, otherwise both sides equal <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span> by the power of the annihilator.</p>
<h4 id="commutativity-1">Commutativity</h4>
<p>Yes.</p>
<h3 id="absorption-laws-fail">Absorption laws fail</h3>
<p>Note that we cannot make a lattice out of the semilattice – thatʼs a step too far. Intuitively from the order theory point of view, thereʼs no reason why would would be able to, since the meet and join operations of a lattice have opposite views of the preorder of the lattice.</p>
<p>And algebraically, the two absorption laws would fail in general: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x * (x + y) = x</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x + (x * y) = x</annotation></semantics></math></span> (even stating them like that looks weird). For <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \neq 0</annotation></semantics></math></span>, by idempotence of the semilattice we would see <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⋄</mo><mo stretchy="false">(</mo><mi>x</mi><mo>⋄</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>⋄</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \diamond (x \diamond y) = x \diamond y</annotation></semantics></math></span>, which only equals <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span> if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">y = e</annotation></semantics></math></span>. Thereʼs just no way to get rid of the extra <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span> there if we are sticking to one operation.</p>
<h2 id="iterating">Iterating</h2>
<p>You could technically iterate this construction, since <code class="haskell">add</code> and <code class="haskell">mul</code> are both idempotent, commutative, associative operations now. However itʼs not terribly interesting.</p>
<p>You end up adjoining some number of identities and annihilators to the underlying semilattice. (New top/bottom elements, depending on which way you look at it.) The order that you do this in does not matter, only how many times you choose to do each way.</p>
<h2 id="additional-comments">Additional comments</h2>
<p>Want a semiring without zero? No need to adjoin a zero, then – just use the same carrier type. The remaining laws still just work.</p>
<p>For static analysis, the zero is only good for representing unreachable/error cases. But the identity of the semilattice is indispensible: itʼs the empty analysis for when you know nothing yet or have nothing to contribute.</p>
<p>Important to note that all of these algebraic constructs (monoids, semilattices, semirings<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>) are closed under taking products. This is why I said “how do you <em>also</em> keep other data around” in the introduction.</p>
<h3 id="explaining-to-non-mathematicians">Explaining to non-mathematicians</h3>
<p>The concept of a semiring is an abstract conception of what a number is. A particular semiring is a specific conception of what can be a number. We can manipulate these “numbers” in the familiar ways – mostly.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>but <strong>not</strong> fields<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
<item>
<title>TransMorphism Type Theory MetaTheory</title>
<pubDate>Fri, 13 Oct 2023 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/tmttmt.html</guid>
<description><![CDATA[<p><span style="display: block;text-align: center;font-size:1.2em">🦋 <em>heck u! *programs ur semicolons :3*</em> 🦋</span></p>
<p>Iʼve been dreaming of making my own metalanguage for writing type theories for many years now. I havenʼt implemented much yet, but Iʼve been refining my ideas. Hereʼs a tiny taste:</p>
<p><em>What you write:</em></p>
<pre class="js" data-lang="tmTTmt"><code>// If we are casing on a known boolean, we know which case to choose
normalize/ ["if" "true" "then" exprT "else" exprF] =&gt; exprT;
normalize/ ["if" "false" "then" exprT "else" exprF] =&gt; exprF;
// If both branches have the same value, the boolean is irrelevant
// This is an example of non-linear pattern matching, which will get desugared
normalize/ ["if" _cond "then" expr "else" expr] =&gt; expr;
// Fallback case, including most other nodes not specified
normalize/ layer =&gt; normalized:
  // ^ We compute the result, `normalized`, by following these operation(s):
  // Recursively calling normalize on each child node of this node
  // (that's it, that's the only operation in this case, but there could be more)
  map normalize layer =&gt; normalized
  // ^ okay this line probably needs tweaking for type inference ...</code></pre>
<p><em>What it means:</em></p>
<pre class="haskell"><code>normalize (Roll (IfThenElse metadata cond exprT exprF)) =
  case normalize cond of
    -- Note that "true" above is allowed to stand for the literal in the AST
    -- (as well as the Boolean type in tmTTmt itself), but in Haskell we need
    -- an explicit constructor `BooleanLiteral` to embed it in the AST:
    BooleanLiteral True -&gt; exprT
    BooleanLiteral False -&gt; exprF
    condN -&gt;
      let (exprTN, exprFN) = (normalize exprT, normalize exprF)
      in case areEqual exprTN exprFN of
        -- Every time we equate two expressions, especially though matching on
        -- the same variable name twice, we return a unified node, so that we
        -- have a chance to merge *metadata* when the underlying *data* is
        -- the same. In typechecking, unifying can also unify metavariables,
        -- through algebraic effects or something.
        Just exprN -&gt;
          exprN
        -- We fall back to the `map` operation, special cased for the node we
        -- already matched here. We can pass the metadata through to the result,
        -- or update it -- but how?? It will be specified in other places,
        -- e.g. through typeclasses and auxiliary functions ...
        Nothing -&gt;
          Roll (IfThenElse (updateMetadata?? metadata) condN exprTN exprFN)
normalize (Roll layer) = Roll (map normalize layer)</code></pre>
<p>I want to skew to the left of many design choices that have been made for most languages, aiming for very specific tradeoffs to achieve aesthetics and functionality.</p>
<p>My goal is to have a syntax that is straightforward for humans to write and easy for computers to interpret.</p>
<p>But I donʼt want this process to be magic! I just want it to look convenient for writing powerful systems of type theory.</p>
<h2 id="implementation">Implementation</h2>
<p>AAaaahhhh</p>
<div class="widget" data-widget="Widget.Query" data-widget-empty="true" data-widget-datakey="default" data-widget-data-keys="tmttmt-example">

</div>
<div class="widget" data-widget="Parser.Main.TMTTMT" data-widget-datakey="default" data-widget-loading="true" style="display: contents" data-widget-data-example="uncurry/ f [a b] => r1:
  f a b => r1
curry/ f c d => r2:
  f [c d] => r2
identity/ x => x;
tuple/ y z => [y z];
test/ [g] [h] => [g h];
tset/ [[i] [j]] => [i j];
> uncurry tuple [&quot;1&quot; &quot;2&quot;]
> uncurry test [[&quot;3&quot;] [&quot;4&quot;]]
> curry identity &quot;5&quot; &quot;6&quot;
> curry tset [&quot;7&quot;] [&quot;8&quot;]
">

</div>
<h2 id="motivation">Motivation</h2>
<p>My problem with existing programming languages is that they are too heavily tied to a fixed logic of computation: ADTs in Haskell are great (especially for language design!), at least right up until you need to add extra data to your ADTs, and now that infects your whole program with ugliness and bookkeeping.</p>
<p>In general, <strong>this distinction between data and metadata</strong> is so <em>crucially</em> important to me. And not something that is really considered in any typed programming language! Data has always gotten tied directly to the logic you are working in, and metadata was given no freedom to roam around. So letʼs unleash them. Let it loose :3</p>
<div class="Example">
<p>As a very concrete example of this, imagine caching which variables are present in each term (such as <a href="https://en.wikipedia.org/wiki/Director_string">Director strings</a>, or a simple extra <code>Set Name</code> on each node). This can be used to skip allocations when you know nothing is changing in operations that target variables. But now you need to keep track of that information literally everwhere you construct nodes in your AST! Despite it being a really simple algorithm to compute on its own, one that hopefully could be incrementally updated in most cases.</p>
<p>As another example, source spans are really tricky to keep around and get right. (I have thoughts on that – that we shouldnʼt be using source spans! – but thatʼs beside the point.) But imagine if you didnʼt have to do any work to keep them around: the logic of tmTTmt could keep that information around, and generate empty source spans for nodes that are inserted by the compiler. (With some way to optionally borrow source spans from other node(s).)</p>
<p>As a third example of why we should separate data and metadata: if we keep the identity of nodes separate from their raw data, we can keep track of which source terms interact with each other. The better you can keep track of source spans and <em>provenance</em>, the more reliable this system will be. If you keep track of which types are unified with each other, and can map them back to locations in the source, it could even tell you all of the places you need to edit if you want to change the type of something (or where you need to insert conversions).</p>
</div>
<p>If you arenʼt forced to work in the base logic of Haskell, and instead have more freedom to come up with a linguistics and logic of type theory design itself, youʼll get several benefits:</p>
<ul>
<li><p>You donʼt have to rewrite your whole compiler to introduce optimizations, like I mentioned above.</p></li>
<li><p>You could generate graphical representations of the rules, from the exact same source that the program is derived from. This would be fantastic for interactive typechecking rules, which could enhance error messages with the particular rule that failed to be derivable, and allow you to search back through the parts of the derivation that did succeed.</p>
<div class="Bonus">
<p>You may still want separate sets of rules for conventional “paper” presentations, however. Like as a term rewriting system, instead of <span data-t="" data-widget="">NbE</span>, for example. But if both of them are executable, you can test whether they are equivalent! (With QuickCheck, unit tests, or assertions.)</p>
</div></li>
<li><p><a href="https://github.com/dhall-lang/dhall-lang/issues/469">dhall-lang#469: Machine-readable semantics</a></p></li>
</ul>
<h3 id="history">History</h3>
<p>Iʼve been ranting about tmTTmt on cohost as an outlet until I have the time to actually write the darn thing: <a href="https://cohost.org/monoidmusician/tagged/tmttmt"><span class="citation" data-cites="monoidmusician">@monoidmusician</span>/#tmttmt</a>.</p>
<p>The real genesis of the project was when I was attempting to write Dhall-PureScript (many apologies for dropping the ball on that one). I wanted to go all in on extensible row types and recursion schemes. I think theyʼre awesome tools, but they proved too impractical to use in PureScript, since they wrecked the existing pattern matching facilities of the core logic of PureScript. I have also learned a lot in the meantime (<span data-t="" data-widget="">e.g.</span> about parsing, about languages like Erlang) and developed a lot more ideas. I think Iʼm ready to make it happen!</p>
<h2 id="general-design-goals">General design goals</h2>
<ul>
<li>Simple syntax, which can be easily interpreted by other programs in other ways.</li>
<li>Type-directed shenanigans. (Typeclasses, mostly. Also type-directed syntax sugar.)</li>
<li>Algebraic effects, or something. This is necessary for lightweight unification.</li>
<li>Compilation steps to get from that syntax to some core logic/runtime in some language.
<ul>
<li>Desugaring nonlinear patterns into appropriate equality/unification steps.</li>
<li>Desugaring core logic into monads/applicative(/selectives?)</li>
<li>Inlining; removing redundant steps.
<ul>
<li>In particular, it will be the expectation that these operations are safe for any custom monads/effects that users use. As an example, resolving imports in <a href="https://dhall-lang.org/">Dhall</a> requires doing disk access and network requests, but those network requests are cached during resolving, so their resolution is idempotent and redundancies can safely be removed. (And obviously if there are URLs that do not have to be resolved, thatʼs great for efficiency! Although you can argue about safety, which is why these things need to be customizable.)</li>
</ul></li>
<li>Personally I think it would be fun to target PureScript, JavaScript, Erlang … very different needs across each of those.</li>
</ul></li>
<li>Functors! I love functors.</li>
<li>Encourage healthy abstractions. I think thatʼs a great word: <em>healthy</em> abstractions.</li>
<li>I have this idea for a type system and I donʼt know if it will pan out … Something like TypeScript done better (or similar sorts of ad-hoc type systems).</li>
<li>Easy debugging and decent dev UX. Being able to dump terms in a representable/inspectable format. Being able to trace execution and focus logs. Flags to enable/disenable features. Assertions. Idk.</li>
</ul>
<h3 id="specific-design-choices">Specific design choices</h3>
<ul>
<li>Lightweight literals, type-directed.
<ul>
<li><p>A literal is a string or a list of literals or variables. (Basically reinventing lisp lol.)</p></li>
<li><p>Types are basically patterns of literals, meaning literal singleton types plus arrays and unions of types, like TypeScript but hopefully in a sensible way. Thus it is obvious what type a literal has, and then this can be subsumed by other types.</p></li>
<li><p>There are also nominal types; still figuring out the details there. The main goal is to mostly get rid of newtype wrappers, so you can just match on the constructors-as-literals you want through all the cruft. But type annotations will still be necessary to disambiguate types in some cases. And full type annotations are usually tedious, so some system of named coercions may be helpful.</p></li>
<li><div class="Key_Idea">
<p>In particular, by committing ourselves to <em>this</em> logic of <strong>literals as ground truth for comparing <em>across types</em></strong>, we can generate automatic coercions between subsets of complex types.</p>
<p>I understand why a lot of languages want literals to have distinct types (<span data-t="" data-widget="">e.g.</span> Haskell ADTs all have distinct, named constructors), but it just poses a barrier to the fluidity I want to have in this system for language design of all things. If you name something <code class="js">["if" _ "then" _ "else" _]</code> then you know what it represents! No matter if it is in the source CST, the desugared AST, or a final core pass …</p>
</div>
<p>In some target runtimes, if they are faithful to the literals, these will be actual zero-cost coercions. However, because the expectation is that compilation is type-directed and enough type information is available to insert conversions as necessary, there is no reason that they are required to be coercions in implementation.</p></li>
<li><p>Restriction types, of nominal types constrained to fewer possible cases, would be incredibly useful.</p></li>
<li><p><span data-t="" data-widget="">tl;dr</span> is that this should help with the <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf">“trees that grow”</a> problem of multiple related ASTs.</p></li>
<li><p>Iʼm wavering on including records: I think they donʼt mesh well with the system of inference. But there is an alternative, which is to include sort of “grab bags”: where you donʼt pretend to know the totality of the record (in particular, there is no sensible way to implement <code class="haskell">Eq</code> for records), but you have some partial knowledge of what you want to be in there.</p>
<p>In concrete terms, this means that inclusion in the grab bag is the only sensible constraint you get to ask for; you donʼt really get to “delete fields” or “merge” or such.</p></li>
<li><p>Avoiding row types … idk. Row types are great but I think there are enough alternatives in this type theory that they would not be so important. In particular, having union types (and maybe restriction types) means that you can talk about parts of the AST.</p>
<p>If I did have row types, I would want to make sure they are not limited to existing constructs of records and variants (product and sum types), there are so many other symmetric tensors to think about! <span data-t="" data-widget="">E.g.</span> configuration options tend to come as a record of maybes, but sometimes you need a bunch of things tensored together with <code class="haskell">These</code>, so you know that at least one is specified.</p></li>
</ul></li>
<li>Function calls cannot be nested, functions are only applied to literals/variables.
<ul>
<li>This is for two reasons: it makes the syntax lighter, and it means that the user was very specific about the order of execution.</li>
<li>One concrete benefit is that you need much fewer delimiters in the syntax, since each pattern ends at a well-known point.</li>
</ul></li>
</ul>
<h4 id="patterns">Patterns</h4>
<p><a href="https://cohost.org/monoidmusician/post/3252802-first-class-patterns" class="uri">https://cohost.org/monoidmusician/post/3252802-first-class-patterns</a></p>
<ul>
<li><p>We need a way to reflect patterns into values, filling in any variables with default values. This is most useful to implement unification: to unify a term with a pattern, you first replace the variables with unification variables, call the unification function (which has no idea what a pattern is), and then match the pattern against the result.</p>
<p>So if you want to unify <code class="js">T</code> against <code class="js">["tuple" x y]</code>, you first generate two unification variables <code>U1</code> and <code>U2</code>, then run <code class="js">unify T ["tuple" U1 U2] =&gt; R</code> (if <code class="js">T</code> is a unification variable, this will write into state that it is now known to be a tuple!), and finally do regular pattern matching of <code class="js">R</code> against <code class="js">["tuple" x y]</code>, binding <code class="js">x</code> and <code class="js">y</code> to the respective subnodes of <code class="js">R</code>.</p>
<ul>
<li><p>Iʼm not quite sure if this deserves to be called first-class patterns. To be honest, Iʼm not sure what first-class patterns would even mean! But it is very simple, practical, and it does all the things I personally would want out of first-class patterns.</p></li>
<li><p>It is a technique I have also been using in more and more places: in my <a href="https://github.com/MonoidMusician/blog/blob/main/PureScript/src/Parser/Languages/Talk.purs">LR parser combinator framework</a>, and in writing a compiler.</p>
<p>The basic idea is that a <code class="haskell">Pattern</code> or <code class="haskell">Matcher</code> (or whatever you want to call it) is a combination of the shape that it expects (minus actual data), and then what to do once it receives that shape (with the data filled in, producing some arbitrary result). You can combine these applicatively and with other tools (if you can combine the shapes and pick them back apart); it is very useful, even without any language support whatsoever, just DSLs and fancy types. These are basically codecs in a single direction (not bidirectional).</p></li>
</ul></li>
<li><p>Non-linear pattern matching.</p></li>
<li><p>Static evaluation of functions, so they can be considered as macros producing patterns.</p>
<p>This means that they have to reduce to a pattern, without running any effectful functions, and cannot have stuck case matching, and so on.</p></li>
<li><p>Pattern aliases?</p></li>
</ul>
<h3 id="use-cases-to-achieve">Use-cases to achieve</h3>
<ul>
<li><p>Writing down programs in the style of judgment rules for different flavours of typechecking (unification and bidirectional) and normalization (rewrite systems and normalization by evaluation).</p></li>
<li><p>Optimizing these algorithms by applying transformations from the source code to add ~things~. And using the same techniques to add additional metadata, for nice features.</p>
<div class="Bonus" data-box-name="Mini Rant">
<p>This is my problem with a ton of code that gets written, and I am certainly guilty of it too: we get the fundamental logic written, but never get over the hump to the point of providing nice features, in part because the languages/libraries we use do not facilitate the nice features – heck, they even made writing the logic so arduous in the first place that we run out of steam –&nbsp;and partly because, as I have mentioned repeatedly, it would mean touching half of the codebase again just to add fields that none of the existing logic cares about.</p>
<p>Urgh. Letʼs find ways to do better, and create the tools that reflect our values.</p>
<p>… Anyways, back to those use-cases:</p>
</div></li>
<li><p>Trace evaluation of these programs and generate interactive visualizations based on this.</p></li>
<li><p>Generate types for precise errors based on analyzing failure modes of the written logic.</p></li>
<li><p>Working with multiple related AST types. Working with types related in other ways, such as non-empty constraints. (These get pretty onerous to work with, when you have to write completely separate types for non empty things, and make sure you preserve non-emptiness in the right places. Trust me, Iʼve tried!)</p></li>
<li><p>Simplify writing advanced programming techniques:</p>
<ul>
<li>Continuation Passing Style (CPS). This is (apparently) really great for efficiency for a bunch of reasons (<span data-t="" data-widget="">e.g.</span> quicker backtracking), but can be mind-bending to write directly.</li>
<li>Deriving zippers/one-hole contexts for datatypes, possibly even <a href="http://strictlypositive.org/CJ.pdf">Clowns &amp; Jokers</a> style for incremental stack-safe computations. (One-hole contexts are possible to derive generically with typeclass machinery. But the conversions get super annoying…)</li>
<li>Functional Reactive Programming (FRP). Existing FRP frameworks are … alright. But none really capture the right logic/linguistics to make it easy.</li>
<li>Incremental computation. I mean … just imagine an incremental compiler, where trivial refactors donʼt cost any time, changing constants in the source code changes them directly in the compiled artefacts, and other tasks scale proportionally to the amount of things they actually affect.</li>
<li>“Free” constructions (I mean, minus laws, since we donʼt have quotients). These are just so difficult to make, with a lot of boilerplate.</li>
<li>Codecs. Parsing. I love parsers so it would be great to integrate them. Maybe even into the type theory! (It is apparently possible to algorithmically decided whether one regular expression is contained in another uwu :3.)</li>
<li>STM. Eventual consistency. Other lattice-y stuff.</li>
<li>Parallel evaluation, à la <code class="haskell">unamb</code> or so.</li>
</ul></li>
</ul>
<h2 id="non-goals">Non-goals</h2>
<ul>
<li>Not intended to support dependent types or any theorem proving features.</li>
<li>This is not intended to be a logic language, although it could be compiled to a logic language. Thus we will not expect to be doing proof search during execution. (Arguably could be doing proof search during compilation.)</li>
<li>Similarly: not interested in baking in unification. That can (and should) be provided by users; the goal is to make the syntax lightweight enough to facilitate it.</li>
<li>Probably not going to have Rank-N types for a while, if ever. I mean, I like Rank-N types, especially for APIs, but most things end up being better expressed by inductive data types, and this way I have a type inference algorithm that is actually tractable …</li>
</ul>
<h2 id="more-details">More Details</h2>
<p>(A separate section so I donʼt bury <a href="#non-goals">Non-goals</a>)</p>
<h3 id="abstractions-i-want">Abstractions I want</h3>
<p>Worship the shape of data and the structure of code …</p>
<ul>
<li>Any metatheory that makes dealing with variable binding easier is worth a lot!
<ul>
<li>What I did in Dhall-PureScript: <a href="https://github.com/MonoidMusician/dhall-purescript/blob/469c3e10d51a8afb90f2e231cf3e6101f50814eb/src/Dhall/Variables.purs#L119-L201">Dhall/Variables.purs</a> This just does basic bookkeeping of when variables are bound, based on the functors I used in the recursion schemes, but I think it proved to do most of what I needed.</li>
<li><div class="Bonus" data-box-name="Aside">
<p>The other, silly solution, is to commit to only having one binder: lambda, and phrasing pi in terms of lambda. I convinced myself it works out on paper but I got a little stuck trying to prove it to Agda. Heh heh heh …</p>
</div></li>
</ul></li>
<li>Container functors, the building blocks of an AST.
<ul>
<li><code class="haskell">traverseWithIndex :: (i -&gt; a -&gt; m b) -&gt; (f a -&gt; m (f b))</code></li>
<li><code class="haskell">mergeWith :: (i -&gt; a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; Maybe (f c)</code>
<ul>
<li>I believe that we need a lot more binary operations like this, for matching on two shapes at once! It is not something that is covered by recursion schemes for example. <code class="haskell">Data.Map</code> has a terrible interface (<code class="haskell">unionWith</code> is so bleh).</li>
</ul></li>
<li><a href="https://github.com/MonoidMusician/dhall-purescript/blob/main/src/Dhall/Core/Zippers.purs">Zippers/one-hole contexts</a> (optional – I never actually used them in Dhall-PureScript, but they could be useful for some things):
<ul>
<li><code class="haskell">upZF :: ZF f' x -&gt; f x</code></li>
<li><code class="haskell">downZF :: f x -&gt; f (ZF f' x)</code></li>
<li><code class="haskell">ixF :: f' x -&gt; i</code></li>
</ul></li>
</ul></li>
<li>Array stuff
<ul>
<li>normal <code>zipWith</code></li>
<li>“long” <code>zipWith</code></li>
<li><code>takeWhileJustWithRest :: (a -&gt; Maybe b) -&gt; Array a -&gt; (Array b, Array a)</code>
<ul>
<li>some kind of condensor pattern</li>
</ul></li>
<li>something better than <code>mapAccumL</code>/<code>mapAccumR</code> lol
<ul>
<li>every time I want to reach for a stateful traversal, I find it so annoying!</li>
</ul></li>
<li>maybe some actual parser type thing</li>
</ul></li>
</ul>
<h3 id="examples">Examples</h3>
<p><em>~Disclaimer that I use typechecking and type inference interchangeably.~</em></p>
<h4 id="typechecking-lists">Typechecking lists</h4>
<p>I think it is <em>very <strong>very</strong></em> useful to move from thinking of unification as a binary operation to it as a N-ary operation. As one example, consider (homogeneous) list literals.</p>
<p>The way a lot of typecheckers work when inferring list literals is that it assumes the first item has the right type, and then it typechecks the remaining items against it. But what if it is the first item that has the wrong type, and all 12 other items are actually right? I believe it is best to typecheck each term in isolation, then see if the results can be unified all at once – and then unify the unification states, since unification variables may have been unified in inconsistent ways. (This requires unification state to be <code class="haskell">WriterT</code> not <code class="haskell">StateT</code>. Yeah.)</p>
<pre class="js" data-lang="tmTTmt"><code>typecheck/ ["ListLiteral" items] =&gt; ["App" "ListType" itemType]
  map typecheck items =&gt; itemTypes
  ensureConsistency itemTypes =&gt; itemType</code></pre>
<h4 id="typechecking-non-dependent-pi-types">Typechecking non-dependent pi types</h4>
<p>I would like to be able to short-circuit typechecking non-dependent functions, and return a result even if the argument is ill-typed or does not have the correct type.</p>
<p>(Why? Because having a more global view of errors is often useful, since the hyperlocal errors we are used to can obscure the real problem.)</p>
<p>This would show up as a soft error that allows further typechecking to proceed. Soft errors can be turned into critical errors when we need to be able to trust the result of typechecking, <span data-t="" data-widget="">e.g.</span> to know that normalization is going to complete.</p>
<pre class="js" data-lang="tmTTmt"><code>typecheck/ ["App" fn arg] =&gt; resultType:
  // Unifies the result with a "Pi" type
  typecheck fn =&gt; ["Pi" binder domain codomain]
  // See if `codomain` does not in fact depend on `binder`
  tryApplyConstant binder codomain
  ? ["constant" resultType]:
    // `resultType` got assigned, so this case is not necessary to produce
    // *some* result that can inform further type errors, though this node does
    // not truly typecheck if it fails:
    typecheck arg =&gt; domain
    // `domain` is a non-linear pattern match, unifying `argType` and `domain`
    // (any further references to `domain` would refer to the unified node)
  ? ["non-constant"]:
    // Typecheck the argument in strict mode to ensure that type errors result
    // in an immediate failure even if an approximate result can be computed:
    strictly ([] =&gt; typecheck arg) =&gt; domain
    // (Unification with `domain` is always strict, it never adds soft errors.)

    // Now that it is safe to compute with `arg`, we apply it to compute the
    // result type:
    substitute binder arg codomain =&gt; resultType
  !

// Probably should simplify this somehow ...</code></pre>
<div class="Note" data-box-name="Aside">
<p>Is this good notation for lambdas as arguments to functions? I donʼt know.</p>
<pre class="js" data-lang="tmTTmt"><code>  strictly | [] =&gt; r:
    typecheck arg =&gt; r
  ! =&gt; domain</code></pre>
<p>Macros for currying?</p>
<pre class="js" data-lang="tmTTmt"><code>asdf (!2 append !1 !0 !)</code></pre>
<p>I want to avoid some problems:</p>
<ul>
<li>Indentation. Figuring out how to indent lambdas as arguments to functions is so annoying.</li>
<li>Related: figuring out where the lambdas end is also annoying. I do like dangling lambdas actually.</li>
</ul>
<pre class="js" data-lang="tmTTmt"><code>["if" ($matches-tag arg1) (: MyExprType) "then" "true" "else" ($failed-match)]</code></pre>
</div>
<pre class="haskell"><code>-- The behavior of `select` for the typechecker monad/thingy is that if the
-- first computation returns a `Left`, it will accumulate errors from the second
-- computation, instead of failing and blocking computation like `&gt;&gt;=`.
--
-- In particular, it does accumulate errors from `strictly`, in that case.
select :: f (Either b a) -&gt; f (a -&gt; b) -&gt; f b
strictly :: f a -&gt; f a
tryApplyConstant :: Binder -&gt; Type -&gt; Maybe Type

typecheck :: Type -&gt; f Type
typecheck (App fn arg) =
  select
    ( typecheck fn &gt;&gt;= \fnType -&gt;
        unifyPi fnType &gt;&gt;= \binder domain codomain -&gt;
          case tryApplyConstant binder codomain of
            Just r -&gt; Left r
            Nothing -&gt; Right Unit
    )
    ( strictly $ typecheck arg &gt;&gt;= \argType -&gt;
        unify argType domain &lt;#&gt; \_unified -&gt;
          apply binder arg codomain
    )</code></pre>]]></description>
</item>
<item>
<title>The Best Errors for Solving Dependency Versions</title>
<pubDate>Sat, 21 Jan 2023 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/version_solver.html</guid>
<description><![CDATA[<div class="Bonus" data-box-name="Backstory">
<blockquote>
<p>Just copy the <a href="https://github.com/elm/compiler/blob/0.19.1/builder/src/Deps/Solver.hs">Elm version solver</a> from Haskell to PureScript, itʼll be easy.</p>
</blockquote>
<p>Uh huh. Totally.</p>
<blockquote>
<p>Oh we need good errors too.</p>
</blockquote>
<p>Yup. Thought so.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
</div>
<p>And so the feature creep started … but the journey was <em>so</em> worth it.</p>
<p>How did I get here and what did I come up with?</p>
<div class="Key_Idea" data-box-name="tl;dr">
<p>A <a href="https://github.com/purescript/registry-dev/blob/master/lib/src/Solver.purs">novel algorithm</a> for resolving dependency bounds to solved versions:</p>
<ul>
<li>Incorporates <a href="#intuitive-foundations-quasi-transitive-dependencies">transitive dependency bounds</a> for a breadth-first search:
<ol type="1">
<li>What dependencies are required no matter which package version in the range we commit to?</li>
<li>Whatʼs the loosest bound for each dependency then?</li>
</ol></li>
<li>By taking this intuitive approach, we gain two things:
<ol type="1">
<li><a href="#errors">Better errors</a>, matching what users would expect.</li>
<li>Efficiency too, if you could believe it.</li>
</ol></li>
<li>Implemented using semilattices (<a href="#monoids-monoids-everywhere">monoids</a>).</li>
</ul>
</div>
<p>(I know youʼre probably not going to read this whole long article and <a href="#errors">Errors</a> is the very last section, but please feel free to skip ahead to that one since that was the whole point of this exercise!)</p>
<h2 id="background">Background</h2>
<h3 id="the-purescript-registry">The PureScript registry</h3>
<p>The PureScript community has been designing a new registry to hold PureScript packages for some time now. PureScript projects initially used <a href="https://bower.io/">Bower</a> (a defunct npm competitor for Node.js packages), and I embarrassingly hung on to Bower until just last year. Most of the community, however, has been using <a href="https://github.com/purescript/spago">Spago</a>, a PureScript build tool supporting package sets (fixed versions of packages that are known to be compatible). Long story, but some core members have been designing a <a href="https://github.com/purescript/registry">new registry</a> to house current and historical PureScript packages. Weʼre very close to releasing it!<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>In the interest of maintaining a healthy ecosystem, we want the new registry to support not just package sets but also traditional version solving. And thatʼs where I came in. Something about my mathy skills being a perfect fit for getting <a href="https://xkcd.com/356/">nerd-sniped</a> by a version solving algorithm. Oh and would you help fix the <a href="https://github.com/purescript/registry-dev/pull/580">versioning issues for legacy packages</a> while youʼre at it? Sure, sure I will.</p>
<h3 id="version-solving">Version solving</h3>
<p>The challenge of version solving in a package ecosystem is coming up with particular version of packages that satisfy not only the dependencies of the current project, but their own dependencies too. You also want to ensure they are up-to-date by taking the latest possible versions – but sometimes those are not compatible with other declared dependencies. The problem is expected to be difficult and slow to solve in general, but it is possible to optimize for what package dependencies look like in practice, and that is what I have done.</p>
<h4 id="details-of-versions-and-version-ranges">Details of versions and version ranges</h4>
<p>Quick notes on conventions/terminology before we get too far in:</p>
<p>The actual details of how versions are tagged doesnʼt matter, just that they are totally ordered.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> For example, it could just be flat integers for all we care. But usually we take them to be lexicographically-ordered lists of integers, like <code class="boo">5.0.3</code> which is less than <code class="boo">5.1.0</code>.</p>
<p>How we form <em>ranges</em> over versions is pretty important, though, and early on the registry decided to only allow half-open intervals. That is, ranges have the form <code class="boo">&gt;=A.B.C &lt;X.Y.Z</code>, which I will use throughout this article. Again, it isnʼt very sensitive to details here (who cares that it is half-open?), but this does seem to be the right level of generality. Supporting more complex queries is asking for trouble.</p>
<p>Finally, from a version-solving point of view, a registry contains information of what versions of packages there are, and for each package version a record of what dependencies it requires and the appropriate version ranges for those packages. That is, it can be represented with the following PureScript datatype:</p>
<pre class="purescript"><code>-- A list of required dependencies
-- with their version ranges
type Manifest = Map PackageName Range

-- A list of all extant package versions
type RegistryIndex =
  Map PackageName
    (Map Version Manifest)</code></pre>
<h4 id="the-problem-statement">The problem statement</h4>
<p>Solving means taking a manifest and finding versions for each package in it, preferring later versions<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<pre class="purescript"><code>solve
  :: RegistryIndex
  -&gt; Manifest
  -&gt; Either SolverErrors
      (Map PackageName Version)</code></pre>
<p>Along with some correctness constraints to ensure it is the solution we want.</p>
<details class="Details" data-box-name="CSS">
<summary>
Correctness constraints
</summary>
<pre class="purescript"><code>let r :: RegistryIndex
let m :: Manifest
let otherSol :: Map PackageName Version

-- We need the solution to solve the manifest and dependency's requirements
isASolutionFor r m (fromRight (solve r m)) &amp;&amp;
-- There are no strictly better versions to be found
( isASolutionFor r m otherSol
  `implies` isn'tWorseSolutionThan otherSol (fromRight (solve r m))
)
where
satisfies
  :: Map PackageName Version
  -&gt; Map PackageName Range
  -&gt; Boolean
satisfies sol m =
  allWithIndex
    ( \package range -&gt;
        case Map.lookup package sol of
          Nothing -&gt; false
          Just version -&gt; range `includes` version
    )
    m

isASolutionFor
  :: RegistryIndex
  -&gt; Manifest
  -&gt; Map PackageName Version
  -&gt; Boolean
isASolutionFor r m sol = and
  -- All packages received a version
  [ Map.keys m `isSubsetEqOf` Map.keys sol
  -- All solved versions fit into the range
  -- as required in the manifest
  , sol `satisfies` m
  -- All packages have their dependencies satisfied
  , allWithIndex
      ( \package version -&gt;
          case Map.lookup package r &gt;&gt;= Map.lookup version of
            Nothing -&gt; false
            Just deps -&gt;
              sol `satisfies` deps
    )
    sol
  ]

isn'tWorseSolutionThan :: Map PackageName Version -&gt; Map PackageName Version -&gt; Boolean
isn'tWorseSolutionThan other optimal =
  Maps.keys optimal `isSubsetEqOf` Map.keys other
  &amp;&amp; not allWithIndex
    ( \package version -&gt;
        case Map.lookup package other of
          Nothing -&gt; true

    )
    optimal
  -- FIXME</code></pre>
</details>
<h4 id="dependencies-are-tricky">Dependencies are tricky</h4>
<p>In particular, note that dependencies are associated with a particular <em>version</em>. A package <em>range</em> doesnʼt need to have well-defined dependencies at all!</p>
<p>This is something that we forget about when using packages in our day-to-day lives, but an algorithm needs to handle all cases we could throw at it.</p>
<h2 id="depth-first-backtracking-algorithm">Depth-first backtracking algorithm</h2>
<p>As I alluded to in the intro, I started off by copying <a href="https://github.com/elm/compiler/blob/0.19.1/builder/src/Deps/Solver.hs">Elmʼs version solving algorithm</a>. Itʼs a very simple depth-first backtracking algorithm:</p>
<ol type="1">
<li>Try the latest compatible version of the package in front of you, based on the global requirements</li>
<li>Add its dependency ranges to the global requirements<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li>
<li>Recursively see if the new global requirements can be solved</li>
<li>Backtrack to the next latest version at each failure.</li>
</ol>
<p>Itʼs easy to see why this is worst-case exponential, and not going to hit fast cases particularly often. In fact, we expect the problem to remain worst-case exponential, but spoiler: we can do much better in most reasonable cases!</p>
<p>Besides performance, the main obstacle I wrestled with was that it had no errors. It turns out these are related concerns: because the algorithm is so naïve, it isnʼt making use of available information to make smart choices, and this would reflect in the errors it could produce.</p>
<h3 id="errors-for-a-backtracking-algorithm">Errors for a backtracking algorithm</h3>
<p>I discovered that this problem of solving package versions corresponds well to what I have been thinking about in terms of compiler/typechecker errors for the past couple years. So thereʼs some good lore here on what I believe errors should look like, but thatʼs for another post.</p>
<p>Basically, good errors should be a faithful reflection of the internal logic of the solver. This is the main hint that performance and errors are linked: if the solver is trying too many bad options, itʼs going to generate a ton of errors for all of those choices. These errors are bad because they mainly reflect bad choices of the solver, not necessarily problems with the underlying data (the manifests). Itʼs only once <em>every option</em> has failed that you know that the underlying manifests were not compatible. Our goal later, then, will be to reduce the number of choices to make and commit to errors as soon as possible.</p>
<p>The second problem with the errors is that the naïve backtracking does a <em>lot</em> of duplicate work, in between choices of packages. In the worst case scenario, two package versions have the same manifests, so trying them separately will duplicate most of the work!<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>It is possible to deduplicate errors after the fact, but those heuristics seem complex in general, and there are two problems still:</p>
<ol type="1">
<li>Youʼve already lost the performance associated with the duplicate work, and are spending more time trying to fix it</li>
<li>You might as well write the algorithm to incorporate the deduplication in the first place!!</li>
</ol>
<p>There are some existing approaches to increase sharing/reduce duplicate work, in the context of general constraint solving and more particularly version solving with these type of bounds. I briefly glanced at them, but they donʼt seem to address the heart of the issue like my algorithm does.</p>
<h4 id="algebraic-errors">Algebraic errors</h4>
<p>In a solver algorithm, we write programs in terms of some error monad. The backtracking algorithm essentially corresponds to a complicated Boolean expression, a tree of various constraints joined with conjunction and disjunction. Thinking of it as <code>Applicative</code>purescript+<code>Alternative</code>purescript, we see that <code>&lt;*&gt;</code>purescript corresponds to conjunction <code>&amp;&amp;</code>purescript and <code>&lt;|&gt;</code>purescript corresponds to disjunction <code>||</code>purescript.</p>
<pre class="boo"><code>console &gt;=5.0.0 &lt;6.0.0

(console == 5.0.0 &amp;&amp; prelude &gt;=5.0.0 &lt;6.0.0)
|| (console == 5.0.1 &amp;&amp; prelude &gt;=5.0.1 &lt;6.0.0)</code></pre>
<p>An error, then, is some kind of proof that the Boolean always evaluates to false. SAT solvers have done a great job of doing this in the general case. And you can think a bit about what this means.</p>
<p>In addition to the literal Boolean clauses, we want the errors to record some <a href="#provenance">additional metadata</a> about where they came from: particular manifests and the current dependency from the manifest we are trying to solve.</p>
<h3 id="drawbacks-of-depth-first">Drawbacks of depth-first</h3>
<p>However, we can only do so much: we remain limited to the logic of the algorithm. With a depth-first algorithm in particular, the errors donʼt convey the global picture that the user is looking for.</p>
<p>I mean, you <em>can</em> report these kinds of Boolean clause errors, but they are so confusing that you might as well just throw up your hands and say “I tried something and it didnʼt work.” Thatʼs all the user would get from the errors anyways, since thatʼs really all the algorithm did: It started with an essentially random package, committed to a version of it immediately, tried other things as a consequence, and eventually reported that nothing worked.</p>
<p>So, since my goal was better errors, <a href="https://github.com/purescript/registry-dev/pull/496#issuecomment-1225145757">my next idea</a> was to try to patch it to <em>run</em> the depth-first backtracking algorithm, but create a post-mortem analysis to <em>report</em> more sensible errors. For example, from the Boolean algebra perspective, you can do basic tricks to factor out common sub-expressions, which you can combine with what you know about comparing versions to ranges.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>I couldnʼt bring myself to write that. So I just wrote a novel breadth-first algorithm.</p>
<p>I spent a significant chunk of time writing it. I spent several weekends debugging its performance.</p>
<p>And the results are amazing. <em>/me pats self on back</em></p>
<h2 id="my-breadth-first-algorithm">My breadth-first algorithm</h2>
<p>Hereʼs where I admit my biggest weakness: prior art. I have a great difficulty reading existing research on some topics. Especially when the problem is so obviously begging for a nice solution like this! Itʼs easier to work out the details for myself to be honest. And then blog about it so that people who are <em>not</em> like me learn what I have done. (Apologies to those who are like me who will never read this and perhaps reinvent it. Godspeed.)</p>
<p>I spent a couple months designing a whole new algorithm from scratch. The basic idea is that we gather as much information we can before committing to any versions. This is done through the use of what I have coined as <a href="#intuitive-foundations-quasi-transitive-dependencies">quasi-transitive dependencies</a>.</p>
<div class="Details" data-box-name="Overview">
<p>The main steps are:</p>
<ol type="1">
<li>Load the slice of the registry index that we care about: package versions that are transitively reachable from the package ranges mentioned in the current manifest.</li>
<li>Gather information about <em>quasi-transitive</em> dependencies for manifests in the registry as well as the current manifest we are solving, looping until there is no more obvious information to discover.</li>
<li>Check if the requirements have hit an error in the requirements already.</li>
<li>If not, check if we have solved it: do all the latest versions of requirements work as a solution?</li>
<li>Only as a last resort do we succumb to picking a package and recursively solving each of its versions, starting from the latest.</li>
</ol>
<p>Note that the quasi-transitive dependencies check essentially commits to unique versions immediately, so by the time we reach step 5 we know that there are at least two possible versions of some dependency and are forced to commit to one to make progress. It turns out that in practice, we already hit errors before we have to do that, so weʼve avoided the worst of the exponential blowup!</p>
<p>You can <a href="https://github.com/purescript/registry-dev/blob/30a88ac7bd48a73bb2bcf9240b20b09a713ee0b9/lib/src/Solver.purs#L249-L289">read these steps in the code directly</a>.</p>
</div>
<h3 id="intuitive-foundations-quasi-transitive-dependencies">Intuitive foundations: quasi-transitive dependencies</h3>
<p>Recall what I said in <a href="#dependencies-are-tricky">Dependencies are tricky</a>: “A package <em>range</em> doesnʼt need to have well-defined dependencies at all!” Oh – but they often <em>do</em> in practice.</p>
<p>If we can get extra knowledge about requirements before committing to any particular versions, we have a chance at implementing some sort of breadth-first search.</p>
<p>How much extra knowledge we obtain depends on how packages treat their dependency bounds in the registry. In the case of how PureScript packages tend to bound dependencies, it turns out to be a lot of knowledge. This is because most stable PureScript libraries update with each breaking compiler release and depend on the corresponding major version range of <code>prelude</code> and various other core packages. Since a lot of versions move in lockstep, it is pretty safe to assign loose dependencies to a package range and even reach for further transitive dependencies.</p>
<p>In general, when bumping minor and patch versions, packages tend to keep the same list of dependencies at similar version ranges. Things are a bit more chaotic between major versions, but it is rarer that packages allowed different major versions in their manifests in the first place, and so there is some semblance of continuity.</p>
<p>Now we need to use this to our advantage:</p>
<div class="Key_Idea">
<p>The idea is that we come up with <em>quasi-transitive dependencies</em> for a package range – a lower bound of the absolutely necessary requirements that follow from a package <em>range</em> being required.</p>
<p>There are two rules here:</p>
<ol type="1">
<li>If a package is not required by all versions in the range, we cannot say it is required overall.</li>
<li>When it <em>is</em> depended on by all versions in a range, we take the loosest bounds we see: the lowest lower bound and the greatest upper bound.</li>
</ol>
</div>
<p>It turns out that we can formulate this rule as a <a href="https://pursuit.purescript.org/packages/purescript-functors/5.0.0/docs/Data.Functor.App#v:semigroupApp">semigroup instance</a> that applies the logic for us to a collection of manifests:</p>
<pre class="purescript"><code>instance Semigroup (App (Map PackageName) Loose) where
  append (App m1) (App m2) = append &lt;$&gt; m1 &lt;*&gt; m2

foldMap1
  :: NonEmptyArray (App (Map PackageName) Loose)
  -&gt; App (Map PackageName) Loose

instance Coercible Manifest (App (Map PackageName) Loose)</code></pre>
<p>Note that this is in fact not a monoid: <a href="https://pursuit.purescript.org/packages/purescript-ordered-collections/docs/Data.Map#t:Map"><code>Map</code>purescript</a> only has an <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Apply#t:Apply"><code>Apply</code>purescript</a> instance (which gives the <code>&lt;*&gt;</code>purescript operator to merge common keys), not <a href="https://pursuit.purescript.org/packages/purescript-prelude/docs/Control.Applicative#t:Applicative"><code>Applicative</code>purescript</a> (which would give <code>pure</code>purescript but does not make sense for <code>Map</code>purescript since it would have to contain <em>all</em> possible keys!).</p>
<p>As a further optimization, while we are checking package versions, we may discard those that do not solve due to an obvious conflict. This may seem strange: In the PureScript registry, each package will solve individually, we check that on upload. But given the additional constraints of a particular manifest we are solving, we may end up with conflicts against various package versions that are incompatible with the global requirements, especially as we continue to aggregate quasi-transitive dependencies.</p>
<pre class="purescript"><code>-- | We record what dependency ranges are required no matter which version
-- | of the package we pick from the registry. That is, we report the loosest
-- | bounds when all packages report a bound for it. By filling in transitive
-- | dependencies on the registry itself, then, these bounds become more
-- | accurate.
-- |
-- | Also note that removing the redundant requirements via `addFrom` is safe
-- | with the assumptions here: if one local requirement is equal to or looser
-- | than a global requirement, then this result here would also be equal to or
-- | looser than the global requirement.
commonDependencies
  :: TransitivizedRegistry
  -&gt; PackageName
  -&gt; Intersection
  -&gt; SemigroupMap PackageName Intersection
commonDependencies registry package range =
  let
    inRange =
      getPackageRange registry package range
    solvableInRange =
      Array.mapMaybe (traverse toLoose) (Array.fromFoldable inRange)
  in
    case NEA.fromArray solvableInRange of
      Nothing -&gt; mempty
      Just versionDependencies -&gt;
        case NEA.foldMap1 App (un SemigroupMap &lt;$&gt; versionDependencies) of
          App reqs -&gt;
            SemigroupMap $ reqs &lt;#&gt; asDependencyOf range &lt;&lt;&lt; fromLoose</code></pre>
<h4 id="composing-relations">Composing relations</h4>
<p>This quasi-transitive dependency business looks a bit like a familiar formula: the composition of two relations in logic.</p>
<div class="Details">
<p>Phrased in terms of set theory, <a href="https://en.wikipedia.org/wiki/Composition_of_relations#Definition">Wikipedia says</a>:</p>
<blockquote>
<p>If <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \subseteq X \times Y</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊂</mo><mi>Y</mi><mo>×</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">S \subset Y \times Z</annotation></semantics></math></span> are two binary relations, then their composition <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo separator="true">;</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R;S</annotation></semantics></math></span> . . . is defined by the rule that says <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi><mo separator="true">;</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(x,z)\in R;S</annotation></semantics></math></span> if and only if there is an element <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">y\in Y</annotation></semantics></math></span> such that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext> </mtext><mi>R</mi><mtext> </mtext><mi>y</mi><mtext> </mtext><mi>S</mi><mtext> </mtext><mi>z</mi></mrow><annotation encoding="application/x-tex">x\,R\,y\,S\,z</annotation></semantics></math></span> (that is, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">(x,y)\in R</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(y,z)\in S</annotation></semantics></math></span>).</p>
</blockquote>
</div>
<p>The key part here is that we take our input and our output and we ask: is there something <em>in the middle</em> that serves to connect the input to the output? (Thinking of relations as boxes that connect certain inputs to certain outputs.)</p>
<p>However, we arenʼt dealing with general relations here, weʼre only dealing with half-open intervals. Weʼre asking: for a version <em>range</em>, what <em>range</em> is constructed by taking the ranges of <em>each version</em> in the middle?</p>
<p>To be a bit more direct with this analogy, a relation <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⊆</mo><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">R \subseteq X \times Y</annotation></semantics></math></span> can equivalently be written as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>×</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \in \mathcal{P}(X \times Y)</annotation></semantics></math></span>. (<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(Z)</annotation></semantics></math></span> here is the powerset monad <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>Z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Z</mi><mo>→</mo><mtext>Prop</mtext></mrow><annotation encoding="application/x-tex">\mathcal{P}(Z) = Z \to \textrm{Prop}</annotation></semantics></math></span>, which consists of all subsets of the given set <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span>.) And by currying, this can be viewed as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∈</mo><mi>X</mi><mo>→</mo><mi mathvariant="script">P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R \in X \to \mathcal{P}(Y)</annotation></semantics></math></span>. This construction <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>M</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to M(Y)</annotation></semantics></math></span> for a monad <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span> is called the Kleisli category. So now the question is: do intervals also form a monad, by taking loose bounds?</p>
<p>The easy answer is that we can certainly think of it as an approximation on top of the underlying set-relation model. That is, we know how to make intervallic dependencies a relation, so we compose them as relations and then take the smallest interval that contains every interval we came across.</p>
<p>Perhaps there is a way to categorify it directly, I donʼt know. We can come up with an identity, but Iʼm not so sure that associativity would hold.</p>
<div class="Details" data-box-name="Clarification">
<p>To see how it fits. Unit -&gt; Package X range -&gt; Package Y range (X depends on Y)</p>
<p>Thatʼs only dealing with versions of a single package. Bundle it together.</p>
</div>
<h3 id="implementing-it">Implementing it</h3>
<p>The core backtracking algorithm actually still exists in the spine of the solver, but its role is greatly reduced. In fact, this has a funny implication for testing the algorithm: <em>the correctness is visible not in finding the right solutions but in the algorithmʼs efficiency and errors.</em></p>
<p>The literal results of the solver were accurate all along. But when I finally got it working <em>fast</em>, I knew all my logic was in place for all the intermediate steps. In particular, this means that we preempted most of the (exponential) backtracking.</p>
<h4 id="monoids-monoids-everywhere">Monoids, monoids everywhere</h4>
<p>Again, a topic for another blog post, but I love monoids, especially semilattices, because they capture information gathering in ways that lend themselves to reliable implementation.</p>
<p>In particular, because of their idempotence, semilattices are great because you just need to make sure you cover all cases. Thereʼs no such thing as double-counting in a semilattice computation! When youʼre dealing with a well-behaved logical scenario, if have written your logic correctly (<span data-t="" data-widget="">i.e.</span> each derivation is valid) and you cover all the cases (you eventually produce every fact you are allowed to derive), thereʼs no chance that you accidentally make things break.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>We already saw our first semilattice <code>Semigroup (App (Map PackageName) Loose)</code>purescript above. However, I left out the definition of <code>Loose</code>purescript and its <code>Semigroup</code>purescript instance.</p>
<p>The <em>data</em> contained in <code>Loose</code>purescript is just a lower bound and an upper bound, and we want the lower bound to be less than the upper bound for it to be valid. We also pack in <em>metadata</em> that describes where each bound came from, the <code>SolverPosition</code>purescript datatype which we will discuss below in <a href="#provenance">Provenance</a>.</p>
<p>To achieve this, we first define a type that describes a bound with metadata packed in. Then we add to this operations that take the maximum and minimum of the bounds, and <em>aggregate</em> the metadata if they were the same bound. Thatʼs right, <strong>the metadata itself forms a semilattice!</strong><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<pre class="purescript"><code>data Sourced = Sourced Version SolverPosition

newtype MinSourced = MinSourced Sourced

instance Semigroup MinSourced where
  append a@(MinSourced (Sourced av as)) b@(MinSourced (Sourced bv bs)) =
    case compare av bv of
      LT -&gt; a
      GT -&gt; b
      EQ -&gt; MinSourced (Sourced av (as &lt;&gt; bs))

newtype MaxSourced = MaxSourced Sourced

instance Semigroup MaxSourced where
  append a@(MaxSourced (Sourced av as)) b@(MaxSourced (Sourced bv bs)) =
    case compare av bv of
      GT -&gt; a
      LT -&gt; b
      EQ -&gt; MaxSourced (Sourced av (as &lt;&gt; bs))</code></pre>
<p>Now we get both <code>Loose</code>purescript and <code>Intersection</code>purescript for free by the right arrangement of these types. Heck, we even get their coercion for free:</p>
<pre class="purescript"><code>newtype Loose = Loose
  { lower :: MinSourced
  , upper :: MaxSourced
  }
derive newtype instance Semigroup Loose

newtype Intersection = Intersection
  { lower :: MaxSourced
  , upper :: MinSourced
  }

derive newtype instance Semigroup Intersection

-- API for `Intersection`
upperBound :: Intersection -&gt; Version
upperBound (Intersection { upper: MinSourced (Sourced v _) }) = v

lowerBound :: Intersection -&gt; Version
lowerBound (Intersection { lower: MaxSourced (Sourced v _) }) = v

good :: Intersection -&gt; Boolean
good i = lowerBound i &lt; upperBound i

satisfies
  :: Version -&gt; Intersection -&gt; Boolean
satisfies v r = v &gt;= lowerBound r &amp;&amp; v &lt; upperBound r

-- `Loose` has to be a valid interval
toLoose :: Intersection -&gt; Maybe Loose
toLoose i | good i = Just (coerce i)
toLoose _ = Nothing

fromLoose :: Loose -&gt; Intersection
fromLoose = coerce</code></pre>
<p>Why donʼt we require <code>Intersection</code>purescript to be a valid interval? As we will talk about in the next section, <code>Intersection</code>purescript is the primary way we keep track of the knowledge we have learned already. Being in the business of aggregating information, we want to know all we can about the situation our solver is confronted with, and we just can accumulate knowledge by throwing it into this semilattice.</p>
<p>We could make taking the intersection of intervals a partially-defined operation (<code>Intersection -&gt; Intersection -&gt; Either Error Intersection</code>purescript), but that means we have to bail out once a single intersection becomes invalid. Instead, we integrate them directly into the semilattice structure by keeping invalid intervals around and turning them into <a href="#errors">errors</a> later (this is why we give them the metadata about <a href="#provenance">provenance</a>!). This gives us multiple errors emerging from one step for free, it is incredibly convenient.</p>
<h4 id="knowledge-propagation">Knowledge propagation</h4>
<p>Figuring out the correct way to propagate known requirements kept me occupied for days. It turns out I had done it wrong the first time, so it is good I thought it over again!</p>
<p>Our goal is to implement <code>solveStep</code>purescript here using <code>commonDependencies</code>purescript (see <a href="#intuitive-foundations-quasi-transitive-dependencies">above</a>) and <code>exploreTransitiveDependencies</code>purescript:</p>
<pre class="purescript"><code>-- Semilattice version of `Registry`
type TransitivizedRegistry =
  SemigroupMap PackageName
    (SemigroupMap Version
      (SemigroupMap PackageName Intersection)
    )

type RRU =
  { registry :: TransitivizedRegistry
  , required :: SemigroupMap PackageName Intersection
  , updated :: TransitivizedRegistry
  }

-- | Discover one step of quasi transitive dependencies, for known requirements
-- | and the rest of the registry too.
solveStep :: RRU -&gt; RRU

-- Key piece:
exploreTransitiveDependencies :: RRU -&gt; RRU</code></pre>
<p>The <code>registry :: TransitivizedRegistry</code>purescript and <code>required :: SemigroupMap PackageName Intersection</code>purescript represent the local dependencies for each package version and the global requirements of the initial manifest given to the solver, respectively. They both are purely accumulative: what goes in comes out with some more information. The additional information will simply be added dependencies and tightened bounds on existing dependencies. Provenance metadata may accumulate too (we donʼt really need to care about that, it is just along for the ride).</p>
<p>The other field, <code>updated :: TransitivizedRegistry</code>purescript, is a bit different: it does not carry over from step to step, it only talks about what changed at the last step. This is because as weʼre keeping <code>registry :: TransitivizedRegistry</code>purescript updated, we want to only calculate updates to the things that might need it.</p>
<p>When we first call <code>solveStep</code>purescript, we treat everything as updated:</p>
<pre class="purescript"><code>solveSeed :: RR () -&gt; RRU
solveSeed { registry, required } = { registry, required, updated: registry }</code></pre>
<p>and the process stabilizes when there are no updates:</p>
<pre class="purescript"><code>-- | Add quasi transitive dependencies until it stabilizes (no more updates).
-- | Needs to know what was updated since it last ran.
solveSteps :: RRU -&gt; RR ()
solveSteps r0 = go r0
  where
  go r@{ registry, required } | noUpdates r = { registry, required }
  go r = go (solveStep r)</code></pre>
<p>Keeping track of what was updated is certainly the trickiest part of the whole algorithm to reason about, but there is this one nugget of insight that coalesced into the knowledge I needed to turn it into an algorithm:</p>
<div class="Key_Idea">
<p>The manifests for package versions might need to update when some of their dependencies update. However, not all updates need to propagate like this from dependencies to their reverse dependencies.</p>
<p>In particular, in the case that a manifest is updating because its dependencies tightened, <em>if</em> this could affect its reverse dependencies they should <em>already</em> be depending on the transitive dependencies directly and updating because of it. This leaves us with the only major updates being because a dependency was <em>added</em>, which the parent did not know about yet so it needs to rescan its dependencies to potentially add the dependency itself.</p>
<p>The other case is that if a package version picks up an obvious failure, its reverse dependencies need to be notified. They may pick up a quasi-transitive dependency once this failing package version is dropped, if it was missing that particular dependency but others had it.</p>
</div>
<pre class="purescript"><code>-- | A package may update because its dependencies tightened, but any reverse
-- | dependencies should have already caught that update in this same tick.
-- | So what we look for is either a new transitive dependency picked up (which
-- | the parent will need to incorporate), or newly failing to solve,
-- | both of which may introduce new dependencies for reverse dependencies
-- | through the `commonDependencies` calculation.
majorUpdate :: SemigroupMap PackageName Intersection -&gt; SemigroupMap PackageName Intersection -&gt; SemigroupMap PackageName Intersection -&gt; Boolean
majorUpdate (SemigroupMap required) (SemigroupMap orig) updated =
  let
    minor = { added: false, failedAlready: false, failedNow: false }

    info :: { added :: Boolean, failedNow :: Boolean, failedAlready :: Boolean }
    info = updated # anyWithIndex \package range -&gt;
      case Map.lookup package orig of
        Nothing -&gt;
          -- This bound may have been omitted merely because it was subsumed by
          -- a global requirement (see `addFrom`), so adding it back does not
          -- count as a major update:
          case Map.lookup package required of
            Nothing -&gt; minor { added = true }
            Just range' -&gt; minor { added = lowerBound range &gt; lowerBound range' || upperBound range &lt; upperBound range' }
        Just r -&gt; minor { failedAlready = not good r, failedNow = not good range }
  in
    case info of
      { added: true } -&gt; true
      { failedNow: true, failedAlready: false } -&gt; true
      _ -&gt; false

-- | Update package versions in the registry with their quasi-transitive
-- | dependencies, if their dependencies were updated in the last tick. The set
-- | global requirements is needed here because those are elided from the
-- | dependencies in each package version, so to tell how the local requirements
-- | updated we need need to peek at that (see `majorUpdate`).
exploreTransitiveDependencies :: RRU -&gt; RRU
exploreTransitiveDependencies lastTick = (\t -&gt; { required: lastTick.required, updated: accumulated (fst t), registry: snd t }) $
  lastTick.registry # traverseWithIndex \package -&gt; traverseWithIndex \version deps -&gt;
    let
      updateOne depName depRange = case Map.isEmpty (unwrap (getPackageRange lastTick.updated depName depRange)) of
        true -&gt; mempty
        false -&gt; Tuple (Disj true) (commonDependencies lastTick.registry depName depRange)
      Tuple (Disj peek) newDeps = foldMapWithIndex updateOne deps
      -- keep GC churn down by re-using old deps if nothing changed, maybe?
      dependencies = if peek then deps &lt;&gt; newDeps else deps
      updated = case peek &amp;&amp; majorUpdate lastTick.required deps dependencies of
        true -&gt; doubleton package version dependencies
        false -&gt; mempty
    in
      Tuple updated dependencies

-- | Discover one step of quasi transitive dependencies, for known requirements
-- | and the rest of the registry too.
solveStep :: RRU -&gt; RRU
solveStep initial =
  { required: initial.required &lt;&gt; moreRequired
  , registry: moreRegistry
  , updated: updated &lt;&gt; updatedOfReqs
  }
  where
  -- Transitivize direct requirements
  moreRequired = initial.required # foldMapWithIndex (commonDependencies initial.registry)
  -- Record updates to them
  updatedOfReqs = requirementUpdates initial moreRequired
  -- Transitivize the rest of the registry, which should be:
  --   (1) Pruned at the start to only reachable package versions
  --   (2) Only touching packages that were directly updated last round
  { updated, registry: moreRegistry } = exploreTransitiveDependencies (initial { registry = map (addFrom moreRequired) &lt;$&gt; initial.registry })</code></pre>
<h4 id="one-simple-trick-for-efficiency">One simple trick for efficiency</h4>
<p>It turns out that the algorithm is naturally efficient, with some help.</p>
<p>The biggest trick is <em>using global constraints to discard redundant local constraints</em>. That is, if the manifest you are solving already constrains <code class="boo">prelude &gt;=6.0.0 &lt;7.0.0</code>, then each package that lists that requirement or a looser one can ignore it.</p>
<pre class="purescript"><code>-- | The key to efficiency: take information from the bounds of global
-- | requirements and add it to the local requirements of each package version
-- | in the registry, BUT remove redundant bounds as we do so.
-- |
-- | For example, if we have a global requirement `&gt;=3.1.0 &lt;4.0.0`, then in the
-- | registry we will keep local dependency ranges for the same package that
-- | look like `&gt;=3.2.0 &lt;4.0.0` or `&gt;=3.1.0 &lt;3.9.0` and remove ranges like
-- | `&gt;=3.0.0 &lt;4.0.0` or `&gt;=3.1.0 &lt;4.0.0` itself.
addFrom
  :: SemigroupMap PackageName Intersection
  -&gt; SemigroupMap PackageName Intersection
  -&gt; SemigroupMap PackageName Intersection
addFrom (SemigroupMap required) =
  over SemigroupMap $ Map.mapMaybeWithKey \package -&gt;
    case Map.lookup package required of
      Nothing -&gt; Just
      Just i -&gt; \j -&gt;
        if j `wouldUpdate` i then Just (j &lt;&gt; i)
        else Nothing

-- | Used in `addFrom, `wouldUpdate j i` is an optimized version of
-- | `(i &lt;&gt; j /= i)`.
wouldUpdate :: Intersection -&gt; Intersection -&gt; Boolean
wouldUpdate j i =
  lowerBound j &gt; lowerBound i ||
  upperBound j &lt; upperBound i</code></pre>
<p>Unfortunately I had to add a bit of special casing in the propagation to handle this, in particular <a href="https://github.com/purescript/registry-dev/blob/30a88ac7bd48a73bb2bcf9240b20b09a713ee0b9/lib/src/Solver.purs#L493-L495">when checking for major updates</a>, but the exceptional efficiency is more than worth the slight inelegance.</p>
<h5 id="oh-but-i-spent-so-much-time-getting-here">Oh but I spent so much time getting here</h5>
<p>I almost made a profiling analysis library. JavaScript performance testing is useless because it gets washed away in a sea of lambdas, and I couldnʼt find/make a tool to aggregate the lambda information into their named parents. Wrap particular segments in profiling.</p>
<p>I also needed a histogram viewer.</p>
<p>Lots of micro optimizations.</p>
<ul>
<li>Using a specific order of <code>&lt;&gt;</code>purescript, since <code>Map</code>purescript appends are implemented as a fold over the second argument so it should be the smaller argument.</li>
<li>Using a difflist (Cayley) representation when I know Iʼm only appending one key at a time but with mixed associativity.</li>
<li>Implementing <code>wouldUpdate</code>purescript directly instead of using the semigroup operation.</li>
<li>Optimizing the <code>Ord Version</code>purescript instance since it is the most common operation in this whole thing.</li>
</ul>
<p>Did they make a difference? I donʼt know! They appeared to make incremental difference as I was testing it, but once I did the big optimization above I gave up on testing that.</p>
<h3 id="errors">Errors</h3>
<p>Room for improvement. But decent off the bat. And a clear direction for improvement, unlike depth-first algorithms.</p>
<p>Conflicts. (Conflict “clauses.”) The problem with backtracking was that the errors . Particular clauses could conflict, sure, but then you had to work out why that made the whole boolean expression fail, and what that corresponds to in the version solving model.</p>
<p>In the new model, since we just keep adding requirements at each step to tighten bounds, the basic form of conflict is really simple: a required upper bound got pushed below a required lower bound. Or, we could have restricted to a range that has no registered versions.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<p>There are two ways we combine these errors within the logic of the solver:</p>
<ol type="1">
<li>First we note that we may encounter errors in multiple requirements at the same time, so we keep a (non-empty) map of package names to their conflicts. (Reporting multiple errors at once is very helpful!)</li>
<li>Second it may be the case that a package has versions in range, but we happen to know that none of them are still solvable, they all have conflicts of their own. (We actually just do a <a href="https://github.com/purescript/registry-dev/blob/30a88ac7bd48a73bb2bcf9240b20b09a713ee0b9/lib/src/Solver.purs#L300-L304">very shallow check of this</a>.)</li>
</ol>
<p>This gets us <a href="https://github.com/purescript/registry-dev/blob/30a88ac7bd48a73bb2bcf9240b20b09a713ee0b9/lib/src/Solver.purs#L149-L151">this data type for errors</a>:</p>
<pre class="purescript"><code>data SolverError
  = Conflicts (Map PackageName Intersection)
  | WhileSolving PackageName (Map Version SolverError)</code></pre>
<p>This isnʼt completely faithful to the logic of the solver. You have to trust that the system determined these are required: it wonʼt tell you exactly what decisions led to it requiring it.</p>
<p>But it does keep around provenance information that tells you enough about where it originated.</p>
<h4 id="provenance">Provenance</h4>
<p>Normally I like to keep full provenance to detail exactly the path a piece of data took to get through the logic.<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> However, it is really slick in this domain: we only need to keep track of the endpoints, users donʼt exactly care about what came in between (just that it is reasonable to assume, because it is in fact correct).</p>
<p>So in this case I keep track of which particular package version manifest(s) gave us the constraint we are talking about (<code>LocalSolverPosition</code>purescript), and which constraints in the current manifest caused it to be required. Thereʼs some logic to combine these positions which I will not reproduce here.</p>
<pre class="purescript"><code>data LocalSolverPosition
  -- | Dependency asked for in manifest
  = Root
  -- | Committed to a specific version
  | Trial
  -- | Required transitive dependency seen in said packages
  | Solving
      ( NonEmptySet
          { package :: PackageName
          , version :: Version
          }
      )

data SolverPosition = Pos LocalSolverPosition (Set PackageName)</code></pre>
<p>It seems that it weakens the logical connection just a bit, I donʼt know if they can be put into formal properties anymore. (<span data-t="" data-widget="">E.g.</span> “Deleting the mentioned constraint from the current manifest affects it in <em>this</em> way.”)</p>
<p>But I believe it is the information that users want to see; it certainly falls into the category of making it actionable so they can fix things and run it again to make progress. In the case that it is a local error, knowing which clauses of the current manifest led to it is crucial in answering the question, “What do I need to change to fix the error”. And sometimes it is a deeper error of outdated dependencies, so you want to know what package is responsible for that incongruous version requirement.</p>
<div class="Bonus" data-box-name="Side thought">
<p>Itʼs interesting that nothing here required that dependencies are acyclic. I actually made some tiny decisions that ensured that this would work, without causing an infinite loop for example, but it was minor things.</p>
</div>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>The Elm version solver has <a href="https://github.com/elm/compiler/blob/c9aefb6230f5e0bda03205ab0499f6e4af924495/builder/src/Reporting/Exit.hs#L902-L905">network errors</a>, but apparently <a href="https://github.com/elm/compiler/blob/c9aefb6230f5e0bda03205ab0499f6e4af924495/builder/src/Deps/Solver.hs#L102">no actual errors</a> from the simple solve-by-backtracking algorithm.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>No, for real this time!!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Actually we probably donʼt even need a total order, a partial order would work fine for it?<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>This is actually a weird requirement, since there can be incomparable solutions that need to be tie-broken arbitrarily. In practice I do it alphabetically just by dint of how the package versions are tried.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Since we chose a particular version in the previous step, its dependency ranges are well-defined, just being given in its manifest.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p> The only difference between two versions of the same package with the same manifests is that some later requirements may constrain that packageʼs range to eliminate one or the other.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Foreshadowing …<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p> If the logical scenario does not have a finite upper bound of information to derive, this naïve process may not terminate, but in our case it is certainly finite: the registry itself is finite, so any logical derivations from it will eventually be saturated.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>I cannot emphasize how key this is to a lot of the work of carrying around metadata by bundling it in with data like this.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>It turns out these are the <a href="https://github.com/purescript/registry-dev/blob/30a88ac7bd48a73bb2bcf9240b20b09a713ee0b9/lib/src/Solver.purs#L308-L311">same check</a>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p> In particular, in dependently-typed languages it is really helpful to be able to trace terms through their evaluation, so that by the time you get to a type error you know exactly why those particular things popped up, not just a rough idea of where in the source they were originally found once upon a time. Especially because once separate terms are unified, you donʼt want to arbitrarily pick a location, you want to know both locations!<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
<item>
<title>Impossible Bézier Calligraphy</title>
<pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/bezier_calligraphy.html</guid>
<description><![CDATA[<p>The story of how I implemented calligraphy for <a href="https://www.jasondavies.com/animated-bezier/">cubic Bézier curves</a> (the kind widely used in graphics programs, especially the common <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">Scalable Vector Graphics (SVG) format</a>).</p>
<p>The problem statement:</p>
<div class="Key_Idea" data-box-name="Challenge">
<p>Given a pen nib of some shape, what composite shape is produced when that pen is drawn along any particular path?</p>
<p>If the inputs are cubic Bézier curves, is the output as well?</p>
<div class="Bonus" data-box-name="Jargonized">
<p>Is the <a href="https://en.wikipedia.org/wiki/Minkowski_addition">Minkowski sum</a> of two piecewise cubic Bézier hulls a <a href="https://en.wikipedia.org/wiki/Composite_B%C3%A9zier_curve">piecewise cubic Bézier hull</a>?</p>
<p>More specifically, is the the convolution of two cubic Bézier curves a cubic Bézier curve?</p>
</div>
</div>
<p>The catch? Itʼs mathematically impossible to model the output using cubic curves, as I determined after a bit calculus. In fact, it fails already for <em>quadratic</em> curves (the simpler companion to cubic curves, which would have simpler, more tractable solutions).</p>
<p>The cubic in “cubic Bézier curve” refers to the fact that they are parametric curves modeled by <em>cubic polynomials</em> (one polynomial for the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span> coordinate and one polynomial for the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span> coordinate, in terms of a shared time variable <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span>). Simply put, the solution for how the curves of the pen and the curves of the path interact means that the solution wonʼt be a polynomial anymore, it would at least be a <a href="https://en.wikipedia.org/wiki/Rational_function">rational function</a>, <span class="foreign" lang="la">i.e.</span> a polynomial divided by another polynomial.</p>
<p>However, that doesnʼt prevent us from getting pretty darn close. Let me show you how it works out.</p>
<div class="Note">
<p>Cubic polynomials have nothing to do with Cubism. At least, not that I know of.</p>
</div>
<h2 id="backstory">Backstory</h2>
<p>You want to know how I got here? The story begins with a car trip. My customary activity while riding in the car is to invent new writing systems, drawing on my tablet to try different calligraphic curves to start establishing what shapes I want to represent various sounds. (I tend to develop <a href="https://en.wikipedia.org/wiki/Featural_writing_system">featural writing systems</a> based on sounds represented by the <a href="https://en.wikipedia.org/wiki/International_Phonetic_Alphabet">International Phonetic Alphabet</a>.)</p>
<p>Of course, doing this in the car is hard mode already! The bumps of the car mean I have to use the tablets undo feature for more strokes than not. Plus, not only are there the mistakes of my hand being jostled by the car going over bumps, thereʼs also the mistakes of me just being mediocre at calligraphy, <em>plus</em> the fact that I have to teach myself the script as Iʼm inventing it! (I do love the creative interaction of drawing random shapes, seeing what feels good, and refining it both intentionally and through the natural iterations.)</p>
<p>Iʼve done this for many years, since before I could drive. As long as Iʼve done that, Iʼve also wanted to digitize the shapes, maybe to make them into a computer font so I donʼt have to manually write things out when I want to see how full sentences look. (ʼTwould also be a great way to explore ligatures and open type features to really make a natural flowing calligraphic font …)</p>
<p>As I mentioned above, the precisely stated mathematical problem says the curves we are looking for arenʼt the type of curves supported by graphics programs today. But why let the mathematical impossibilities get in the way of actually quite good enough? It took me until now to have the skills/insight/motivation to finally realize my dream, and I want to share the result and the process with you.</p>
<h2 id="demo">Demo</h2>
<p>But first, always start with the demo! Here you can see the musculoskeletal anatomy of a Minkowski calligraphy stroke:</p>
<script src="https://cdn.jsdelivr.net/npm/path-data-polyfill@1.0.3/path-data-polyfill.min.js"></script>
<style>
  #superpath path:nth-child(2n) {
    stroke: blue;
  }
  .annot path:hover {
    stroke: blue;
    fill: #0059;
    pointer-events: stroke;
  }
  [id$="-calligraphy-demo"] > svg {
    width: 50%;
  }
  @media (max-width: 760px) {
    [id$="-calligraphy-demo"] > svg {
      width: 100%;
    }
  }
</style>
<div id="main-calligraphy-demo">

</div>
<label><input id="anatomy" type="checkbox" checked=""> Overlay anatomy</label>
<script src="assets/js/quartic.js"></script>
<script src="assets/js/calligraphy.js"></script>
<script src="assets/js/minkowski.js"></script>
<p><br></p>
<div class="Details" data-box-name="Legend">
<ul>
<li>Black area – the algorithm as it current stands.</li>
<li>Red area – the ideal output, approximated. (double click on the black to generate a more and more fine approximation)</li>
<li>Green lines – the patchwork of simple segments (click to debug, double click to delete).</li>
<li>Orange lines – the special paths added via the approximate convolution algorithm. </li>
</ul>
</div>
<h2 id="big-picture">Big picture</h2>
<p>We can take apart the pen nib and pen path into a bunch of segments and compute the composite of each segment with each segment (<a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>). Each composite of individual segments produces a section of the result, resulting in a patchwork of sections that form the whole composite shape. Having a lot of overlapping sections is OK, since <span class="foreign" lang="la">e.g.</span> Inkscapeʼs builtin Boolean operations will simplify the shapes for us.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>In fact, we will end up subdividing the original segments a bunch to produce accurate results:</p>
<ul>
<li>We donʼt want any self-intersecting segments [not implemented yet].</li>
<li>We also donʼt want any segments that stop (their derivative is zero).</li>
<li>The pen nib needs to be split up at inflection points, so its slope is monotonic along the segment.
<ul>
<li>This is because the slope of the pen path needs to be mapped onto the pen nib, and we want a unique solution.</li>
</ul></li>
<li>The pen nib also needs to be split up so that it doesnʼt loop around [not implemented yet].
<ul>
<li>More specifically, each segment needs to be split at the tangent of an endpoint.</li>
</ul></li>
<li>The pen paths need to be split at the tangents of the endpoints of the pen nib segment it is being combined with.
<ul>
<li>This ensures that each segment either traces out the obvious thing or has a composite.</li>
<li>Basically we want that either the tangents are disjoint or the pen nibʼs tangents are contained in the pen pathʼs tangents.</li>
</ul></li>
</ul>
<p>Then the task is to come up with the sections that form the patchwork:</p>
<ul>
<li>The original segments form corners (especially if they are disjoint)
<ul>
<li>With only this, you essentially get stamps at the endpoints, connected by rakes from the points; see the <a href="#smooth-sailing">smooth sailing</a> section.</li>
</ul></li>
<li>Finally the special composite that we will spend a lot of time discussing (if the tangents are a subset)</li>
</ul>
<p>But thatʼs the end result, letʼs see how I got to this algorithm.</p>
<h3 id="smooth-sailing">Smooth sailing</h3>
<p>The simplest approach is to paste each path on each segment, something like this:</p>
<pre class="javascript"><code>(Ps,Qs) =&gt; Ps.flatMap(P =&gt; Qs.flatMap(Q =&gt; [shift(Q, P[0]), shift(P, Q[0])]))</code></pre>
<p>Mathematically we would say weʼre taking the <a href="https://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a> of the segments.</p>
<p>I was able to do this much in Inkscape directly: copy some segments, align them. You can even make linked clones so it updates altogether.</p>
<div id="simplest-calligraphy-demo">

</div>
<p><label><input id="anatomy-simplest" type="checkbox" checked=""> Overlay anatomy</label></p>
<p>But there were problems: when the paths crossed over it got noticeably too thin. Even before then, the curves were trending too close, as you can see by double-clicking on it to reveal the red approximation. Basically if the pen nib wasnʼt made of perfectly straight lines, the composite stroke would be missing stuff.</p>
<p>Essentially this process is simulating what you would get by stamping the pen nib in certain points, and then drawing a rake through the path to connect them with curves. (The rake only touching the paper at the segmentation points of the pen nib.)</p>
<p>It appeared that anything more complex would require algorithmic help, and oh was I right … There were more issues lurking with curved segments.</p>
<h3 id="point-of-no-return">Point of no return</h3>
<p>Where tangents go wrong.</p>
<p>I sat down and tried to analyze where this occurred. My first thought was what I said above: itʼs where the crossovers happen, right? Right??</p>
<p>However, I realized that canʼt possibly be right: when the curves fail to cover the actual sweep of the pen, it has already separated by the time the curves actually cross over each other, and continues afterwards. That is, the cross-over is a symptom of the issue but not the part the delimits it.</p>
<p>Looking at it more closely (literally) I realized that the separation occurs precisely when the path of the pen parallels the endpoint tangent of one of the curvy segments of the pen nib.</p>
<p>My first thought was to stamp out the problem: insert more stamps of the pen nib at these problematic tangent points where it wants to detach from the real path. Little did I know this was only the start of unraveling a long thread … it was not enough! For longer curvy segments, it was clear that the extra stamps only masked the problem and did not account for what lay between them.</p>
<div id="simple-calligraphy-demo">

</div>
<p><label><input id="anatomy-simple" type="checkbox" checked=""> Overlay anatomy</label></p>
<p>The main insight, which I have already spoiled for you, is that we need to find some composite of the curves of the pen nib with the curves in the pen path, a composite which is not identical to either curve.</p>
<h4 id="need-for-composite-curves">Need for composite curves</h4>
<p>To step back from calligraphy for a moment, consider a simpler example: drawing with a circular sponge, marker, whatever. Make it comically big in your mind.</p>
<p>If you draw a straight line, the composite path is very simple: the two endpoints are capped by a semicircle and are connected by a rectangle.</p>
<p>Now consider a curved path: you can quickly imagine that two semicircles joined by the exact path will not do the job. First of all the endpoints are wrong to connect with the endcaps, second of all the curve would look funny!</p>
<p>If you slow down and look at some point on the curve very closely, what points on the circle are actually doing the work of drawing? What part of the circle is extremally far from the curve at that point? The part that is tangent to the curve!</p>
<p>Thus we will end up offsetting each point on the curve by the radius perpendicular to the curveʼs tangent.</p>
<div class=".Bonus">
<p>In fact, this offset curve is no longer a Bézier curve: it is an <a href="https://raphlinus.github.io/curves/2022/09/09/parallel-beziers.html">analytic curve of degree 10</a>.</p>
<p>Funnily enough, although it is mathematically complicated, all graphics programs support approximating this cubic Bézier + circular pen combo: this is just the stroke width parameter of SVG Bézier curves.</p>
<p>As far as the main topic of this post goes, the underlying mathematic impossibility should not discourage us quite yet: circles cannot be exactly captured by Bézier curves either, so our focus on cubic Bézier pen nibs may still be okay. (Spoiler: it is not.)</p>
</div>
<p>This thought experiment shows that we really want to find the tangent point on the pen nib that corresponds with the tangent from the pen path. If we can correlate the two for each point in time, we would get a composite path that fills out the proper area, more than the rake and stamp method.</p>
<h3 id="dead-reckoning">Dead reckoning</h3>
<p>Now we can find a precise curve to work towards: given two “nice” curves, we add up all the points where their tangents are parallel, to obtain a new curve. (This is called the convolution of the two curves.)</p>
<p>We hope to solve this in the case of cubic curves in particular: given a tangent from one curve (the pen path), find the time when the other curve (the pen nib) has the same tangent, and add those points together.</p>
<h4 id="death">Death</h4>
<p>Letʼs try a simpler thing first and see why it fails: we can keep the pen path as a cubic Bézier, but restrict the pen nib to being quadratic.</p>
<p>Taking the tangent <em>vector</em> of each curve decreases degree by one: the cubic Bézier has a quadratic tangent <em>vector</em>, and the quadratic Bézier has a linear tangent <em>vector</em>. This sounds okay so far, but recall that we want the tangents to have the same <em>slope</em> (to be parallel). This makes us take fractions (see below for more details in the cubic case).</p>
<p>So the solution is a <a href="https://en.wikipedia.org/wiki/Rational_function">rational function</a> (ratio of two polynomials). Bézier curves are polynomials, not rational functions, so the result will not be a Bézier curve.</p>
<p>Dealing with cubic curves, their tangent vector (being the derivative of their position vector) is a quadratic function. We want the two tangent vectors to be parallel, so we end up with a quadratic equation of one in terms of the other. Solving the quadratic equation introduces radicals, so it is no longer even a rational function in the cubic case.</p>
<h4 id="reckoning">Reckoning</h4>
<p>So we set about approximating the exact curve by a Bézier one.</p>
<p>The first question to ask ourselves is: what are the tangents of the curve at the endpoints? This is a simple question, actually: since we are picking points from the curves where the tangents match, the tangent is simply what it was for the base curve. (We will work through the math below to prove why this is the case.)</p>
<p>If we were approximating by a quadratic curve, this would be all we need to know: the last control point would be at the intersection of the tangents from the endpoints.</p>
<p>But since it is cubic, we have two more points to pick, which should correspond abstractly to another parameter to control at each endpoint, in addition to the tangent there.</p>
<p>Youʼd think this parameter would be curvature. Youʼd <strong>think</strong>!!</p>
<h3 id="why-curvature">Why curvature?</h3>
<p>The obvious first parameter to control is the tangent angles. If we were approximating with quadratic curves, this would be all there is to it: two points and two tangents.</p>
<p>Working with cubic curves, however, we expect an extra degree of freedom: more control over how it matches our curve. The obvious place to look is curvature.</p>
<p>Curvature (often denoted <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi></mrow><annotation encoding="application/x-tex">\kappa</annotation></semantics></math></span>) is a geometric quantity that captures second-order behavior of a curve, regardless of parametrization. That is, regardless of how <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span> maps to actual <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">\langle x, y \rangle</annotation></semantics></math></span> points on the curve, if the curve looks the same, it will have the same curvature.</p>
<p>However, it is not so simple to map curvature onto the Bézier curve parameters, as weʼll see next.</p>
<p>For one thing, the formula involves a complex mix of components: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>κ</mi><mo>=</mo><mfrac><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>y</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>−</mo><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><msup><mi>y</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mrow><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mi>y</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><msup><mo stretchy="false">)</mo><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\kappa = \frac{x'y'' - x''y'}{(x'^2 + y'^2)^{3/2}}.</annotation></semantics></math></span></p>
<p>And then add in the complexities of the Bézier parameterization and you have a fun problem that yields non-unique solutions.</p>
<p>The proliferation of solutions is kind of problematic since it means we need to guess what is the right solution. At least we know we are looking for clean-looking solutions that do not deviate too much.</p>
<div class="Bonus" data-box-name="Aside">
<p>Itʼs funny: in order to display curvature in a geometrically meaningful way, you want it to be in units of distance, which means youʼd take its inverse <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>κ</mi></mrow><annotation encoding="application/x-tex">1/\kappa</annotation></semantics></math></span>. This inverse is the radius of the <em>osculating circle</em> that just barely touches the curve in the most graceful way. (Perhaps you know that you can form a circle passing through any three points, possibly a circle with infinite radius if the points are <a href="https://en.wikipedia.org/wiki/Collinearity">along the same line</a>. This is why it is a second-order property.)</p>
<p>However, despite being in the right units, the radius of the osculating circle is poorly behaved because it can blow up to infinity when the curvature is near zero! (<span class="foreign" lang="la">E.g.</span> near inflection points.)</p>
<p>So people often resort to displaying curvature as a kind of vector field associated with the curve, with some implicit conversion of units from inverse distance to real distance.</p>
<p>There is a third-order analogue of curvature called <a href="https://www.jstor.org/stable/2690245">aberrancy</a>. It is related to the <em>osculating parabola</em>, since parabolas rotated in space can be fit to four points.</p>
</div>
<h2 id="details.-oh-so-many-details">Details. Oh so many details</h2>
<p>In which we work through the math to compute a cubic Bézier approximation to cubic Bézier convolution, based on matching the known curvature at the endpoints of the exact convolution.</p>
<h3 id="background-and-notation">Background and notation</h3>
<p>If you want to dig into the details youʼll want some familiarity with vectors, calculus, and parametric curves.</p>
<p>Bézier curves are parametric curves based on some control points. Weʼll only be dealing with 2D cubic Bézier curves. Weʼll put the control points in boldface like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>, and give the 2D vectors arrows over top like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{u}</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math></span>.</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">P</mi><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>0</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>0</mn><mi>y</mi></mrow></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub><mo stretchy="false">⟩</mo><mo separator="true">,</mo><mo stretchy="false">⟨</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>3</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>3</mn><mi>y</mi></mrow></msub><mo stretchy="false">⟩</mo><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{P} = [\langle \mathbf{P}_{0x}, \mathbf{P}_{0y}\rangle, \langle \mathbf{P}_{1x}, \mathbf{P}_{1y}\rangle, \langle \mathbf{P}_{2x}, \mathbf{P}_{2y}\rangle, \langle \mathbf{P}_{3x}, \mathbf{P}_{3y}\rangle].</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">P</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{P} = [\mathbf{P}_{0}, \mathbf{P}_{1}, \mathbf{P}_{2}, \mathbf{P}_{3}].</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mi>x</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>0</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub><mo separator="true">,</mo><msub><mi mathvariant="bold">P</mi><mrow><mn>3</mn><mi>x</mi></mrow></msub><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}_ {x} = [\mathbf{P}_{0x}, \mathbf{P}_{1x}, \mathbf{P}_{2x}, \mathbf{P}_{3x}].</annotation></semantics></math></span></p>
<p>We need the formula for the Bézier polynomial that results from the control points, and weʼll also need its first and second derivatives:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mstyle scriptlevel="0" displaystyle="true"><msub><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi></msub><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mstyle></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mn>3</mn></msup><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo>+</mo><mn>3</mn><mi>t</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>+</mo><mn>3</mn><msup><mi>t</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>+</mo><msup><mi>t</mi><mn>3</mn></msup><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>t</mi><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><msup><mi>t</mi><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo>−</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><msup><mi>t</mi><mn>3</mn></msup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>3</mn><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mi>t</mi><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn><msup><mi>t</mi><mn>2</mn></msup><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>t</mi><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo>−</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><msup><mi>t</mi><mn>2</mn></msup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msubsup><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>t</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mi>t</mi><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>+</mo><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">P</mi><mn>3</mn></msub><mo>−</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi mathvariant="bold">P</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">P</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>t</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\displaystyle \mathbf{B}_\mathbf{P}(t)
  &amp;= (1-t)^3 \mathbf{P}_0 + 3t(1-t)^2 \mathbf{P}_1 + 3t^2(1-t) \mathbf{P}_2 + t^3 \mathbf{P}_3\\
  &amp;= \mathbf{P}_0 + 3(\mathbf{P}_1 - \mathbf{P}_0)t + 3(\mathbf{P}_2 - 2\mathbf{P}_1 + \mathbf{P}_0)t^2 + (\mathbf{P}_3 - 3\mathbf{P}_2 + 3\mathbf{P}_1 - \mathbf{P}_0)t^3.\\
\mathbf{B}'_\mathbf{P}(t)
  &amp;= 3(1-t)^{2}(\mathbf{P} _{1}-\mathbf{P} _{0})+6(1-t)t(\mathbf{P} _{2}-\mathbf{P} _{1})+3t^{2}(\mathbf{P} _{3}-\mathbf{P} _{2})\\
  &amp;= 3(\mathbf{P}_1 - \mathbf{P}_0) + 6(\mathbf{P}_2 - 2\mathbf{P}_1 + \mathbf{P}_0)t + 3(\mathbf{P}_3 - 3\mathbf{P}_2 + 3\mathbf{P}_1 - \mathbf{P}_0)t^2.\\
\mathbf{B}''_\mathbf{P}(t)
  &amp;= 6(1-t)(\mathbf{P} _{2}-2\mathbf{P} _{1}+\mathbf{P} _{0})+6t(\mathbf{P} _{3}-2\mathbf{P} _{2}+\mathbf{P} _{1})\\
  &amp;= 6(\mathbf{P}_2 - 2\mathbf{P}_1 + \mathbf{P}_0) + 6(\mathbf{P}_3 - 3\mathbf{P}_2 + 3\mathbf{P}_1 - \mathbf{P}_0)t.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>Naturally the first derivative of a cubic Bézier is quadratic, and the second derivative is linear.</p>
<h4 id="d-cross-product"><span style="font-variant-numeric: lining-nums">2D</span> cross product</h4>
<p>Normally we think of it in 3D space, because the cross product of two 3D vectors is another 3D vector. But it also works in 2D space, it just produces a scalar (1D vector) instead! And it turns out to be a useful abstraction for a lot of our calculations.</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>u</mi><mo>⃗</mo></mover><mo>×</mo><mover accent="true"><mi>v</mi><mo>⃗</mo></mover><mo>=</mo><msub><mi>u</mi><mi>x</mi></msub><msub><mi>v</mi><mi>y</mi></msub><mo>−</mo><msub><mi>u</mi><mi>y</mi></msub><msub><mi>v</mi><mi>x</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\vec{u} \times \vec{v} = u_x v_y - u_y v_x.</annotation></semantics></math></span></p>
<h3 id="matching-the-curves-up">Matching the curves up</h3>
<p>The two curves are controlled by their own <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span> parameters that are independent of each otherʼs! We need to match them up somehow, and as discussed above, thereʼs a particular way to do that for our application: We need to find the times when they have <em>parallel tangent lines</em>, since that will tell us what is the furthest point of the pen nib (<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>) (locally) along any given point of the pen path (<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span>).</p>
<p>The slope of the tangent line at time <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span> is given by the ratio of the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span> components of the first derivative of the curve. <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>t</mi><msub><mo stretchy="false">)</mo><mi>y</mi></msub></mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>t</mi><msub><mo stretchy="false">)</mo><mi>x</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\mathbf{B}'_\mathbf{P}(t)_y}{\mathbf{B}'_\mathbf{P}(t)_x}.</annotation></semantics></math></span></p>
<p>Weʼll start using <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msub><mi>t</mi><mi mathvariant="bold">P</mi></msub></mrow><annotation encoding="application/x-tex">p = t_\mathbf{P}</annotation></semantics></math></span> to refer to the time along curve <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><msub><mi>t</mi><mi mathvariant="bold">Q</mi></msub></mrow><annotation encoding="application/x-tex">q = t_\mathbf{Q}</annotation></semantics></math></span> to refer to the time along curve <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>. Weʼll think of it as solving for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span> in terms of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>; <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> is the input and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span> the output. Our goal is to match them up, so the curves have the same slope at corresponding times!</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><msub><mo stretchy="false">)</mo><mi>y</mi></msub></mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><msub><mo stretchy="false">)</mo><mi>x</mi></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><msub><mo stretchy="false">)</mo><mi>y</mi></msub></mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><msub><mo stretchy="false">)</mo><mi>x</mi></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{\mathbf{B}'_\mathbf{Q}(q)_y}{\mathbf{B}'_\mathbf{Q}(q)_x} = \frac{\mathbf{B}'_\mathbf{P}(p)_y}{\mathbf{B}'_\mathbf{P}(p)_x}.</annotation></semantics></math></span></p>
<p><strong>Cross</strong> multiply <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><msub><mo stretchy="false">)</mo><mi>y</mi></msub></mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><msub><mo stretchy="false">)</mo><mi>x</mi></msub></mrow><mo>=</mo><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><msub><mo stretchy="false">)</mo><mi>x</mi></msub></mrow><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><msub><mo stretchy="false">)</mo><mi>y</mi></msub></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">{\mathbf{B}'_\mathbf{Q}(q)_y} {\mathbf{B}'_\mathbf{P}(p)_x} = {\mathbf{B}'_\mathbf{Q}(q)_x} {\mathbf{B}'_\mathbf{P}(p)_y}.</annotation></semantics></math></span></p>
<p>Or use the <strong>cross</strong> product: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">\mathbf{B}'_\mathbf{Q}(q) \times \mathbf{B}'_\mathbf{P}(p) = 0.</annotation></semantics></math></span></p>
<p>(Recall that the cross product is a measure of how <em>perpendicular</em> two vectors are, so they are <em>parallel</em> exactly when their cross product is zero. This is true in 2D just like in 3D, itʼs just that the cross product is now a scalar quantity, not a vector quantity.)</p>
<p>What does this get us? Well, we can think of it either way, but letʼs assume that weʼre given <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, so we plug it in and obtain an equation to solve for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>. Since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup></mrow><annotation encoding="application/x-tex">\mathbf{B}'_ \mathbf{Q}</annotation></semantics></math></span> is quadratic, we get a quadratic equation to solve, with some nasty scalar coefficients <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span> coming from the control points of our curves <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>, evaluated at <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>q</mi><mo>+</mo><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">a(p)q^2 + b(p)q + c(p) = 0.</annotation></semantics></math></span></p>
<p>Obviously it gets tedious to write all of that, so we omit the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> parameter and simply write: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>q</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">aq^2 + bq + c = 0.</annotation></semantics></math></span></p>
<h4 id="issues">Issues</h4>
<p>Thereʼs a few issues we run into.</p>
<p>The first is that the solution doesnʼt necessarily lie on the actual Bézier segment drawn out by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>q</mi><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \le q \le 1</annotation></semantics></math></span>.</p>
<p>Second there might be two solutions, since weʼre solving a quadratic!</p>
<p>The solution to both is to split things up! We need to split up the <em>pen path</em> so it indexes the tangents at the end of the Bézier segments of the pen nib, after first splitting the <em>pen nib</em> at its inflection points.</p>
<p>Splitting at inflection points ensures that the tangent slope is always increasing or decreasing along the segment, making there only be a single solution. Actually this requires also knowing that the Bézier segment doesnʼt rotate 180°, so we need to split it if it reaches its original tangents again.</p>
<p>Solving these issues means we can think of the equation above as giving us a function for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span> in terms of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>±</mo><msqrt><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">q(p) = \frac{-b(p) \pm \sqrt{b(p)^2 - 4a(p)c(p)}}{2a(p)}.</annotation></semantics></math></span></p>
<p>This puts the functions in lock-step in terms of their tangents, giving us what we need to calculate the outside of their sweep.</p>
<h4 id="derivative-of-this">Derivative of this</h4>
<p>Weʼll need the derive of this equation soon, so letʼs calculate it while weʼre here.</p>
<p>My first thought was great, we have a quadratic equation, so we know the formula and can just take the derivative of it!</p>
<p>This was … naïve, oh so naïve. Letʼs see why.</p>
<p>We have our solution here:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo>=</mo><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
q = q(p) = \frac{-b\pm\sqrt{b^2 - 4ac}}{2a}.
</annotation></semantics></math></span></p>
<p>So we can take its derivative <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q' = q'(p)</annotation></semantics></math></span>, using the chain rule, quotient rule, product rule … oh Iʼll spare you the gory details.</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>±</mo><mfrac><mrow><mn>2</mn><mi>b</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mn>4</mn><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>c</mi><mo>−</mo><mn>4</mn><mi>a</mi><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mfrac><mo stretchy="false">)</mo><mn>2</mn><mi>a</mi><mo>+</mo><mn>2</mn><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><msup><mi>a</mi><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo>−</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>±</mo><mfrac><mrow><mn>2</mn><mi>b</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><mn>4</mn><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>c</mi><mo>−</mo><mn>4</mn><mi>a</mi><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt></mfrac></mrow><mrow><mn>2</mn><mi>a</mi></mrow></mfrac><mo>+</mo><mfrac><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt><mo stretchy="false">)</mo></mrow><mrow><mn>2</mn><msup><mi>a</mi><mn>2</mn></msup></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
q'
  &amp;= \frac{(-b'\pm\frac{2bb' - 4a' c - 4ac'}{\sqrt{b^2 - 4ac}})2a + 2a'(-b\pm\sqrt{b^2 - 4ac})}{4a^2}\\
  &amp;= \frac{-b'\pm\frac{2bb' - 4a' c - 4ac'}{\sqrt{b^2 - 4ac}}}{2a} + \frac{a'(-b\pm\sqrt{b^2 - 4ac})}{2a^2}
\end{aligned}
</annotation></semantics></math></span></p>
<p>(Recall that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span> are functions of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, so they have derivatives <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a'</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">b'</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">c'</annotation></semantics></math></span> in terms of that variable.)</p>
<p>Notice any problems?</p>
<p>Well, first off, itʼs an ugly, messy formula! And thatʼs even with hiding the definitions of the coefficients <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>.</p>
<p>The biggest problem, though, is that everything is divided by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>a</mi></mrow><annotation encoding="application/x-tex">2a</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">4a^2</annotation></semantics></math></span>, which means it doesnʼt work when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0</annotation></semantics></math></span>. That shouldnʼt be too surprising, given that the quadratic formula also fails in that case. (Itʼs the <em>quadratic</em> formula after all, not the <em>quadratic-or-linear</em> formula!)</p>
<p>I mean, we could solve the linear case separately:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mi>q</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">
bq + c = 0
</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>q</mi><mo>=</mo><mfrac><mrow><mo>−</mo><mi>c</mi></mrow><mi>b</mi></mfrac></mrow><annotation encoding="application/x-tex">
q = \frac{-c}{b}
</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><mo>−</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>b</mi><mo>+</mo><mi>c</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><msup><mi>b</mi><mn>2</mn></msup></mfrac><mo>=</mo><mfrac><mrow><mo>−</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mi>b</mi></mfrac><mo>+</mo><mfrac><mrow><mi>c</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><msup><mi>b</mi><mn>2</mn></msup></mfrac></mrow><annotation encoding="application/x-tex">
q' = \frac{-c' b + cb'}{b^2} = \frac{-c'}{b} + \frac{cb'}{b^2}
</annotation></semantics></math></span></p>
<p>But that also doesnʼt work; it omits the contribution of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a'</annotation></semantics></math></span>, which does in fact influence the result of the rate of change of the quadratic formula, even when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 0</annotation></semantics></math></span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>So I took a deep breath, started texting my math advisor, and I <a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">rubber ducked</a> myself into a much <em>much</em> better solution.</p>
<p>You see, the quadratic formula is a lie. How did we define <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>? Certainly not as a complicated quadratic formula solution. It is <strong>really</strong> defined as the implicit solution to an equation (an equation which happens to be quadratic): <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>q</mi><mo>+</mo><mi>c</mi><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">aq^2 + bq + c = 0.</annotation></semantics></math></span></p>
<p>Look, we can just take the derivative of that whole equation, even before we attempt to solve it (only takes the product rule this time!):</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><mi>q</mi><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi><mo>+</mo><mi>b</mi><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">
a'q^2 + 2aqq' + b'q + bq' + c' = 0.
</annotation></semantics></math></span></p>
<p>And <strong>this</strong>, now <em>this</em> has a nicer solution: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi><mo>+</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mrow><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
q' = \frac{a' q^2 + b' q + c'}{2aq + b}.
</annotation></semantics></math></span></p>
<p>I think itʼs cute how the numerator is another quadratic polynomial with the derivatives of the coefficients of the original polynomial. Itʼs also convenient how we have no square roots or plusminus signs anymore – instead we write the derivative in terms of the original solution <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>.</p>
<p>We still have a denominator that can be zero, but this is for deeper reasons: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo>−</mo><mi>b</mi><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt><mo>+</mo><mi>b</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi></mrow></msqrt><mo>=</mo><mn>0.</mn></mrow><annotation encoding="application/x-tex">2aq + b = -b \pm \sqrt{b^2 - 4ac} + b = \pm \sqrt{b^2 - 4ac} = 0.</annotation></semantics></math></span></p>
<p>Obviously this is zero exactly when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mn>2</mn></msup><mo>−</mo><mn>4</mn><mi>a</mi><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">b^2 - 4ac = 0</annotation></semantics></math></span>. This quantity is called the discriminant of the quadratic, and controls much of its behavior: the basic property of how many real-valued solutions it has, as well as deeper number-theoretic properties studied in <a href="https://cofree.coffee/~verity/">Galois theory</a>.</p>
<div class="Bonus" data-box-name="Aside">
<p>I was looking at this and seeing <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">q^2</annotation></semantics></math></span> made me think that it could be rewritten a bit, since we can solve for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">q^2</annotation></semantics></math></span> in the defining equation:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>q</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mo>−</mo><mi>c</mi><mo>−</mo><mi>b</mi><mi>q</mi></mrow><mi>a</mi></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">
q^2 = \frac{-c-bq}{a}.
</annotation></semantics></math></span></p>
<p>With some work that gives us this formula: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mfrac><mrow><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi><mo>+</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mrow><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>a</mi><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>−</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>b</mi><mo stretchy="false">)</mo><mi>q</mi><mo>+</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>a</mi><mo>−</mo><mi>c</mi><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><mrow><mi>a</mi><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></mfrac><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">
q' = \frac{a' q^2 + b' q + c'}{2aq + b} = \frac{(ab' - a' b)q + c' a - ca'}{a(2aq + b)},
</annotation></semantics></math></span> which is nice and symmetric (it is patterned a little like the cross product in the numerator) but not what I ended up going for, I think I was worried about floating-point precision but idk.</p>
</div>
<div class="Bonus">
<p>For fun we can see what the second derivative is, though we wonʼt end up using it! (I was scared we would need it at one point but that was caused by me misreading my code.)</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi><mo>+</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">
(2aq+b)q' = a' q^2 + b' q + c'
</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>a</mi><mi>t</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>+</mo><mo stretchy="false">(</mo><menclose notation="updiagonalstrike"><mrow><mn>2</mn><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi></mrow></menclose><mo>+</mo><mn>2</mn><mi>a</mi><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><menclose notation="updiagonalstrike"><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></menclose><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi>a</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><menclose notation="updiagonalstrike"><mrow><mn>2</mn><msup><mi>a</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>q</mi><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></menclose><mo>+</mo><msup><mi>b</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mi>q</mi><mo>+</mo><menclose notation="updiagonalstrike"><mrow><msup><mi>b</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></menclose><mo>+</mo><msup><mi>c</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">
(2at+b)q'' + (\cancel{2a'q} + 2aq' + \cancel{b'})q' = a'' q^2 + \cancel{2a'qq'} + b'' q + \cancel{b' q'} + c''
</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><mfrac><mrow><mo>−</mo><mn>2</mn><mi>a</mi><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mi>a</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mi>q</mi><mo>+</mo><msup><mi>c</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><mrow><mn>2</mn><mi>a</mi><mi>q</mi><mo>+</mo><mi>b</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
q'' = \frac{- 2aq'^2 + a'' q^2 + b'' q + c''}{2aq+b}
</annotation></semantics></math></span></p>
</div>
<h4 id="mystery-coefficients">Mystery coefficients</h4>
<p>In which I attempt to write out what <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span> actually are. Wish me luck.</p>
<p>We take the standard quadratic form of the tangent of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>6</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mi>q</mi><mo>+</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>3</mn></msub><mo>−</mo><mn>3</mn><msub><mi mathvariant="bold">Q</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">
\mathbf{B}'_\mathbf{Q}(q) =
3(\mathbf{Q}_1 - \mathbf{Q}_0) + 6(\mathbf{Q}_2 - 2\mathbf{Q}_1 + \mathbf{Q}_0)q + 3(\mathbf{Q}_3 - 3\mathbf{Q}_2 + 3\mathbf{Q}_1 - \mathbf{Q}_0)q^2
</annotation></semantics></math></span></p>
<p>(Notice how there is a constant term, a term multiplied by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>, and a term with <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">q^2</annotation></semantics></math></span>.)</p>
<p>We want to wrangle this cross product of that with <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{B}'_\mathbf{P}(p)</annotation></semantics></math></span> into a quadratic equation of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>q</mi><mo>+</mo><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
\mathbf{B}'_\mathbf{Q}(q) \times \mathbf{B}'_\mathbf{P}(p)
  = a(p)q^2 + b(p)q + c(p)
</annotation></semantics></math></span></p>
<p>So by distributivity, each coefficient we saw above is cross-producted with <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{B}'_\mathbf{P}(p)</annotation></semantics></math></span> to obtain our mystery coefficients: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>3</mn></msub><mo>−</mo><mn>3</mn><msub><mi mathvariant="bold">Q</mi><mn>2</mn></msub><mo>+</mo><mn>3</mn><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>b</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>6</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>2</mn></msub><mo>−</mo><mn>2</mn><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>+</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>3</mn><mo stretchy="false">(</mo><msub><mi mathvariant="bold">Q</mi><mn>1</mn></msub><mo>−</mo><msub><mi mathvariant="bold">Q</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>×</mo><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
a(p) &amp;= 3(\mathbf{Q}_3 - 3\mathbf{Q}_2 + 3\mathbf{Q}_1 - \mathbf{Q}_0) \times \mathbf{B}'_\mathbf{P}(p),\\
b(p) &amp;= 6(\mathbf{Q}_2 - 2\mathbf{Q}_1 + \mathbf{Q}_0) \times \mathbf{B}'_\mathbf{P}(p),\\
c(p) &amp;= 3(\mathbf{Q}_1 - \mathbf{Q}_0) \times \mathbf{B}'_\mathbf{P}(p).\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>You <em>could</em> expand it out more into the individual components, but it would be painful, not very insightful, and waste ink.</p>
<p>Note that this vector cross-product <em>cannot</em> be cancelled out as a common term, because the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>-vector coefficients control how the separate components of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{B}'_\mathbf{P}(p)</annotation></semantics></math></span> are mixed together to create the coefficients of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>. However, it could be divided by its norm without a problem (that is, only the direction of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msubsup><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{B}'_\mathbf{P}(p)</annotation></semantics></math></span> matters, not is magnitude – and this is by design.)</p>
<h3 id="dead-reckoning-revisited">Dead reckoning revisited</h3>
<p>Now that we have a formula for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span> in terms of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, we can just plug it in and get our whole curve.</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="bold">C</mi><mrow><mi mathvariant="bold">P</mi><mo separator="true">,</mo><mi mathvariant="bold">Q</mi></mrow></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="bold">B</mi><mi mathvariant="bold">P</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi mathvariant="bold">B</mi><mi mathvariant="bold">Q</mi></msub><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}_{\mathbf{P},\mathbf{Q}}(p) = \mathbf{B}_\mathbf{P}(p) + \mathbf{B}_\mathbf{Q}(q(p)).</annotation></semantics></math></span></p>
<p>Now for the main question: is this a Bézier curve? Nope!</p>
<p>Even if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span> was a quadratic Bézier curve, the solution <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(p)</annotation></semantics></math></span> would still be a <a href="https://en.wikipedia.org/wiki/Rational_function">rational function</a>, which is not compatible with the polynomial structure of Bézier curves.</p>
<p>That means we canʼt just stick the curve into an SVG file or similar graphics format, its true form is not natively supported by any graphics libraries. (And for good reason, because itʼs kind of a beast!)</p>
<p>However, we know a lot of information about the curve, and we can use it to reconstruct a decent approximation of its behavior, meaning all is not lost.</p>
<h4 id="computing-compound-curvature">Computing compound curvature</h4>
<p>We now know an exact formula for the idealized <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">C</mi><mrow><mi mathvariant="bold">P</mi><mo separator="true">,</mo><mi mathvariant="bold">Q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{C}_{\mathbf{P}, \mathbf{Q}}</annotation></semantics></math></span>. We can use this to get some key bits of information that will allow us to construct a good approximation to its behavior.</p>
<p>In particular, we want to know the slope at the endpoints and also the curvature at the endpoints. The curvature is the complicated part.</p>
<p>Itʼs going to get verbose very quickly, so letʼs trim down the notation a bit by leaving <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> implicit, focusing on <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t = q(p)</annotation></semantics></math></span>, and remove the extraneous parts of the Bézier notation:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">C</mi><mo>=</mo><mi mathvariant="bold">P</mi><mo>+</mo><mi mathvariant="bold">Q</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} = \mathbf{P} + \mathbf{Q}(q).</annotation></semantics></math></span></p>
<p>By construction, the slope at the endpoints is just the slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span> at the endpoints: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∥</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}' = \mathbf{P}' + \mathbf{Q}'(q)q' \parallel \mathbf{P}',</annotation></semantics></math></span> since those vectors are parallel by the construction of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(p)</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∥</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}' \parallel \mathbf{Q}'(q).</annotation></semantics></math></span></p>
<p>The curvature is a bit complicated, but we can work through it and just requires applying the formulas, starting with this formula for curvature of a parametric curve:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">C</mi><mi>κ</mi></msup><mo>=</mo><mfrac><mrow><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><msup><mi mathvariant="bold">C</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><mrow><mi mathvariant="normal">∥</mi><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi mathvariant="normal">∥</mi><mn>3</mn></msup></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}^\kappa = \frac{\mathbf{C}' \times \mathbf{C}''}{\|\mathbf{C}'\|^3}.</annotation></semantics></math></span></p>
<p>We already computed <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">\mathbf{C}'</annotation></semantics></math></span> above, so we just need to compute <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">C</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{C}''</annotation></semantics></math></span> and compute the cross product. <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi mathvariant="bold">C</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>=</mo><msup><mi mathvariant="bold">P</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}'' = \mathbf{P}'' + \mathbf{Q}''(q)q'^2 + \mathbf{Q}'(q)q''.</annotation></semantics></math></span></p>
<p>However, I promised that we wouldnʼt need the second derivative <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">q''</annotation></semantics></math></span>, so letʼs see how it cancels out in the cross product. With some distributivity we can expand it:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right left" columnspacing="0em 1em 0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><msup><mi mathvariant="bold">C</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">×</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>×</mo><msup><mi mathvariant="bold">P</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">+</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>×</mo><msup><mi mathvariant="bold">Q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">+</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><menclose notation="updiagonalstrike"><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></menclose><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">+</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><menclose notation="updiagonalstrike"><mrow><mo stretchy="false">(</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></menclose><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><msup><mi mathvariant="bold">C</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><mo stretchy="false">(</mo><msup><mi mathvariant="bold">P</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">Q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mathbf{C}' \times \mathbf{C}''
  &amp;&amp; = &amp;\ (\mathbf{P}' + \mathbf{Q}'(q)q')\\
  &amp;&amp; \times &amp;\ (\mathbf{P}'' + \mathbf{Q}''(q)q'^2 + \mathbf{Q}'(q)q'')\\\\
  &amp;&amp; = &amp;\ (\mathbf{P}' + \mathbf{Q}'(q)q') \times \mathbf{P}''\\
  &amp;&amp; + &amp;\ (\mathbf{P}' + \mathbf{Q}'(q)q') \times \mathbf{Q}''(q)q'^2\\
  &amp;&amp; + &amp;\ \cancel{(\mathbf{P}' \times \mathbf{Q}'(q))}q''\\
  &amp;&amp; + &amp;\ \cancel{(\mathbf{Q}'(q) \times \mathbf{Q}'(q))}q'q''\\\\
  &amp;&amp; = &amp;\ \mathbf{C}' \times (\mathbf{P}'' + \mathbf{Q}''(q)q'^2).\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>Obviously <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>×</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbf{Q}'(q) \times \mathbf{Q}'(q) = 0</annotation></semantics></math></span>, since those are parallel, being the same vector. But <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>×</mo><msup><mi mathvariant="bold">Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathbf{P}' \times \mathbf{Q}'(q) = 0</annotation></semantics></math></span> as well, since those are parallel by construction of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = q(p)</annotation></semantics></math></span>. That means we do not need to deal with the second derivative <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo></mrow></msup></mrow><annotation encoding="application/x-tex">q''</annotation></semantics></math></span>.</p>
<h4 id="reconstructive-surgery">Reconstructive surgery</h4>
<p>Now we can get down to business. How do we find the best Bézier curve to fill in for the much more complicated curve <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">C</mi><mrow><mi mathvariant="bold">P</mi><mo separator="true">,</mo><mi mathvariant="bold">Q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{C}_{\mathbf{P},\mathbf{Q}}</annotation></semantics></math></span> that combines the two curves <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi></mrow><annotation encoding="application/x-tex">\mathbf{P}</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span>?</p>
<p>Weʼll take six (6) pieces of data from <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">C</mi><mrow><mi mathvariant="bold">P</mi><mo separator="true">,</mo><mi mathvariant="bold">Q</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{C}_{\mathbf{P},\mathbf{Q}}</annotation></semantics></math></span>:</p>
<ol type="1">
<li>The endpoints: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">f_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f_1</annotation></semantics></math></span> (x2),</li>
<li>The tangents at the endpoints: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">d_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">d_1</annotation></semantics></math></span> (x2), and</li>
<li>The curvature at the endpoints: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\kappa_0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>κ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\kappa_1</annotation></semantics></math></span> (x2).</li>
</ol>
<p>This should be enough to pin down a Bézier curve, and indeed there is a way to find cubic Bézier curves that match these parameters.</p>
<p>We will be following the paper <a href="https://minds.wisconsin.edu/bitstream/handle/1793/58822/TR692.pdf;jsessionid=E008B26966FD35F59178ECBD7500CB56?sequence=1">High accuracy geometric Hermite interpolation</a> by Carl de Boor, Klaus Höllig, and Malcolm Sabin to answer this question. The basic sketch of the math is pretty straightforward, but the authors have done the work to come up with the right parameterizations to make it easy to compute and reason about.</p>
<p>The bad news is we end up with a quartic (degree 4) equation, to solve the system of two quadratic equations. So we see that there can be up to 4 solutions. But we can narrow them down a bunch, like if there are solutions with loops (self-intersections) we can rule them out, or other outlandish solutions with far-flung control points.</p>
<p>For example, one can take these same datapoints from a real cubic Bézier curve and reconstruct its control points from those six pieces of information. In our case, we are hoping that the curves we come across, although not technically being of that form, are very close and will still produce a similar curve to the perfect idealized solution.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<div class="Bonus">
<p>In fact, one cool thing about this implementation is that we can use it to find the closest Bézier curve <em>without a loop</em> to one <em>with a loop</em>. (And the reverse, though I have not implemented that.)</p>
<div id="delooper-demo">

</div>
</div>
<h5 id="steps-to-a-solution">Steps to a solution</h5>
<p>Basically a lot of shuffling variables around.</p>
<p>We will be solving for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\delta_0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span>, which scale the control handles along the predefined tangents, giving these Bézier control points: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><msub><mi>f</mi><mn>0</mn></msub><mo separator="true">,</mo><mtext>&nbsp;</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><msub><mi>δ</mi><mn>0</mn></msub><msub><mi>d</mi><mn>0</mn></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>b</mi><mn>3</mn></msub><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>&nbsp;</mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><msub><mi>b</mi><mn>2</mn></msub><mo>=</mo><msub><mi>b</mi><mn>3</mn></msub><mo>−</mo><msub><mi>δ</mi><mn>1</mn></msub><msub><mi>d</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
b_0 = f_0,\ &amp;\ b_1 = b_0 + \delta_0 d_0,\\
b_3 = f_1,\ &amp;\ b_2 = b_3 - \delta_1 d_1.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>Now we compute the curvature at the endpoints for this Bézier curve: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>κ</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>2</mn></msub><mo>−</mo><msub><mi>b</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>3</mn><msubsup><mi>δ</mi><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>κ</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><msub><mi>d</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>1</mn></msub><mo>−</mo><msub><mi>b</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>3</mn><msubsup><mi>δ</mi><mn>1</mn><mn>2</mn></msubsup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\kappa_0 &amp;= 2d_0 \times (b_2 - b_1)/(3\delta_0^2),\\
\kappa_1 &amp;= 2d_1 \times (b_1 - b_2)/(3\delta_1^2).\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>And with these substitutions, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>f</mi><mn>0</mn></msub><mo>−</mo><msub><mi>f</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>:</mo><mi>a</mi><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>b</mi><mn>2</mn></msub><mo>−</mo><msub><mi>b</mi><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>:</mo><mi>a</mi><mo>−</mo><msub><mi>δ</mi><mn>0</mn></msub><msub><mi>d</mi><mn>0</mn></msub><mo>−</mo><msub><mi>δ</mi><mn>1</mn></msub><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
f_0 - f_1 &amp;=: a,\\
b_2 - b_1 &amp;=: a - \delta_0 d_0 - \delta_1 d_1,\\
\end{aligned}
</annotation></semantics></math></span> we get a system of two quadratic equations for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\delta_0</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\delta_1</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>δ</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><msub><mi>κ</mi><mn>1</mn></msub><msubsup><mi>δ</mi><mn>1</mn><mn>2</mn></msubsup><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><msub><mi>δ</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><mi>a</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><msub><mi>κ</mi><mn>0</mn></msub><msubsup><mi>δ</mi><mn>0</mn><mn>2</mn></msubsup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
(d_0 \times d_1)\delta_0 = (a \times d_1) - (3/2)\kappa_1 \delta_1^2,\\
(d_0 \times d_1)\delta_1 = (d_0 \times a) - (3/2)\kappa_0 \delta_0^2.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>Itʼs easy to deal with the case when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">d_0 \times d_1 = 0</annotation></semantics></math></span> (that is, when the starting and ending tangents are parallel). For the nonzero case, we reparameterize again according to:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>δ</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>:</mo><msub><mi>ρ</mi><mn>0</mn></msub><mfrac><mrow><mi>a</mi><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub></mrow><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mfrac><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>δ</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>:</mo><msub><mi>ρ</mi><mn>1</mn></msub><mfrac><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><mi>a</mi></mrow><mrow><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\delta_0 &amp;=: \rho_0 \frac{a \times d_1}{d_0 \times d_1},\\
\delta_1 &amp;=: \rho_1 \frac{d_0 \times a}{d_0 \times d_1}.\\
\end{aligned}
</annotation></semantics></math></span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>R</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mfrac><mn>3</mn><mn>2</mn></mfrac><mfrac><mrow><msub><mi>κ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>R</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>:</mo><mo>=</mo><mfrac><mn>3</mn><mn>2</mn></mfrac><mfrac><mrow><msub><mi>κ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>d</mi><mn>0</mn></msub><mo>×</mo><msub><mi>d</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
R_0 &amp;:= \frac{3}{2}\frac{\kappa_0 (a \times d_1)}{(d_0 \times a)(d_0 \times d_1)^2},\\
R_1 &amp;:= \frac{3}{2}\frac{\kappa_1 (d_0 \times a)}{(a \times d_1)(d_0 \times d_1)^2}.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>Thus we end up with the very pretty system of quadratics: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>ρ</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><msubsup><mi>ρ</mi><mn>1</mn><mn>2</mn></msubsup><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>ρ</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>0</mn></msub><msubsup><mi>ρ</mi><mn>0</mn><mn>2</mn></msubsup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\rho_0 = 1 - R_1 \rho_1^2,\\
\rho_1 = 1 - R_0 \rho_0^2.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>We can solve for one of these variables, by substituting from the other equation, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>ρ</mi><mn>0</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>0</mn></msub><msubsup><mi>ρ</mi><mn>0</mn><mn>2</mn></msubsup><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><msub><mi>R</mi><mn>0</mn></msub><msub><mi>R</mi><mn>1</mn></msub><msubsup><mi>ρ</mi><mn>0</mn><mn>2</mn></msubsup><mo>−</mo><msubsup><mi>R</mi><mn>0</mn><mn>2</mn></msubsup><msub><mi>R</mi><mn>1</mn></msub><msubsup><mi>ρ</mi><mn>0</mn><mn>4</mn></msubsup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\rho_0
  &amp;= 1 - R_1 (1 - R_0 \rho_0^2)^2\\
  &amp;= 1 - R_1 + 2R_0R_1\rho_0^2 - R_0^2 R_1 \rho_0^4.\\
\end{aligned}
</annotation></semantics></math></span></p>
<p>This is a depressed quartic equation, with coefficients <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mtext>&nbsp;</mtext><mn>2</mn><msub><mi>R</mi><mn>0</mn></msub><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>&nbsp;</mtext><mn>0</mn><mo separator="true">,</mo><mtext>&nbsp;</mtext><mo>−</mo><msubsup><mi>R</mi><mn>0</mn><mn>2</mn></msubsup><msub><mi>R</mi><mn>1</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1 - R_1,\ -1,\ 2R_0R_1,\ 0,\ -R_0^2R_1]</annotation></semantics></math></span>.</p>
<h5 id="pruning-solutions">Pruning solutions</h5>
<p>We want solutions with <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>δ</mi><mn>1</mn></msub><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta_0, \delta_1 \ge 0</annotation></semantics></math></span> – that is, with the control handles pointing the correct way. We also want to generally minimize those variables too, otherwise there are outlandish solutions with huge coefficients (particularly ones with loops). Finally I also added a check that ensures we are getting the correct curvature out of them – for some reason I was getting solutions with flipped curvature.</p>
<div class="Bonus">
<p>Itʼs actually really pretty to see solutions with all signs of curvatures together:</p>
<div id="all-fits-demo">

</div>
</div>
<h2 id="implementation">Implementation</h2>
<p>I have an implementation in vanilla JavaScript of the algorithm described in this post.</p>
<p>Of course it needs some basic theory of vectors and polynomials and Bézier curves. For example, <code class="javascript">bsplit(points, t0)</code> returns a vector of two new Bézier curves that cover intervals <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, t_0]</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>t</mi><mn>0</mn></msub><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[t_0, 1]</annotation></semantics></math></span> of the input curve, respectively.</p>
<p>The important functions in <a href="https://github.com/MonoidMusician/blog/blob/main/assets/js/calligraphy.js"><code>calligraphy.js</code></a> are as follows:</p>
<ul>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/calligraphy.js#L464-L481"><code class="javascript">compositeI(P,Q)</code></a> computes the approximate Bézier convolution of <code>P</code> with <code>Q</code>.</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/calligraphy.js#L414-L444"><code class="javascript">PQ_CURVATURE(P,Q)(p,q=T_SOL(P,Q)(p))</code></a> computes the curvature of the exact convolution between <code>P</code> and <code>Q</code> at <code>(p,q)</code> (where <code>q</code> should be the point on <code>Q</code> corresponding to <code>p</code> on <code>P</code>, <span data-t="" data-widget="">i.e.</span> parallel).</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/calligraphy.js#L483-L490"><code class="javascript">INFLXNS(P)</code></a> computes the inflection points of <code>P</code>.</li>
</ul>
<p>And the full algorithm is put together (with visualization) in <a href="https://github.com/MonoidMusician/blog/blob/main/assets/js/minkowski.js"><code>minkowski.js</code></a>:</p>
<ul>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/minkowski.js#L185-L216"><code class="javascript">doTheThing(p1, p2)</code></a> does the thing, as it says.</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/minkowski.js#L1327-L1341"><code class="javascript">splitPathAtInflections(p2)</code></a> removes pathologies from the pen nib.</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/minkowski.js#L1264-L1267"><code class="javascript">splitBezierAtTangents(c1, getTangentsL(c2))</code></a> splits the pen path according to the points of interest of the pen nib.</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/minkowski.js#L201-L203"><code class="javascript">getTangentsL(c2)</code></a> includes both the control point tangents of the Bézier as well as the beginning-to-end tangent, to make the tangent function injective on the length of each segment.?? ??</li>
<li><a href="https://github.com/MonoidMusician/blog/blob/4147508e0dfd2e0451ba89a5e6ed5116e9628d73/assets/js/minkowski.js#L239-L303"><code class="javascript">doTheTask(c1, c2)</code></a> creates a patch or two from two Bézier curves, which will either be the “parallelogram” formed by translating them, or will include their convolution if it exists.</li>
</ul>
<h3 id="hacks">Hacks</h3>
<p>Uhhh … I allowed the control points to go backwards (<span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mn>0</mn></msub><mo>∗</mo><msub><mi>δ</mi><mn>1</mn></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\delta_0 * \delta_1 &lt; 0</annotation></semantics></math></span>) and I perturbed the tangential splits due to numeric issues. The latter could be fixed by actually remembering those splits and not trying to solve <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q(p)</annotation></semantics></math></span> there.</p>
<h2 id="symmetries">Symmetries</h2>
<p>Throughout this post, Iʼve been emphasizing “the pen nib this” and “the pen path that” for the sake of giving you a concrete image in your mind. But the reality of the underlying math is that there is no fundamental distinction between the two curves. The convolution and Minkowski sum are commutative, and do not care which curve is which.</p>
<h2 id="references">References</h2>
<p>My primary sources/inspiration:</p>
<ul>
<li>The wonderful, fabulous, extraordinary <a href="https://pomax.github.io/bezierinfo/">Primer on Bézier Curves</a> by Pomax.</li>
<li><a href="https://raphlinus.github.io/curves/2021/03/11/bezier-fitting.html">Fitting cubic Bézier curves</a>, <a href="https://raphlinus.github.io/curves/2018/12/28/bezier-arclength.html">How long is that Bézier?</a>, and other posts by the excellent Raph Levien.</li>
<li>Linked from the above, my main reference that convinced me it was possible and made my life easier (except for the hour I spent chasing down a minus sign I forgot): <a href="https://minds.wisconsin.edu/bitstream/handle/1793/58822/TR692.pdf;jsessionid=E008B26966FD35F59178ECBD7500CB56?sequence=1">High accuracy geometric Hermite interpolation</a> by Carl de Boor, Klaus Höllig, and Malcolm Sabin.</li>
</ul>
<p>Other miscellanea on Bézier curves:</p>
<ul>
<li><a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4049692">The Uniqueness of the Rational Bézier Polygon is Unique</a> by Javier Sánchez-Reyes</li>
<li><a href="https://sealedabstract.com/posts/bezier-curvature/">The problem with cubic bezier curvature</a> and <a href="https://math.stackexchange.com/questions/3833973/smoothing-asymptotic-behavior-in-the-curvature-of-a-cubic-bezier">related StackExchange post</a></li>
<li>Special cases to <a href="https://math.stackexchange.com/questions/3024630/arc-length-reparameterization-of-a-cubic-bezier-in-parts">arc length reparameterization of a cubic Bézier</a></li>
<li><a href="https://math.stackexchange.com/questions/3294/how-to-approximate-connect-two-continuous-cubic-b%C3%A9zier-curves-with-to-a-single-o#comment8479_3983">the term for the third-derivative analog of curvature for curves is “aberrancy”</a></li>
<li><a href="https://math.stackexchange.com/questions/1954845/bezier-curvature-extrema/1956264#1956264">Bézier curvature extrema</a></li>
<li>… can time-parameterization cut down on the configuration space of cubic curves too?</li>
</ul>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>It should be possible to only compute the outer segments and skip that step, but for now itʼs better to overapproximate it and optimize later.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Even though weʼre putting a lot of vector information in from the control points of the curves, the coefficients are just scalars, and in fact are even quadratic polynomials in terms of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>! Knowing that they are quadratic polynomials does not really help things at all.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>I first verified this numerically, but it makes a lot of sense if you think about it.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Note that we arenʼt doing other methods of error reduction, like <a href="https://raphlinus.github.io/curves/2021/03/11/bezier-fitting.html#signed-area">minimizing area</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
<item>
<title>Interactive Parser Explanations</title>
<pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/parser.html</guid>
<description><![CDATA[<p>I have been building this framework for explaining, analyzing, and teaching about LR(1) grammars for a couple months now. I hope to turn it into a series of interactive blog posts to explain what parsing is and some approaches we can take to it, most notably <a href="https://en.wikipedia.org/wiki/Canonical_LR_parser">LR(1)</a> parsing. Many notable parser generators like Haskellʼs <a href="https://www.haskell.org/happy/">Happy</a> and the mainstream <a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>, <a href="https://en.wikipedia.org/wiki/GNU_Bison">Bison</a>, and <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> use variants of LR(1), modified for efficiency by reducing the number of generated states.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The interactive widgets here will allow you to build and verify your intuition by clicking through examples, because I believe that once you are armed with the basic ideas and the right intuition, you can figure out the rest of details for yourself.</p>
<p>Alternatively, it can serve as a playground to test out hypotheses about grammars, see exactly where things go wrong when conflicts occur, and what to do to fix those errors.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>My real goal is to show you how intuitive LR(1) parsing can be! Thatʼs right, thereʼs nothing too advanced or magical going on, just some intuitive ideas carried to their logical conclusions. I used to be scared of parser generators, but once I was introduced to them I followed this approach to understand them for myself and I hope to share that with you.</p>
<p>As (functional) programmers, weʼre used to learning topics in terms of the appropriate datatypes and operations for the job, and thatʼs what I will go through for you here. Hint: weʼll use a lot of monoids!</p>
<pre class="purescript"><code>data ShiftReduce s r
  = Shift s
  | Reduces (NonEmptyArray r)
  | ShiftReduces s (NonEmptyArray r)

instance Semigroup (ShiftReduce s r) where
  -- We do not expect to see two shifts, so arbitrarily prefer the first one
  append (Shift s) (Shift _) = Shift s
  append (Shift s) (ShiftReduces _ rs) = ShiftReduces s rs
  append (ShiftReduces s rs) (Shift _) = ShiftReduces s rs
  append (ShiftReduces s rs) (ShiftReduces _ rs') = ShiftReduces s (rs &lt;&gt; rs')
  append (Shift s) (Reduces rs) = ShiftReduces s rs
  append (Reduces rs) (Shift s) = ShiftReduces s rs
  append (Reduces rs) (Reduces rs') = Reduces (rs &lt;&gt; rs')
  append (ShiftReduces s rs) (Reduces rs') = ShiftReduces s (rs &lt;&gt; rs')
  append (Reduces rs) (ShiftReduces s rs') = ShiftReduces s (rs &lt;&gt; rs')</code></pre>
<p>Thatʼs my big complaint: thereʼs too many numbers floating around in traditional explanations of LR(1) tables, without any indication of what they mean or how they tie together. So I have used semantic formatting to indicate what they all mean: numbered states <span class="state">0</span>, <span class="state">1</span>, <span class="state">2</span> are highlighted differently from named rules <span class="rule">0</span>, <span class="rule">1</span>, <span class="rule">2</span> and differently from number tokens <span class="terminal">0</span>, <span class="terminal">1</span>, <span class="terminal">2</span>. Hopefully the pretty colors will keep your attention!</p>
<p>All of the mechanical steps in generating LR(1) parsers will be broken down and their motivation explained. What does it mean to “close” a state? How do you know what states are next, and when are you done? Why are “reduce–reduce” conflicts bad? Stay tuned to find out!</p>
<p>Skip to <a href="#widgets">Widgets</a> below to start using! Or click this button to see them on their own:</p>
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<h2 id="blog-posts">Blog Posts</h2>
<p>Right now I donʼt have much helpful content below, but I will slowly add more posts. I am finally ready to start writing explanatory content now, after working a lot on the behind-the-scenes code to animate it.</p>
<p>EDIT: this project kind of stalled, sorry. Iʼm still thinking about parsers a lot, but not in this introductory way. You can bug or help me write more ^^</p>
<h3 id="topics">Topics</h3>
<ul>
<li><span data-t="" data-widget="">TODO</span>: <a href="https://cofree.coffee/~verity/parser_by_example.html">Using this tool by example</a></li>
<li><span data-t="" data-widget="">TODO</span>: <a href="https://cofree.coffee/~verity/parser_terminology.html">Terminology reference</a></li>
<li><span data-t="" data-widget="">WIP</span>: <a href="https://cofree.coffee/~verity/parser_basics.html">Basics: What are grammars</a> (BNF, RegExp)
<ol>
<li>Nonterminals and terminals</li>
<li>Sequencing and alternation (regexes)</li>
</ol></li>
<li><span data-t="" data-widget="">WIP</span>: <a href="https://cofree.coffee/~verity/parser_applications.html">Uses of grammars</a>:
<ol>
<li>Generators: nondeterministically generate strings in the grammar by following the rules as state transitions</li>
<li>Recognition: recognize which strings belong to the grammar and which do not</li>
<li>Syntax highlighting: cursed.</li>
<li>Parsing: find an unambiguous parse tree for inputs that belong to the grammar</li>
</ol></li>
<li><span data-t="" data-widget="">WIP</span>: <a href="https://cofree.coffee/~verity/parser_lr1.html">Basics of LR(1) Parsing</a>
<ol>
<li>States</li>
<li>State transitions</li>
<li>Closure of states</li>
<li>Lookahead</li>
</ol></li>
<li>Precedence
<ol>
<li>Refresher on operator precedence</li>
<li>Operator precedence mapped to LR(1) table parsing</li>
<li>Conflict resolution using precedence operators à la Happy.</li>
</ol></li>
<li>Grammars as datatypes
<ol>
<li>AST/CSTs as ADTs</li>
<li>Data associated with tokens</li>
<li>Finding perfect representations, <span data-t="" data-widget="">e.g.</span> no leading zeroes, if you want it to encode data exactly</li>
<li>Common practice of using grammars this way (<span data-t="" data-widget="">e.g.</span> in type theory papers)</li>
</ol></li>
</ul>
<h3 id="ideas-questions">Ideas &amp; Questions</h3>
<ul>
<li>State exploration: current state, next states, previous states</li>
<li>Emulate Happy, especially precedence operators</li>
<li>Can Happy precedence operators be explained in terms of alternative grammars? Can the conflict resolutions always be “pulled back” to a grammar that would generate the same table, or a larger table that represents the same abstract grammar? Does it require quotiented grammars to explain?</li>
<li>Generate example inputs for each state, especially to diagnose conflicts<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></li>
<li>Explain <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing</a> using a similar approach</li>
<li>Better errors!</li>
</ul>
<h2 id="widgets">Widgets</h2>
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Widget.Query" data-widget-empty="true" data-widget-datakey="default" data-widget-data-keys="grammar" data-widget-loading="true">

</div>
<h3 id="enter-a-grammar">Enter a grammar</h3>
<p>Craft a grammar out of a set of rules. Each rule consists of a nonterminal name, then a colon followed by a sequence of nonterminals and terminals. Each rule must also have a unique name, which will be used to refer to it during parsing and when displaying parse trees. If ommitted, an automatic rule name will be supplied based on the nonterminal name.</p>
<p>The top rule is controlled by the upper input boxes (LR(1) grammars often require a top rule that contains a unique terminal to terminate each input), while the lower input boxes are for adding a new rule. The nonterminals are automatically parsed out of the entered rule, which is otherwise assumed to consist of terminals.</p>
<p>Click “Use grammar” to see the current set of rules in action! It may take a few seconds, depending on the size of the grammar and how many states it produces.</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.Grammar" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<h3 id="generate-random-matching-inputs">Generate random matching inputs</h3>
<p>This will randomly generate some inputs that conform to the grammar. Click on one to send it to be tested down below!</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.Random" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<h3 id="explore-building-trees-in-the-grammar">Explore building trees in the grammar</h3>
<p>Each rule can be read as a transition: “this nonterminal may be replaced with this sequence of terminals and nonterminals”. Build a tree by following these state transitions, and when it consists of only terminals, send it off to be parsed below!</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.Explorer" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<h3 id="see-parsing-step-by-step-on-custom-input">See parsing step-by-step on custom input</h3>
<p>Text entered here (which may also be generated by other widgets below) will be parsed step-by-step, and the final parse tree displayed if the parse succeeded. (Note that the closing terminal is automatically appended, if necessary.) Check the state tables above to see what state the current input ends up in, and the valid next terminals will be highlighted for entry.</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.Input" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<h3 id="list-of-parsing-states">List of parsing states</h3>
<p>To construct the LR(1) parse table, the possible states are enumerated. Each state represents partial progress of some rules in the grammar. The center dot “•” represents the dividing line between already-parsed and about-to-be-parsed.</p>
<p>Each state starts from a few seed rules, which are then closed by adding all nonterminals that could be parsed next. Then new states are explored by advancing on terminals or nonterminals, each of which generates some new seed items. That is, if multiple rules will advance on the same (non)terminal, they will collectively form the seed items for a state. (This state may have been recorded already, in which case nothing further is done.)</p>
<p>When a full rule is parsed, it is eligible to be reduced, but this is only done when one of its lookaheads come next (highlighted in red).</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.StateTable" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<h3 id="table-of-parse-actions-for-each-state">Table of parse actions for each state</h3>
<p>Once the states are enumerated, the table of parse actions can be read off:</p>
<p>Terminals can be “shifted” onto the stack, transitioning to a new state seeded by pushing through that terminal in all applicable rules in the current state.</p>
<p>Completely parsed rules will be “reduced” when their lookahead appears, popping the values matching the rule off of the stack and replacing it with the corresponding nonterminal, which then is received by the last state not involved in the rule.</p>
<p>Nonterminals received from another state trigger “gotos” to indicate the next state.</p>
<p>Two types of conflicts may occur: if a terminal indicates both a shift and reduce actions (shift–reduce conflict) or multiple reduce actions (reduce–reduce conflict). Note that there cannot be multiple shift actions at once, so most implementations (including this one) choose to do the shift action in the case of shift–reduce conflict.</p>
<div class="widget-group">
<div data-widget="Widget.Control" data-widget-datakey="main">

</div>
<div class="widget" data-widget="Parser.ParseTable" data-widget-datakey="default" data-widget-loading="true">

</div>
</div>
<div data-widget="Widget.Control" data-widget-datakey="main" data-widget-parent="#TOC">

</div>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Specifically LALR(1) is the most common alternative, and it cuts down on states by merging ones that are the same except for their lookaheads. We will not focus on any of those details in this series, most likely.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Have you ever had to debug a Happy grammar by opening up the <a href="https://www.haskell.org/happy/doc/html/sec-invoking.html"><code>.info</code></a> file? Itʼs overwhelming!<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>currently it only generates example inputs for nonterminals/productions<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
<item>
<title>Eudoxus Real Numbers as Slopes of Pixelated Graphs</title>
<pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
<guid>https://cofree.coffee/~verity/Eudoxus.html</guid>
<description><![CDATA[<p>If you have a little background in classical constructions of the real numbers, you might have noticed that all of the usual constructions start with the rational numbers as a base, and then build up to real numbers. For example, Cauchy real numbers are constructed as sequences <em>of rational numbers</em> satisfying the Cauchy condition on the usual rational metric. Dedekind real numbers are constructed as sets <em>of rational numbers</em> satisfying the conditions to make them Dedekind cuts with the usual ordering.</p>
<p>This is a post on constructing real numbers <em>without</em> constructing rational numbers. Along the way the rationals will sort of be constructed, or at least heavily implied, but they donʼt directly figure into the definition! Instead all we need is functions from integers to integers. </p>
<p>The construction weʼll be talking about is my favorite esoteric construction of real numbers: the <em><a href="https://ncatlab.org/nlab/show/Eudoxus+real+number">Eudoxus real numbers</a></em>.</p>
<img src="https://cofree.coffee/~verity/./rendered/c85c71d5af10f6359e4a7617d9ec0dd4626eca31.png" style="width: 100%">
<p>I want to explore <em>why</em> this definition works, not merely recite its definition and properties. So letʼs go on a journey together through various properties of linear and almost linear functions, and learn how to leverage “wrong” definitions of slope to create the real numbers!</p>
<div class="Note">
<p><em>If you donʼt have any background in real analysis or constructions of the real numbers, thatʼs okay. Bring along your intuitions nonetheless, they will aid you greatly! We will go over the necessary details as we get to them, although you may miss some of the depth of the discussion when I reference those other things. Just know that thereʼs a lot of strange and marvelous things going on that make constructing the real numbers an essential part of mathematics. Are these marvelous properties of the real numbers all coincidences? Surely not</em> 😉.</p>
</div>
<h2 id="what-makes-a-good-approximation">What makes a good approximation?</h2>
<p>Like all constructions of fundamental objects, we need to begin with our existing intuition about what real numbers are in order to construct them out of more basic building blocks. Just like the integers are built from natural numbers, and rational numbers are built from integers, real numbers need to be constructed from natural numbers, integers, and/or rationals. In the case of real numbers, we will need two ingredients: approximations, and a lot of them – infinitely many, in fact.</p>
<div class="Key_Idea">
<p>The key property of approximations is that they need to be <em>easier to grasp</em> than the thing we are approximating, otherwise it doesnʼt buy us any leverage! In our circumstance in particular, each individual approximation should contain a <em>finite amount of data</em>, and then we stitch together an <em>infinite number of approximations</em> to represent the complicated object we are constructing: a real number.</p>
<div class="Details">
<p>A convenient way to say that something has a finite amount of data is to say it is countable. In programmer terms, we could say we want it to be serializable into a string – itʼs equivalent. Why? Well each natural number or string has a finite amount of data, it is easy to understand or describe all at once. So if some set we are studying is countable/serializable, meaning it can be understood as if it was a set of natural numbers, then it can serve as an approximation for our purposes.</p>
</div>
</div>
<p>Thereʼs much more to say about this kind of process, indeed I hope to write a whole nother blog post about it, but for now know that there are two main questions to ask:</p>
<ol type="1">
<li>When are approximations consistent enough so they ought to represent <em>a thing</em> (<span data-t="" data-widget="">e.g.</span> “when does a sequence of rationals converge?”), and</li>
<li>When do two approximations approximate the <em>same</em> thing (<span data-t="" data-widget="">e.g.</span> “when do two convergent sequences converge to the same point?”). </li>
</ol>
<div class="Example">
<p>For example, letʼs think about approximation generators, functions that generate approximations by taking in an error bound and returning a rational number that lies within that error bound of the real number we are trying to approximate.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Because we can ask for smaller and smaller error bounds, we in fact get an infinite number of approximations that probe closer and closer to the real number. This is good: when approximating an irrational number, no single rational approximation will suffice to capture it! But not all functions will be well-behaved approximation generators, and even of those that are, there will be many ways of approximating the same number. Thatʼs why we ask those two questions: when do the approximations work, and when do they agree with each other.</p>
</div>
<p>Answering these two questions will let us invent real numbers. However, the process to get there wonʼt quite be <em>linear</em>: the notion of approximation will not be as clear as it was in the example above!</p>
<h2 id="intuition-what-is-slope">Intuition: What is slope?</h2>
<p>Letʼs dive in!</p>
<p>The idea of Eudoxus real numbers is that they represent a real number indirectly, via a functionʼs slope. We will cover <em>why</em> this works later, but first letʼs agree on <em>what slope is</em> so we can proceed with the construction and then analyze its properties that make it all work.</p>
<h3 id="step-1-what-functions-have-slope-for-sure">Step 1: What functions have slope for sure?</h3>
<h4 id="linear-functions">Linear functions</h4>
<p>Letʼs say we have a function that takes in numbers and outputs numbers. (We donʼt need to be formal about what kind of numbers yet.)</p>
<p>What <strong>definitely</strong> has a slope? Well our favorite function from school mathematics does: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = m*x + b</annotation></semantics></math></span>. Weʼve memorized that this has slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span>!</p>
<div class="Details">
<p>Why do we say it has slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span>? What is slope? Well, weʼve also memorized that slope is “Rise Over Run”. If we take two points at <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span>, the distance we <strong>run</strong> from the first to the second point is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_2 - x_1</annotation></semantics></math></span>, and the distance we had to <strong>rise</strong> to keep up with the function is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_2) - f(x_1)</annotation></semantics></math></span>. Slope as “rise over run” is therefore <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{f(x_2) - f(x_1)}{x_2 - x_1}.</annotation></semantics></math></span></p>
<p>The beautiful thing about <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = m*x + b</annotation></semantics></math></span> is that functions of this form have <em>constant slope</em>, no matter what <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span> are! <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><menclose notation="updiagonalstrike"><mrow><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></menclose></mrow><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>m</mi><mo>∗</mo><menclose notation="updiagonalstrike"><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></menclose></mrow><menclose notation="updiagonalstrike"><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></menclose></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>m</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\frac{f(x_2) - f(x_1)}{x_2 - x_1} &amp;= \frac{(m*x_2 + b) - (m*x_1 + b)}{x_2 - x_1} \\&amp;= \frac{(m*x_2 - m*x_1) + \cancel{(b - b)}}{x_2 - x_1} \\&amp;= \frac{m*\cancel{(x_2 - x_1)}}{\cancel{x_2 - x_1}} \\&amp;= m.\end{align*}</annotation></semantics></math></span></p>
<p>The inputs <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span> disappear, meaning it traces out a line with a constant slope – itʼs why we call it a linear function. So weʼre pretty happy saying that this function has slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span>. Tada! 🎉</p>
</div>
<h4 id="what-slopes-does-this-give-us">What slopes does this give us?</h4>
<p>This is where we have to ask what kind of numbers we are using, because that determines what <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> can be. If the function takes in real numbers and outputs real numbers, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> can surely be any real number too. But tough luck – we canʼt use that to <em>construct</em> real numbers, no circular definitions allowed!</p>
<p>Maybe <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> can be any rational number. Thatʼs fine – slope works in the same way. But we run into another roadblock: the function still only has one well-defined slope, and itʼs stuck being a rational number. Thereʼs no magic of infinity happening.</p>
<p>What if we say that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> is an integer function? Here we have to be careful: integer division isnʼt necessarily well-defined, <strong>but</strong> if we know <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> is an integer, then it happens to work out in this case: the denominator will always evenly divide the numerator, and out pops <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span>. This seems like an even worse situation, getting stuck with integers! But wait …</p>
<p>We need a little wiggle room. Having a constant slope is too restrictive! Can we loosen up and find something that is still like slope, but only approximately?</p>
<h3 id="step-2-graphing-calculators-approximate-slope">Step 2: Graphing calculators approximate slope</h3>
<p>Having hit these roadblocks, we need some inspiration. Letʼs revisit the idea of integer functions but in a new way.</p>
<p>Hereʼs the thing: consider a graphing calculator, or a graphing app on a computer. What happens when we ask it to graph <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>π</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = (1/\pi) * x</annotation></semantics></math></span>? (Pick your favorite irrational-but-<a href="https://en.wikipedia.org/wiki/Computable_number">computable</a> real number there.)</p>
<p>It does some math, and shows us a line on a screen … but wait, that line isnʼt a perfect mathematical function from real numbers to real numbers, itʼs a pixelated entity: <em>itʼs an <strong>integer</strong> function that approximates the <strong>real</strong> function</em>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<img src="https://cofree.coffee/~verity/./rendered/c590d03da6205ad1ad69aa978f1c470e37e017e9.png" style="width: 100%">
<h4 id="sampling-rational-slope">Sampling rational slope</h4>
<p>What happens as we keep scrolling the screen? We could keep sampling snapshots of the screen at each moment, and see how they vary.</p>
<p>If we had picked an integer slope, every snapshot would appear to have the same slope. For a slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span>, there is never any change. For a slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>, it steadily moves up pixel by pixel. For a slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span>, it skips a pixel as it goes. Et cetera. This isnʼt so interesting, yet!</p>
<img src="https://cofree.coffee/~verity/./rendered/cdc3969580b332e35826231008f5078c0fa4c9ca.png" style="width: 100%">
<p>But if we had picked a rational slope, we start to see something interesting happen: It doesnʼt always step by the same amount, sometimes it jumps more than it does other times.</p>
<p>For instance, a slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">1/7</annotation></semantics></math></span> would only jump up a single pixel every <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn></mrow><annotation encoding="application/x-tex">7</annotation></semantics></math></span> pixels. A slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">4/3</annotation></semantics></math></span> would jump up <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span> pixels one time, then jump up a single pixel twice more, making visible groups of three.</p>
<img src="https://cofree.coffee/~verity/./rendered/46cf2bd1ee25dd6c848efaacc35d325cf01e946b.png" style="width: 100%">
<p>More complicated fractions will look more complicated and repeat over longer distances. Can you figure out what the third line graphed in this figure is? (Hint: how long does it take to repeat?)</p>
<h4 id="sampling-irrational-slope">Sampling irrational slope</h4>
<p>However, this same phenomenon occurs for irrational slopes too: how do we tell the difference now??</p>
<p>The key is not how the jumps repeat in individual snapshots, but how they repeat across the whole domain of the function.</p>
<p>Do the snapshots recur in a nice pattern? If so, that must be graphing a line with rational slope! They will recur when the window has shifted by the denominator of the slope.</p>
<div class="Key_Idea">
<p><em>If the snapshots recur irregularly, without fitting a nice pattern, it is graphing an irrational number.</em></p>
</div>
<p>(Since there are a finite number of snapshots that will be generated for a particular line, they must recur – thatʼs not the point. The point is whether they recur on a fixed schedule.)</p>
<p>This is where we cross over from computation to mathematics: We canʼt hope to decide whether this is the case from a finite number of snapshots! Instead we leave it to the realm of mathematical proof to definitely establish whether a slope is rational or irrational. (We might not know!)</p>
<h3 id="step-3-what-weirder-functions-might-still-have-slope">Step 3: What weirder functions might still have slope?</h3>
<p>Okay, we are ready to take the knowledge we learned from graphing calculators and translate it back into mathematics.</p>
<p>We agreed that linear functions of all types have slope, but only linear functions using real numbers contained enough data to represent real numbers. However, we saw that calculators approximate real functions with integer functions – this is our hope of salvation, if we can connect the two ideas.</p>
<p>What, then, will tell us whether some <strong>integer</strong> function approximates a <strong>real <em>linear</em></strong> function?</p>
<h4 id="integer-functions-with-rational-slope">Integer functions with rational slope</h4>
<p>We said that integer-function approximations to lines with rational slopes had a key property: they recur in a consistent pattern!</p>
<p>If we call the period of recurrence <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, this property is that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">f(x + p) = f(x) + d</annotation></semantics></math></span>, for some <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span>.</p>
<p>What is this mysterious <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span> though? Itʼs the <strong>rise</strong> for the <strong>run</strong> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>. Weʼre saying that the function repeats every time we shift by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> steps of the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span>-axis, but it has shifted by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span> in the <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span>-axis in the meantime.</p>
<p>Thatʼs right, weʼve circled back to good olʼ slope, but in a new way: instead of saying that we want the function to be linear by having rise over run being constant for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1, x_2</annotation></semantics></math></span> we choose, we just want it to be constant when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_2 - x_1</annotation></semantics></math></span> is a known period.</p>
<p>This is much less restrictive: in particular, it lets us get rational slopes back out of integer functions! If we define the slope to be <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">d/p</annotation></semantics></math></span>, we see that for integer approximations it matches the slope of the original rational linear function, which we said would recur with period of the denominator, and of course it must travel vertically by the numerator in that time.</p>
<img src="https://cofree.coffee/~verity/./rendered/0856e015b4b1fb39d0a8fb214392f215999e4889.png" style="width: 100%">
<p>With how they wave around, these two functions donʼt look linear anymore, but they do follow a nice recurrence. Their shapes keep repeating every <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span> pixels, while they climb or fall by half that each time. That is, they have slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">+1/2</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">-1/2</annotation></semantics></math></span> in our new system, even though they are not linear.</p>
<h4 id="irrational-slopes">Irrational “slopes”</h4>
<div class="Error">
<p>We hit a roadblock with irrational slopes, though. If we donʼt have a period to work with, how can we get our hands on a slope from an integer function??</p>
</div>
<p>The answer is … [drumroll] … <strong>we donʼt!!!!</strong></p>
<h3 id="step-4-maybe-we-donʼt-need-slopes">Step 4: Maybe we donʼt need slopes</h3>
<blockquote>
<p>Huh?!?! 🤨😧😱</p>
</blockquote>
<p>What. Donʼt give me that look. 😄😌😇</p>
<p>Look here: we said linear functions were boooring. Linear functions were just their slope! pluuus a second term that merely shifts it vertically, as if that matters. Yawn 😴😪.</p>
<p>However, now weʼre going to use this correspondence as leverage to do something <em>truly</em> exciting: represent slopes <strong>as the functions weʼre given!</strong></p>
<p>We donʼt need an independent notion of slope if we can isolate the properties that <em>arenʼt</em> slope in order to distill the functions down into their slopiest essence. 🍾✨</p>
<h4 id="whatʼs-not-slope-in-fact">Whatʼs <em>not</em> slope, in fact?</h4>
<p>As we just said, shifting by a constant amount vertically will not impact slope. However, we can do infinitely better than this.</p>
<p>Recall that weʼre looking at integer functions through their whole domain, not just at a single slice anymore.</p>
<p>Say the calculator made an error and calculated a pixel incorrectly. (The horror! Quick – letʼs blame it on cosmic radiation.)</p>
<p>Should this <em>single error</em> affect the slope? Nope! Itʼll quickly get washed away in the <em>infinite other data</em> that informs us what the slope is.</p>
<p>Should another error affect the slope? Nahhh. Should any finite amount of errors affect the slope? Not even!</p>
<p>Thus we can say that shifting vertically doesnʼt influence the slope and any finite number of errors wonʼt influence it either.</p>
<p>Putting these together, we can wrap them up as a single property, and with a little extra sprinkle on top: <em>any two functions that differ by a <strong>bounded amount</strong> represent the same slope!</em><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<img src="https://cofree.coffee/~verity/./rendered/0d29dca7daf441563080f9827c9f469f8ceb7b8f.png" style="width: 100%">
<h4 id="what-is-slope-really">What <em>is</em> slope, really?</h4>
<p>Finally we get to identify what slope actually is. Took us long enough!</p>
<div class="Key_Idea">
<p>Hereʼs the key property: we want to ask that the quantity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_f(x_1, x_2) = f(x_1) + f(x_2) - f(x_1 + x_2)</annotation></semantics></math></span> is <em>bounded</em> for the integer functions we are considering.</p>
<p>The <a href="https://ncatlab.org/nlab/show/Eudoxus+real+number">nLab</a> calls this property “almost linear”. Letʼs also call <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_f(x_1, x_2)</annotation></semantics></math></span> the “wiggle” of the function <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> between <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span>.</p>
</div>
<p>As a first check, letʼs see that this happens for actually linear functions <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo>∗</mo><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(x) = m*x + b</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mi>m</mi><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mn>2</mn><mo>∗</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><menclose notation="updiagonalstrike"><mrow><mi>m</mi><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></menclose><mo>+</mo><menclose notation="updiagonalstrike"><mn>2</mn></menclose><mo>∗</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><menclose notation="updiagonalstrike"><mrow><mi>m</mi><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></menclose><mo>+</mo><menclose notation="updiagonalstrike"><mi>b</mi></menclose><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mi>b</mi><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}&amp;\ f(x_1) + f(x_2) - f(x_1 + x_2) \\=&amp;\ (m*x_1 + b) + (m*x_2 + b) - f(x_1 + x_2) \\=&amp;\ (m*(x_1+x_2) + 2*b) - f(x_1 + x_2) \\=&amp;\ (\cancel{m*(x_1+x_2)} + \cancel{2}*b) - (\cancel{m*(x_1 + x_2)} + \cancel{b}) \\=&amp;\ b.\end{align*}</annotation></semantics></math></span></p>
<p>Whoa, itʼs not only bounded, itʼs actually constant! And the constant is the vertical shift we said we didnʼt care about, interesting.</p>
<p>What about for integer approximations of linear functions?</p>
<h5 id="redux-linearly-periodic-approximations">Redux: Linearly-periodic approximations</h5>
<p>First we can look at the linearly-periodic approximations of rational linear functions: saying the period is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, we mean that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">f(x + p) = f(x) + d</annotation></semantics></math></span> for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span>. So as one example, if we pick <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">x_2 = p</annotation></semantics></math></span>, then for any <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span>, the quantity weʼre looking at <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1) + f(p) - f(x_1 + p)</annotation></semantics></math></span> is just <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p) = f(0)</annotation></semantics></math></span>. Constant, thus bounded. (Note how nicely this matches up with the perfectly linear case, since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(0) = b</annotation></semantics></math></span> then!)</p>
<p>We can play this game again: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>2</mn><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1) + f(2*p) - f(x_1 + 2*p) = f(2*p) = f(0)</annotation></semantics></math></span> as well.</p>
<p>But what about other values of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span> that donʼt fit into the period? The key is that it <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1) + f(x_2) - f(x_1 + x_2)</annotation></semantics></math></span> is not just linearly-periodic, but actually periodic in both <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span> now, having the same period <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> of course:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>&nbsp;</mtext><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}&amp;\ f(x_1) + f(x_2 + p) - f(x_1 + (x_2 + p)) \\=&amp;\ f(x_1) + (f(x_2) + d) - (f(x_1 + x_2) + d) \\=&amp;\ f(x_1) + f(x_2) - f(x_1 + x_2).\end{align*}</annotation></semantics></math></span></p>
<p>The <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span> cancels out from the two terms that changed.</p>
<p>The upshot is that we donʼt need to worry about <em>all</em> values of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span>, just one period worth of it, from <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span> to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>. Explicitly, the wiggle of the function is bounded by the quantity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\max(|f(1)|, |f(2)|, \dots, |f(p)|).</annotation></semantics></math></span></p>
<h5 id="irrational-approximations">Irrational approximations</h5>
<p>We didnʼt identify a property for abstractly looking at approximations of linear functions with irrational slopes, like we did with approximations of rational slopes. However, if we look at a typical approximation function, we know that, with whatever integer rounding it is using, its integer value will be within <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\pm 1</annotation></semantics></math></span> of the actual real value at any given point. So when you look at the three terms <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1)</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_2)</annotation></semantics></math></span>, and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x_1 + x_2)</annotation></semantics></math></span>, it is clear that the wiggle will be within <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">\pm 3</annotation></semantics></math></span> of the value of the wiggle of the underlying linear function, which we know is constantly <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>. So the wiggle is clearly bounded.</p>
<h2 id="just-tell-me-definition">Just tell me: Definition</h2>
<p>Having satisfied our curiosity that we have identified the necessary ingredients, letʼs finally define the actual mathematical object and the operations on it.</p>
<p>The <strong>Eudoxus real numbers</strong> are <strong>almost linear functions</strong> but where two functions are considered the same when they have a <strong>bounded difference</strong>.</p>
<ul>
<li><strong>Almost linear functions</strong> have bounded wiggle, which is our name for the quantity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_f(x_1, x_2) = f(x_1) + f(x_2) - f(x_1 + x_2)</annotation></semantics></math></span>. This property should make it possible to say this function has a slope!</li>
<li><strong>Bounded difference</strong> just means that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x) - g(x)</annotation></semantics></math></span> is bounded. This property eliminates what data each function carries that is extraneous to our goal of defining slopes.</li>
</ul>
<h3 id="arithmetic">Arithmetic</h3>
<h4 id="addition">Addition</h4>
<p>We can add slopes in the obvious way, by adding the functions together (pointwise!): <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f+g)(x) = f(x) + g(x)</annotation></semantics></math></span>. And we can negate pointwise <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-f)(x) = -f(x)</annotation></semantics></math></span>, and the zero for this is of course the constantly zero function: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0(x) = 0</annotation></semantics></math></span>. For example, we can add slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">1/6</annotation></semantics></math></span> to slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">-1/2</annotation></semantics></math></span> to get slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">-1/3</annotation></semantics></math></span>:</p>
<img src="https://cofree.coffee/~verity/./rendered/9df55eece203e884d7c6c32255a0cf47251c7378.png" style="width: 100%">
<p>Huh, that middle line doesnʼt look like the graph of the line with slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">-1/3</annotation></semantics></math></span>! Itʼs very flakey, like it almost canʼt decide whether it wants to go up or down. Still, it looks like it does have the right trend overall, a general slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">-1/3</annotation></semantics></math></span>, and we will prove this later: addition works out just fine, within the bounded wiggle we expect!</p>
<h4 id="multiplication">Multiplication</h4>
<p>Now we get to my favorite part: how to multiply slopes.</p>
<p>Multiplying the functions pointwise is the wrong move: that would produce something like quadratic functions, or worse.</p>
<img src="https://cofree.coffee/~verity/./rendered/1559333778e9d0a1f9f803ee832780fc33544888.png" style="width: 100%">
<p>That is a sad looking parabola indeed ☹️.</p>
<p>Hmm … oh wait! What about <em>composing</em> functions?</p>
<p>If you compose two functions, you multiply their slopes! So we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∗</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f*g)(x) = f(g(x))</annotation></semantics></math></span>. This suggests that the identity function acts as the identity for this multiplication, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">1(x) = x</annotation></semantics></math></span> (of course it has slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>!).</p>
<img src="https://cofree.coffee/~verity/./rendered/6b2c5cc5731e137639bd476e522c8f2b03df0fa0.png" style="width: 100%">
<h3 id="ordering">Ordering</h3>
<p>The goal is to come up with an ordering on almost-linear functions that is consistent with the arithmetic and the equivalence relation. So we can take a shortcut: we only need to define what it means to be positive, then <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>&gt;</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f &gt; g</annotation></semantics></math></span> is defined by the difference <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>−</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f - g</annotation></semantics></math></span> being positive.</p>
<p>Before we ask what it means to positive or negative, what does it mean to be zero? We said that zero was the constant function – but wait, itʼs actually the <em>equivalence class</em> of the constant function, which consists of all functions that are bounded (since that means they have bounded difference from zero).</p>
<p>Positive and negative, then, are going to be unbounded functions. How do we distinguish them?</p>
<p>The basic idea is that positive will grow unboundedly <em>positive</em> to the right and negative will grow unboundedly <em>negative</em> to the right. In formal terms, we say that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> is positive if, upon picking some arbitrary height <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span>, it is eventually always above <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span> as it goes towards the right: <span data-t="" data-widget="">i.e.</span> there is some <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span> such that for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">m &gt; N</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f(m) &gt; C</annotation></semantics></math></span>.</p>
<p>There are some properties to verify.</p>
<p>First off, why is it sufficient to just consider the behavior of the function to the right (<span data-t="" data-widget="">i.e.</span> for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">m &gt; 0</annotation></semantics></math></span>)? We would need to know that growing unboundedly positive to the right is the same as growing unboundedly negative to the left. This conforms with our intuition of how almost linear functions have slope, but it requires a proof.</p>
<p>The other properties of how the ordering interacts with arithmetic are straightforward, however:</p>
<ol type="1">
<li>Negation works as expected: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>f</mi><mo>&gt;</mo><mo>−</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">-f &gt; -g</annotation></semantics></math></span> holds exactly when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>&gt;</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g &gt; f</annotation></semantics></math></span> holds, since the first means <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mi>f</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-f) - (-g)</annotation></semantics></math></span> is positive, and the second means <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g - f</annotation></semantics></math></span> is positive.</li>
<li>Addition works as expected: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>g</mi><mn>1</mn></msub><mo>+</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1 + f_2 &gt; g_1 + g_2</annotation></semantics></math></span> if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f_1 &gt; g_1</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_2 &gt; g_2</annotation></semantics></math></span>, since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo>+</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo>−</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo>−</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f_1 + f_2) - (g_1 + g_2) = (f_1 - g_1) + (f_2 - g_2)</annotation></semantics></math></span>, and obviously the sum of two positive functions is still positive.</li>
<li>Multiplying by a positive factor works as expected: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∗</mo><mi>h</mi><mo>&gt;</mo><mi>g</mi><mo>∗</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">f * h &gt; g * h</annotation></semantics></math></span> if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>&gt;</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f &gt; g</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h &gt; 0</annotation></semantics></math></span> holds by distributivity <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∗</mo><mi>h</mi><mo>−</mo><mi>g</mi><mo>∗</mo><mi>h</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo>−</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">f * h - g * h = (f - g) * h</annotation></semantics></math></span> and multiplication of positives is obvious too.</li>
</ol>
<h2 id="does-it-work-properties">Does it work? Properties</h2>
<h3 id="slope">Slope</h3>
<p>The million dollar question: does it really have a slope?</p>
<p>To determine this, weʼll basically use Cauchy real numbers. Recall that those are equivalence classes of sequences of rational numbers. Can we construct a Cauchy real number from <em>our</em> definition of real numbers, to capture the slope of our almost-linear functions?</p>
<p>Recall our definition of slope as rise over run. We should be able to pick two arbitrary points and compute their slope, right? It will be a rational number, since weʼre dealing with integer functions. And then presumably as those points get further and further away from each other, the approximation will get better and better.</p>
<p>We might as well pick <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span> as our basepoint and move out to positive numbers, like so: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>0</mn></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} \frac{f(n) - f(0)}{n - 0}.</annotation></semantics></math></span></p>
<p>Except notice that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(0)</annotation></semantics></math></span> is a constant in the numerator, and since the denominator grows to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span>, some basic properties of limits tell us that it is irrelevant, so we can instead use this limit: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} f(n)/n.</annotation></semantics></math></span></p>
<p>In fact this realization is the key step that informs us that the limit is well-defined on equivalence classes: any bounded difference between two functions will not affect this limit. So we could also assume that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">f(0) = 0</annotation></semantics></math></span> without loss of generality, since that will be in the same equivalence class.</p>
<p>Now we just need to show that it satisfies the Cauchy condition, assuming <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> is almost linear:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>N</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>&gt;</mo><mi>N</mi><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mrow><mo fence="true">∣</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>m</mi><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>ϵ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\forall \epsilon &gt; 0, \exists N &gt; 0, \forall n, m &gt; N, \\ \left|f(n)/n - f(m)/m\right| &lt; \epsilon.</annotation></semantics></math></span></p>
<p>We will go through what this means including a proof later, since it requires more machinery.</p>
<p>But weʼve half-answered our question already: we have done what we can to isolate slope from the other data the functions carry, and it just remains to confirm that we can in fact define slope from it.</p>
<h3 id="horizontal-shifting">Horizontal shifting</h3>
<p>Thereʼs another obvious property that we need slopes to be invariant under:</p>
<p>Weʼve covered vertical shifting, but what about horizontal shifting? Does bounded (vertical) differences suffice to cover bounded (horizontal) differences? Obviously not for arbitrary functions, but hopefully for the almost-linear functions we are covering?</p>
<p>It turns out yes, being almost-linear is exactly what it means that horizontal shifts of the function require just bounded vertical shifts to compensate: we need <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) - f(n+c)</annotation></semantics></math></span> bounded (for fixed <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>), but being almost linear means that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(c) + f(n) - f(n+c)</annotation></semantics></math></span> is bounded which is different just by the constant <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(c)</annotation></semantics></math></span>.</p>
<p>For example, these two functions with slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mi mathvariant="normal">/</mi><mn>7</mn></mrow><annotation encoding="application/x-tex">3/7</annotation></semantics></math></span> are shifted by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span> relative to each other, so their different forms a pretty checkerboard-like pattern, which is clearly bounded, only taking the values <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span> as the functions grow in close proportion.</p>
<img src="https://cofree.coffee/~verity/./rendered/b9c12774439ae497d591674f8665287a95bccaf4.png" style="width: 100%">
<h3 id="monotonicity">Monotonicity</h3>
<p>Thereʼs one property we have not mentioned yet: monotonicity.</p>
<p>All of the linear approximation functions we would come up with are monotonic: either for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \le n</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(m) \le f(n)</annotation></semantics></math></span> (weakly monotonically increasing), or for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \le n</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>≥</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(m) \ge f(m)</annotation></semantics></math></span> (weakly monotonically decreasing). But weʼve never mentioned this. Why not include it as a property we care about having or respecting?</p>
<p>The first clue is what we saw above with addition: when we added two monotonic representative functions (with slope <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">1/6</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">-1/2</annotation></semantics></math></span>), the result wasnʼt monotonic anymore, it went up and down and up and down, although in a nicely repeating pattern. So our naïve definition of addition did not preserve monotonicity.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>However, you can in fact take any representative function and make it monotonic by only a bounded difference – but with one big catch: you have to know up front whether the slope is zero, positive, or negative,— and that property is <a href="https://en.wikipedia.org/wiki/Decision_problem">undecidable</a>.</p>
<p>So it just seems more fussy and complicated to require the representative functions be monotonic, even though it could be done without resulting in a different theory.</p>
<h2 id="proofs">Proofs</h2>
<h3 id="addition-1">Addition</h3>
<p>All of the lemmas involving addition are straightforward, so I wonʼt go through them here, but feel free to ask me if you have questions!</p>
<h3 id="multiplication-distributes-over-addition">Multiplication distributes over addition</h3>
<p>This is my <strong>favorite</strong> theorem, and the reason I like this construction so much.</p>
<p>Distributivity is what lets you pull out common factors, like so: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>h</mi><mo>=</mo><mi>f</mi><mo>∗</mo><mi>h</mi><mo>+</mo><mi>g</mi><mo>∗</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">(f+g)*h = f*h + g*h</annotation></semantics></math></span>.</p>
<p>Watch what happens when we use our definitions of these operators (recall that multiplication is function composition):</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>h</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">((f+g)*h)(x) = (f+g)(h(x)) = f(h(x)) + g(h(x)).</annotation></semantics></math></span></p>
<p>Thatʼs right, it falls out for free based on how we defined multiplication and addition, just because of how functions work! Isnʼt that so cool?</p>
<p>But … thereʼs a catch.</p>
<p>Proving that multiplication <em>on the left</em> distributes over addition is not so straightforward: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>f</mi><mo>+</mo><mi>g</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mtext>&nbsp;</mtext><mo stretchy="false">?</mo><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">(h*(f+g))(x) = h((f+g)(x)) = h(f(x) + g(x)) =\ ??</annotation></semantics></math></span></p>
<p>There doesnʼt seem to be a direct way to attack this. However, once we prove that <a href="#multiplication-is-commutative">multiplication is commutative</a>, it doesnʼt matter anymore. (In fact, I suspect that proving left-distributivity directly requires similar arguments to the commutativity of multiplication anyways.)</p>
<h3 id="multiplication-is-well-defined">Multiplication is well-defined</h3>
<p>Thereʼs two aspects to show that the multiplication is well-defined: since weʼre dealing with subquotients, we need to show that the result satisfies the necessary property, and also that it respects the quotienting relation.</p>
<h4 id="multiplication-is-almost-linear">Multiplication is almost-linear</h4>
<p>I think this first aspect requires one of the more tricky proofs: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∗</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f*g</annotation></semantics></math></span> is almost linear if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span> are. (Remember we defined multiplication as the composition of those functions, not pointwise multiplication!)</p>
<p>Assume <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(m+n) - f(m) - f(n)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(m+n) - g(m) - g(n)</annotation></semantics></math></span> are bounded, then show that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(m+n)) - f(g(m)) - f(g(n))</annotation></semantics></math></span> is bounded as well.</p>
<p>For the set-up, we observe that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a(m,n)+e(m,n)) - f(a(m,n)) - f(e(m,n))</annotation></semantics></math></span> is bounded (by assumption), and we choose strategic functions <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(m)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(n)</annotation></semantics></math></span>.</p>
<p>In particular, if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(m,n)</annotation></semantics></math></span> is bounded by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span>, then <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(e(m,n))</annotation></semantics></math></span> is clearly also bounded, thus so is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a(m,n)+e(m,n)) - f(a(m,n))</annotation></semantics></math></span> – namely, by the maximum of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> on the interval <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-b,b]</annotation></semantics></math></span>.</p>
<p>What quantity do we know is bounded? Letʼs choose <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(m,n) = g(m)+g(n)-g(m+n)</annotation></semantics></math></span>.</p>
<p>For the other function we choose <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(m,n) = g(m+n)</annotation></semantics></math></span>, which makes their sum <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a(m,n)+e(m,n) = g(m)+g(n)</annotation></semantics></math></span>.</p>
<p>Plugging these in, we see that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(m)+g(n)) - f(g(m+n))</annotation></semantics></math></span> is bounded. But <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(m)+g(n)) - f(g(m)) - f(g(n))</annotation></semantics></math></span> is also bounded by the first assumption. Thus their difference <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(m+n)) - f(g(m)) - f(g(n))</annotation></semantics></math></span> is bounded. <a href="https://en.wikipedia.org/wiki/Q.E.D.">Q.E.D.</a></p>
<h4 id="multiplication-preserves-bounded-differences">Multiplication preserves bounded-differences</h4>
<p>We also need that if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1 \sim f_2</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_1 \sim g_2</annotation></semantics></math></span> then <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>g</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>f</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f_1*g_1 \sim f_2*g_2</annotation></semantics></math></span>. We can decompose this into two steps, varying one side at a time: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>f</mi><mn>2</mn></msub><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msub><mi>f</mi><mn>1</mn></msub><mo>∗</mo><mi>g</mi><mo>∼</mo><msub><mi>f</mi><mn>2</mn></msub><mo>∗</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f_1 \sim f_2 \implies f_1*g \sim f_2*g</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>∼</mo><msub><mi>g</mi><mn>2</mn></msub><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>f</mi><mo>∗</mo><msub><mi>g</mi><mn>1</mn></msub><mo>∼</mo><mi>f</mi><mo>∗</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">g_1 \sim g_2 \implies f*g_1 \sim f*g_2</annotation></semantics></math></span>.</p>
<p>The first is trivial: if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_1(x) - f_2(x)</annotation></semantics></math></span> is bounded, of course <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_1(g(x)) - f_2(g(x))</annotation></semantics></math></span> is also bounded, just by properties of functions!</p>
<p>The second step also makes sense, but is trickier to formalize: if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_1(x) - g_2(x)</annotation></semantics></math></span> is bounded, then <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> being almost linear should preserve this bounded difference. Itʼs not like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> can stray too far away so as to make an unbounded difference on closely bounded inputs.</p>
<p>So how do we knead the almost-linear condition into a form that tells us about <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g_1(x)) - f(g_2(x))</annotation></semantics></math></span>? Well, what it looks like now is: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mtext>&nbsp;bounded</mtext><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">f(m+n) - f(m) - f(n)\ \text{bounded},</annotation></semantics></math></span> and to ask about the <em>difference</em> of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> at certain input, we want to pick <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>=</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m+n = g_1(x)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m = g_2(x)</annotation></semantics></math></span>, which makes <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n = g_1(x) - g_2(x)</annotation></semantics></math></span>, giving us: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>&nbsp;bounded</mtext><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">f(g_1(x)) - f(g_2(x)) - f(g_2(x) - g_1(x))\ \text{bounded}.</annotation></semantics></math></span> But weʼre done now, since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_2(x) - g_1(x)</annotation></semantics></math></span> is bounded, making its image under <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> bounded, so using the above fact, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g_1(x)) - f(g_2(x))</annotation></semantics></math></span> is really bounded as we wanted.</p>
<h3 id="machinery">Machinery</h3>
<p>Following <a href="http://arxiv.org/abs/math/0405454">Arthanʼs exposition</a>, we will need some more machinery before we tackle the rest of the proofs. Using the tools of <a href="https://en.wikipedia.org/wiki/Mathematical_analysis">mathematical analysis</a> we will establish further properties that capture the almost-linearity of functions, using the existing property of bounded wiggle.</p>
<p>Let <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span> be a bound for the wiggle of the function; <span data-t="" data-widget="">i.e.</span> <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">d_f(p, q) &lt; C</annotation></semantics></math></span> for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>.</p>
<p>The first lemma<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> we want to establish is the following<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(pq) − pf(q)| &lt; (|p| + 1)C.</annotation></semantics></math></span></p>
<p>We need to use induction on <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>. This wasnʼt obvious to me at first, but it makes sense in retrospect!</p>
<div class="Details">
<p>For the base case <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p = 0</annotation></semantics></math></span>, it is easy: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>−</mo><mn>0</mn><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>0</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(0) - 0| = |f(0)| = |f(0 + 0) - f(0) - f(0)| = |d_f(0, 0)| &lt; C.</annotation></semantics></math></span> However, letʼs rewrite it using the point <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>, to make the next steps of induction clearer: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(0)| = |f(0 + q) - f(0) - f(q)| = |d_f(0, q)| &lt; C.</annotation></semantics></math></span></p>
<p>Now we need to establish that if it holds for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>, then it holds for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p+1</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>C</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mspace linebreak="newline"></mspace><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo>+</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(pq) - pf(q)| &lt; (|p| + 1)C \implies\\ |f(pq + q) - pf(q) - f(q)| &lt; (|p| + 2)C.</annotation></semantics></math></span></p>
<p>How do we get from <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(pq) - pf(q)</annotation></semantics></math></span> to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f((p+1)q) - (p+1)f(q)</annotation></semantics></math></span>? The difference is <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f((p+1)q) - f(pq) - f(q)</annotation></semantics></math></span>: but this is actually <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_f(pq, q)</annotation></semantics></math></span>, so it is also less than <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span> in absolute value.</p>
<p>So this means that each step we take changes it by less than <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span>, and weʼre done by induction<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>. We can write it all out in one step like this: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mn>2</mn><mi>q</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>d</mi><mi>f</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|d_f(0, q) + d_f(q, q) + d_f(2q, q) + \cdots + d_f(pq, q)| &lt; (|p|+1)C.</annotation></semantics></math></span></p>
</div>
<p>Using that lemma, we get to the next lemma<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> in a very slick manner: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>q</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>q</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|pf(q) − qf(p)| &lt; (|p| + |q| + 2)C.</annotation></semantics></math></span></p>
<p>Our task here is to compare <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pf(q)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">qf(p)</annotation></semantics></math></span>. The magic of the above lemma is that it compared these values to a <em>common</em> value: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(pq) = f(qp)</annotation></semantics></math></span>. So we have what we need now: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>q</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mi>q</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>q</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo>+</mo><mi mathvariant="normal">∣</mi><mi>q</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|pf(q) - qf(p)| \le |pf(q) - f(pq)| + |f(qp) - qf(p)| &lt; (|p| + 1 + |q| + 1)C.</annotation></semantics></math></span></p>
<p>While weʼre here, we need one more lemma<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> that certifies that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> acts like a linear function, approximately. We show that there are some constants <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span> such that the following holds for all <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>B</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(p)| &lt; A|p| + B.</annotation></semantics></math></span></p>
<p>Notice that this also says that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> is behaves like a linear: it cannot grow outside the confines of the linear function <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A|p| + B</annotation></semantics></math></span> (although those <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span> may be large numbers, thus providing only loose bounds on <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span>).</p>
<p>It comes immediately from the above lemma: take <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">q = 1</annotation></semantics></math></span> to get <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">|pf(1) - f(p)| &lt; (|p| + 3)C</annotation></semantics></math></span> so with some rearranging we get <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(p)</annotation></semantics></math></span> by itself and a coefficient for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mn>3</mn><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|f(p)| &lt; (f(1) + C)|p| + 3C.</annotation></semantics></math></span></p>
<p>Thus we can take <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A = (f(1) + C)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mn>3</mn><mi>C</mi></mrow><annotation encoding="application/x-tex">B = 3C</annotation></semantics></math></span> to accomplish the task.</p>
<h3 id="slope-converges">Slope converges</h3>
<p>Now we <em>finally</em> have the tools we need to prove that we can get a slope out of these almost linear functions! Recall that we were going to define slope as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>0</mn></mrow></mfrac><mo>=</mo><munder><mrow><mi>lim</mi><mo>⁡</mo></mrow><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></munder><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\lim_{n \to \infty} \frac{f(n) - f(0)}{n - 0} = \lim_{n \to \infty} f(n)/n.</annotation></semantics></math></span></p>
<p>And to show that it converges, we show that it is a Cauchy sequence, meaning that terms in the sequence get arbitrarily close beyond a certain point: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>ϵ</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>N</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>&gt;</mo><mi>N</mi><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mrow><mo fence="true">∣</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>n</mi><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>m</mi><mo fence="true">∣</mo></mrow><mo>&lt;</mo><mi>ϵ</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\forall \epsilon &gt; 0, \exists N &gt; 0, \forall n, m &gt; N, \\ \left|f(n)/n - f(m)/m\right| &lt; \epsilon.</annotation></semantics></math></span></p>
<p>Well, the lemma above gives us exactly what we need, just pretend that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> stand for <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">∣</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mi>n</mi></mfrac><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><mi>m</mi></mfrac><mo fence="true">∣</mo></mrow><mo>=</mo><mfrac><mrow><mi>m</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>−</mo><mi>n</mi><mi>f</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><mrow><mi>m</mi><mi>n</mi></mrow></mfrac><mo>&lt;</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi></mrow><mrow><mi>m</mi><mi>n</mi></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\left\vert\frac{f(n)}{n} - \frac{f(m)}{m}\right\vert = \frac{mf(n) - nf(m)}{mn} &lt; \frac{(m+n+2)C}{mn}.</annotation></semantics></math></span></p>
<p>Notice how the numerator is like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m+n</annotation></semantics></math></span> and the denominator is like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span>, clearly the denominator will win as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> get large!</p>
<div class="Details">
<p>To give more details, notice how we can bound the fraction like so <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi></mrow><mrow><mi>m</mi><mi>n</mi></mrow></mfrac><mo>=</mo><mfrac><mi>C</mi><mi>n</mi></mfrac><mo>+</mo><mfrac><mi>C</mi><mi>m</mi></mfrac><mo>+</mo><mfrac><mrow><mn>2</mn><mi>C</mi></mrow><mrow><mi>m</mi><mi>n</mi></mrow></mfrac><mo>&lt;</mo><mfrac><mrow><mn>2</mn><mi>C</mi></mrow><mi>N</mi></mfrac><mo>+</mo><mfrac><mrow><mn>2</mn><mi>C</mi></mrow><msup><mi>N</mi><mn>2</mn></msup></mfrac><mo>&lt;</mo><mfrac><mrow><mn>4</mn><mi>C</mi></mrow><mi>N</mi></mfrac><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">\frac{(m+n+2)C}{mn} = \frac{C}{n} + \frac{C}{m} + \frac{2C}{mn} &lt; \frac{2C}{N} + \frac{2C}{N^2} &lt; \frac{4C}{N},</annotation></semantics></math></span> since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">m, n &gt; N</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N^2 &gt; N</annotation></semantics></math></span>.</p>
<p>So now to get <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mi>C</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">4C/N</annotation></semantics></math></span> to be less than <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span>, we need <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>&gt;</mo><mn>4</mn><mi>C</mi><mi mathvariant="normal">/</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">N &gt; 4C/\epsilon</annotation></semantics></math></span>. So as <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span> gets really tiny and close to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span> has to grow very large in response. But this is fine: it exists by the <a href="https://en.wikipedia.org/wiki/Archimedean_property">Archimedean property</a>, completing our proof.</p>
</div>
<h3 id="multiplication-is-commutative">Multiplication is commutative</h3>
<p>Let <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span>, <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span> be two almost-linear functions, we need to show that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∗</mo><mi>g</mi><mo>=</mo><mi>g</mi><mo>∗</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f*g = g*f</annotation></semantics></math></span> by showing that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(p) = f(g(p)) - g(f(p))</annotation></semantics></math></span> is bounded.</p>
<p>We will use the same trick as above, comparing <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(g(p))</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(f(p))</annotation></semantics></math></span> to a common term. In fact itʼs a titch more subtle still: we will add extra factors of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> first, comparing <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pf(g(p))</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pg(f(p))</annotation></semantics></math></span> to the common term <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g(p)f(p)</annotation></semantics></math></span>. Do you see where this is going? We get to use our lemmas from above!</p>
<p>Take <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = f(p)</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q = g(p)</annotation></semantics></math></span> in our favorite lemma, to give us these two inequalities: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">|pf(g(p)) − g(p)f(p)| &lt; (|p| + |g(p)| + 2)C</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|g(p)f(p) − pg(f(p)| &lt; (|p| + |f(p)| + 2)C.</annotation></semantics></math></span></p>
<p>Now to get <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|pf(g(p)) - pg(f(p))|</annotation></semantics></math></span> we take the sum, getting a bound of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(2|p| + |f(p)| + |g(p)| + 2)C.</annotation></semantics></math></span></p>
<p>That kind of looks awful, Iʼm not going to lie, <strong>but</strong> weʼre sooo close. Remember the other lemma that told us that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(p)|</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|g(p)|</annotation></semantics></math></span> behaved roughly like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span>? We can use that here to say that it <em>all</em> behaves like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span>:</p>
<p><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mo>&lt;</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mi>A</mi><mo>+</mo><mi>A</mi><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mo stretchy="false">(</mo><mi>B</mi><mo>+</mo><mi>B</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mi>C</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">(2|p| + |f(p)| + |g(p)| + 2)C &lt; (2+A+A)C|p| + (B + B + 2)C.</annotation></semantics></math></span></p>
<p>We can squash all that nonsense behind two new constants <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span> and <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span>, reaching our next conclusion: <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>p</mi><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>E</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">|pf(g(p)) - pg(f(p))| = |p|w(p) &lt; D|p| + E.</annotation></semantics></math></span></p>
<p>Take a breath … One last step.</p>
<p>Both sides now behave like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span>. If you look really closely, this actually implies that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(p)</annotation></semantics></math></span> is bounded: it must sort of behave like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span> (the slope of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span>) on the other side. (It certainly canʼt behave like <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span> or <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">|p|^2</annotation></semantics></math></span> or anything else that grows faster!)</p>
<div class="Details">
<p>More specifically, if we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>D</mi><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi><mo>+</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">|p| w(p) &lt; D|p| + E</annotation></semantics></math></span>, we can divide through by <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span> to get <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>D</mi><mo>+</mo><mfrac><mi>E</mi><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">w(p) &lt; D + \frac{E}{|p|}.</annotation></semantics></math></span></p>
<p>This is only valid when <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo mathvariant="normal">≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p \ne 0</annotation></semantics></math></span>, however! Since <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>p</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math></span> is an integer, it would then have to be at least <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span>, so <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>D</mi><mo>+</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">w(p) &lt; D + E</annotation></semantics></math></span> in that case.</p>
<p>And dealing with the case <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p = 0</annotation></semantics></math></span> on its own poses no problem (it bounds itself), so overall we have <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>D</mi><mo>+</mo><mi>E</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">w(p) \le \max(D + E, w(0)).</annotation></semantics></math></span></p>
</div>
<p>This establishes that <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(p) = f(g(p)) − g(f(p))</annotation></semantics></math></span> is bounded, and thus multiplication commutes!</p>
<h2 id="reflection-take-aways">Reflection &amp; Take-aways</h2>
<p>Whew! Hopefully you enjoyed our journey through almost-linear integer functions to get to Eudoxus real numbers.</p>
<p>Here are some things I did my best to convey in this article:</p>
<ul>
<li>We started with the intuition of how graphing calculators display pixelated lines in order to find a notion of slope that we could derive from integer functions.</li>
<li>My saw my favorite parts of Eudoxus real numbers: looking at the slope of lines means <a href="#multiplication">function composition <em>creates</em> multiplication</a>, and we get <a href="#multiplication-distributes-over-addition">distributivity</a> for free that way.</li>
<li>Perhaps you got a glimpse of the non-local nature of dealing with infinity: only the loooong term behavior matters when defining slope, because finite differences and even bounded differences simply <a href="#slope">disappear in the limit</a>.</li>
<li>And if you stuck around for the <a href="#proofs">proofs</a> (no shame if not!), you also got to peek at the methods of <a href="https://en.wikipedia.org/wiki/Mathematical_analysis">mathematical analysis</a>, where techniques for dealing with limits and bounding abstract quantities are studied and put to use. (This is often covered in a “Real Analysis” course in colleges and universities.)</li>
</ul>
<p>Thereʼs a lot still to talk about – like “what does it mean to <em>construct</em> a mathematical entity and what tools do we use to do so?”, and we didnʼt even prove that multiplicative inverses exist (what would that look like visually? I bet you have the intuition!) or that the Eudoxus reals are <a href="https://en.wikipedia.org/wiki/Complete_metric_space">sequentially complete</a>. But this is more than enough for now – the intuition is more important than the details.</p>
<div class="Bonus">
<p>For more on Eudoxus reals, including a cool construction of <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span> as a Eudoxus real number and references to further connections made with the construction, I would recommend <a href="https://mattbaker.blog/2021/12/15/the-eudoxus-reals/">Matt Baker’s Math Blog</a>. And of course see the <a href="https://ncatlab.org/nlab/show/Eudoxus+real+number">nLab</a>, where I originally learned about this construction and which I already referenced several times, and <a href="http://arxiv.org/abs/math/0405454">Arthanʼs exposition</a>, which helped me fill in the tougher proofs.</p>
</div>
<p><br></p>
<aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Rational numbers are countable, so they qualify as a finite approximation for us!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Okay, thereʼs some slight details here, like <a href="https://en.wikipedia.org/wiki/Spatial_anti-aliasing">antialiasing</a> and the fact it could draw several pixels stacked vertically. But for the sake of simplification letʼs assume that it only renders one pixel in each column, making it an honest-to-goodness integer function.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>This accounts for the two above properties as well as infinite differences that are not merely a shift but are still bounded. In fact, this allows us to get rid of horizontal shifts, as we will see <a href="#horizontal-shifting">later</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Note that the plain definition of multiplication <em>does</em> preserve monotonicity!<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Part of lemma 7 in Arthan<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Exercise: Why is this related to <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> being an almost linear function? What if <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span> was actually a linear function?<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Technically we also need to cover the cases where <span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span> is negative, but thatʼs easy.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Lemma 7 in Arthan<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Lemma 8 in Arthan<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>]]></description>
</item>
</channel>
</rss>
