module Parser.Comb.Types where

import Prelude

import Control.Alternative (class Alternative)
import Control.Apply (lift2)
import Control.Plus (class Alt, class Plus, empty, (<|>))
import Data.Array (head, length, splitAt, zipWith, (!!))
import Data.Compactable (class Compactable, compact, separateDefault)
import Data.Maybe (Maybe(..))
import Data.String (CodePoint)
import Data.Traversable (sequence)
import Data.Tuple (Tuple(..))
import Parser.Types (CST(..), Fragment, Grammar)
import Parser.Comb.Syntax (Syntax(..))

type CSyntax = Syntax
type CGrammar nt cat = Grammar nt Int cat
type CFragment nt cat = Fragment nt cat
type CCST nt o = CST (Tuple nt Int) o

-- | An applicative parser combinator that builds a grammar and parses a CST.
-- |
-- | It operates in two parts:
-- | - It builds a rule as a flat list of alternatives, and adds these rules
-- |   to the grammar when they are named (which enables recursion).
-- | - It builds a codec the parses a CST to obtain the arbitrary data out of
-- |   it that parser combinators are known for.
-- |
-- | Parsing then proceeds in two phases:
-- | - First the LR(1) parsing table is built from the grammar. This is cached.
-- | - For a given parse, following the table builds a CST, and then the codec
-- |   is used to parse the ultimate result out of the CST, based on which
-- |   rules were matched and the value of the tokens.
-- |
-- | `grammar` is a list of all the named rules generated by the syntax so far.
-- | `rules` is a list of all the alternative rules that this piece of syntax
-- | will recognize, along with the function to parse the corresponding CST into
-- | the result type (see `matchRule`).
-- |
-- | The action of `apply` is to take the cartesian product of rules and
-- | concatenate each alternative together; the action of `alt` is to simply
-- | append the lists of rules.
-- |
-- | This means that alternatives are statically flattened, unless they are
-- | named.
-- |
-- | `pretty` and `prettyGrammar` serve to keep track of the original tree
-- | structure, instead of the flattened rules.
-- |
-- | Invariant:
-- | - `rules # all \{ rule, resultant } -> length rule == resultant.length`
-- |
-- | Type parameters:
-- | - `nt`: Names for non-terminals. Must have an `Ord` instance.
-- | - `cat`: Categories of tokens, including literals. Also requires `Ord`.
-- |   Commonly `Similar String Rawr` to match with literal keywords and regexes.
-- | - `o`: Tokenize values output by the lexer. These appear in the CST.
-- | - `a`: Parser result, can be any type.
newtype Comb nt cat o a = Comb
  { grammar :: CGrammar nt cat
  , pretty :: Maybe (CSyntax nt cat)
  , prettyGrammar :: Array (Tuple nt (Maybe (CSyntax nt cat)))
  , rules :: Array
    { rule :: CFragment nt cat
    , resultant :: CResultant nt o a
    }
  }
type Combs = Comb String CodePoint CodePoint

-- | Parses an array (of CSTs), expecting a certain number of elements.
-- | It may still return failure early, though.
-- |
-- | Invariants:
-- | - `length i < r.length => (r.result `elem` [Partial, Failed])`
-- | - `length i == r.length => r.result /= Partial`
-- | - `r.result i == r.result (take r.length i)`
newtype Resultant i a = Resultant
  { length :: Int
  , result :: Array i -> PartialResult a
  }
type CResultant nt o = Resultant (CCST nt o)

data PartialResult a
  = Failed
  | Partial
  | Result a

derive instance functorComb :: Functor (Comb nt cat o)
instance applyComb :: Apply (Comb nt cat o) where
  apply (Comb l) (Comb r) = Comb
    { grammar: l.grammar <> r.grammar
    , pretty: Conj <$> l.pretty <*> r.pretty
    , prettyGrammar: l.prettyGrammar <|> r.prettyGrammar
    , rules: ado
        x <- l.rules
        y <- r.rules
        in
          { rule: x.rule <|> y.rule
          , resultant: x.resultant <*> y.resultant
          }
    }
instance applicativeComb :: Applicative (Comb nt cat o) where
  pure a = Comb
    { grammar: mempty
    , pretty: Just Null
    , prettyGrammar: empty
    , rules: pure
      { rule: empty
      , resultant: pure a
      }
    }
instance altComb :: Alt (Comb nt cat o) where
  alt (Comb l) (Comb r) = Comb
    { grammar: l.grammar <> r.grammar
    , pretty: case l.pretty, r.pretty of
        Nothing, Nothing -> Nothing
        Just lp, Nothing -> Just lp
        Nothing, Just rp -> Just rp
        Just lp, Just rp -> Just (Disj lp rp)
    , prettyGrammar: l.prettyGrammar <|> r.prettyGrammar
    , rules: l.rules <|> r.rules
    }
instance plusComb :: Plus (Comb nt cat o) where
  empty = Comb { grammar: mempty, pretty: Nothing, prettyGrammar: empty, rules: empty }
-- | Distributivity follows from distributivity of `Array`
instance alternativeComb :: Alternative (Comb nt cat o)
instance compactableComb :: Compactable (Comb nt cat o) where
  compact (Comb c) = Comb c { rules = c.rules <#> \r -> r { resultant = compact r.resultant } }
  separate eta = separateDefault eta
instance semigroupComb :: Semigroup a => Semigroup (Comb nt cat o a) where
  append = lift2 append
instance monoidComb :: Monoid a => Monoid (Comb nt cat o a) where
  mempty = pure mempty

-- | Matched a named rule against a CST, with codecs for each production.
matchRule :: forall nt o a. Ord nt => nt -> Array (CResultant nt o a) -> CCST nt o -> Maybe a
matchRule name resultants (Branch (Tuple _name i) children) | name == _name = do
  resultant <- resultants !! i
  resultFrom resultant children
matchRule _ _ _ = Nothing

-- | Modify the result of the parser based on the CST fragment it receives.
withCST :: forall nt cat o a b. (Array (CCST nt o) -> PartialResult (a -> b)) -> Comb nt cat o a -> Comb nt cat o b
withCST f = withCST' \csts prev -> f csts <*> prev unit

-- | Modify the result of the parser based on the CST fragment it receives.
withCST' :: forall nt cat o a b. (Array (CCST nt o) -> (Unit -> PartialResult a) -> PartialResult b) -> Comb nt cat o a -> Comb nt cat o b
withCST' f (Comb c) = Comb c
  { rules = c.rules <#> \r@{ resultant: Resultant { length, result } } -> r
    { resultant = Resultant
      { length
      , result: \csts -> f csts (\_ -> result csts)
      }
    }
  }

derive instance functorResultant :: Functor (Resultant i)
instance applyResultant :: Apply (Resultant i) where
  apply (Resultant l) (Resultant r) = Resultant
    { length: l.length + r.length
    , result: \i ->
        let { before: li, after: ri } = splitAt l.length i in
        l.result li <*> r.result ri
    }
instance applicativeResultant :: Applicative (Resultant i) where
  pure a = Resultant { length: 0, result: const (pure a) }
instance compactableResultant :: Compactable (Resultant i) where
  compact (Resultant r) = Resultant r { result = map compact r.result }
  separate eta = separateDefault eta

-- | Apply the resultant.
resultFrom :: forall i a. Resultant i a -> Array i -> Maybe a
resultFrom (Resultant r) i = case r.result i of
  Result a -> Just a
  _ -> Nothing

component :: forall i a. (i -> Maybe a) -> Resultant i a
component c = Resultant
  { length: 1
  , result: \is ->
      case head is of
        Nothing -> Partial
        Just i -> compact (Result (c i))
  }
-- | components = traverse component
components :: forall i a. Array (i -> Maybe a) -> Resultant i (Array a)
components cs = Resultant
  { length: length cs
  , result: \is ->
      if length is < length cs then Partial else
        compact (Result (sequence (zipWith identity cs is)))
  }

derive instance functorPartialResult :: Functor PartialResult
instance applyPartialResult :: Apply PartialResult where
  apply Failed _ = Failed
  apply _ Failed = Failed
  apply Partial _ = Partial
  apply _ Partial = Partial
  apply (Result f) (Result a) = Result (f a)
instance applicativePartialResult :: Applicative PartialResult where
  pure = Result
instance bindPartialResult :: Bind PartialResult where
  bind Failed _ = Failed
  bind Partial _ = Partial
  bind (Result a) f = f a
instance monadPartialResult :: Monad PartialResult
instance compactablePartialResult :: Compactable PartialResult where
  compact (Result Nothing) = Failed
  compact (Result (Just a)) = Result a
  compact Failed = Failed
  compact Partial = Partial
  separate eta = separateDefault eta
-- instance altResult :: Alt PartialResult where
--   alt Failed r = r
--   alt l Failed = l
--   alt Partial _ = Partial
--   alt l@(Result _) _ = l
