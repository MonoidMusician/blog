module Parser.Comb.Types where

import Prelude

import Control.Alternative (class Alternative)
import Control.Apply (lift2)
import Control.Plus (class Alt, class Plus, empty, (<|>))
import Data.Array (head, length, splitAt, zipWith, (!!))
import Data.Compactable (class Compactable, compact, separateDefault)
import Data.Either (Either)
import Data.Maybe (Maybe(..))
import Data.Profunctor (class Profunctor, lcmap)
import Data.String (CodePoint)
import Data.Traversable (sequence)
import Data.Tuple (Tuple(..))
import Parser.Comb.Syntax (Syntax(..))
import Parser.Types (CST(..), Fragment, Grammar)

type CSyntax = Syntax
type CGrammar nt cat = Grammar nt Int cat
type CFragment nt cat = Fragment nt cat
type CCST nt o = CST (Tuple nt Int) o

-- | An applicative parser combinator that builds a grammar and parses a CST.
-- |
-- | It operates in two parts:
-- | - It builds a rule as a flat list of alternatives, and adds these rules
-- |   to the grammar when they are named (which enables recursion).
-- | - It builds a codec the parses a CST to obtain the arbitrary data out of
-- |   it that parser combinators are known for.
-- |
-- | Parsing then proceeds in two phases:
-- | - First the LR(1) parsing table is built from the grammar. This is cached.
-- | - For a given parse, following the table builds a CST, and then the codec
-- |   is used to parse the ultimate result out of the CST, based on which
-- |   rules were matched and the value of the tokens.
-- |
-- | `grammar` is a list of all the named rules generated by the syntax so far.
-- | `rules` is a list of all the alternative rules that this piece of syntax
-- | will recognize, along with the function to parse the corresponding CST into
-- | the result type (see `matchRule`).
-- |
-- | The action of `apply` is to take the cartesian product of rules and
-- | concatenate each alternative together; the action of `alt` is to simply
-- | append the lists of rules.
-- |
-- | This means that alternatives are statically flattened, unless they are
-- | named.
-- |
-- | `pretty` and `prettyGrammar` serve to keep track of the original tree
-- | structure, instead of the flattened rules.
-- |
-- | Invariant:
-- | - `rules # all \{ rule, resultant } -> length rule == resultant.length`
-- |
-- | Type parameters:
-- | - `nt`: Names for non-terminals. Must have an `Ord` instance.
-- | - `cat`: Categories of tokens, including literals. Also requires `Ord`.
-- |   Commonly `Similar String Rawr` to match with literal keywords and regexes.
-- | - `o`: Tokenize values output by the lexer. These appear in the CST.
-- | - `a`: Parser result, can be any type.
newtype Comb rec nt cat o a = Comb
  { grammar :: CGrammar nt cat
  , pretty :: Maybe (CSyntax nt cat)
  , prettyGrammar :: Array (Tuple nt (Maybe (CSyntax nt cat)))
  , rules :: Array
    { rule :: CFragment nt cat
    , resultant :: CResultant rec nt o a
    }
  }
type Combs = Comb Unit String CodePoint CodePoint

rerec :: forall rec1 rec2 nt cat o a. (rec2 -> rec1) -> Comb rec1 nt cat o a -> Comb rec2 nt cat o a
rerec f (Comb c) = Comb c
  { rules = c.rules <#> \rule ->
    rule { resultant = lcmap f rule.resultant }
  }

-- Can be abstracted into a new type parameter for `Comb` if necessary
newtype Rec nt i o = Rec (i -> Either ParseError (CCST nt o))

type ParseError = String

-- | Parses an array (of CSTs), expecting a certain number of elements.
-- | It may still return failure early, though.
-- |
-- | Invariants:
-- | - `length i < r.length => (r.result `elem` [Partial, Failed])`
-- | - `length i == r.length => r.result /= Partial`
-- | - `r.result i == r.result (take r.length i)`
newtype Resultant i r a = Resultant
  { length :: Int
  , result :: r -> Array i -> PartialResult a
  }
type CResultant rec nt o = Resultant (CCST nt o) rec

data PartialResult a
  = Failed
  | Partial
  | Result a

derive instance functorComb :: Functor (Comb rec nt cat o)
instance applyComb :: Apply (Comb rec nt cat o) where
  apply (Comb l) (Comb r) = Comb
    { grammar: l.grammar <> r.grammar
    , pretty: Conj <$> l.pretty <*> r.pretty
    , prettyGrammar: l.prettyGrammar <|> r.prettyGrammar
    , rules: ado
        x <- l.rules
        y <- r.rules
        in
          { rule: x.rule <|> y.rule
          , resultant: x.resultant <*> y.resultant
          }
    }
instance applicativeComb :: Applicative (Comb rec nt cat o) where
  pure a = Comb
    { grammar: mempty
    , pretty: Just Null
    , prettyGrammar: empty
    , rules: pure
      { rule: empty
      , resultant: pure a
      }
    }
instance altComb :: Alt (Comb rec nt cat o) where
  alt (Comb l) (Comb r) = Comb
    { grammar: l.grammar <> r.grammar
    , pretty: case l.pretty, r.pretty of
        Nothing, Nothing -> Nothing
        Just lp, Nothing -> Just lp
        Nothing, Just rp -> Just rp
        Just lp, Just rp -> Just (Disj lp rp)
    , prettyGrammar: l.prettyGrammar <|> r.prettyGrammar
    , rules: l.rules <|> r.rules
    }
instance plusComb :: Plus (Comb rec nt cat o) where
  empty = Comb { grammar: mempty, pretty: Nothing, prettyGrammar: empty, rules: empty }
-- | Distributivity follows from distributivity of `Array`
instance alternativeComb :: Alternative (Comb rec nt cat o)
instance compactableComb :: Compactable (Comb rec nt cat o) where
  compact (Comb c) = Comb c { rules = c.rules <#> \r -> r { resultant = compact r.resultant } }
  separate eta = separateDefault eta
instance semigroupComb :: Semigroup a => Semigroup (Comb rec nt cat o a) where
  append = lift2 append
instance monoidComb :: Monoid a => Monoid (Comb rec nt cat o a) where
  mempty = pure mempty

-- | Matched a named rule against a CST, with codecs for each production.
matchRule :: forall rec nt o a. Ord nt => rec -> nt -> Array (CResultant rec nt o a) -> CCST nt o -> Maybe a
matchRule rec name resultants (Branch (Tuple _name i) children) | name == _name = do
  resultant <- resultants !! i
  resultFrom resultant rec children
matchRule _ _ _ _ = Nothing

-- | Modify the result of the parser based on the CST fragment it receives.
withCST :: forall rec nt cat o a b. (Array (CCST nt o) -> PartialResult (a -> b)) -> Comb rec nt cat o a -> Comb rec nt cat o b
withCST f = withCST' \csts prev -> f csts <*> prev unit

-- | Modify the result of the parser based on the CST fragment it receives.
withCST' :: forall rec nt cat o a b. (Array (CCST nt o) -> (Unit -> PartialResult a) -> PartialResult b) -> Comb rec nt cat o a -> Comb rec nt cat o b
withCST' f (Comb c) = Comb c
  { rules = c.rules <#> \r@{ resultant: Resultant { length, result } } -> r
    { resultant = Resultant
      { length
      , result: \rec csts -> f csts (\_  -> result rec csts)
      }
    }
  }

derive instance functorResultant :: Functor (Resultant i r)
derive instance profunctorResultant :: Profunctor (Resultant i)
instance applyResultant :: Apply (Resultant i r) where
  apply (Resultant l) (Resultant r) = Resultant
    { length: l.length + r.length
    , result: \rec i ->
        let { before: li, after: ri } = splitAt l.length i in
        l.result rec li <*> r.result rec ri
    }
instance applicativeResultant :: Applicative (Resultant i r) where
  pure a = Resultant { length: 0, result: \_ _ -> pure a }
instance compactableResultant :: Compactable (Resultant i r) where
  compact (Resultant r) = Resultant r { result = map (map compact) r.result }
  separate eta = separateDefault eta

-- | Apply the resultant.
resultFrom :: forall i r a. Resultant i r a -> r -> Array i -> Maybe a
resultFrom (Resultant res) r i = case res.result r i of
  Result a -> Just a
  _ -> Nothing

component :: forall i r a. (r -> i -> Maybe a) -> Resultant i r a
component c = Resultant
  { length: 1
  , result: \r is ->
      case head is of
        Nothing -> Partial
        Just i -> compact (Result (c r i))
  }
-- | components = traverse component
components :: forall i r a. Array (r -> i -> Maybe a) -> Resultant i r (Array a)
components cs = Resultant
  { length: length cs
  , result: \r is ->
      if length is < length cs then Partial else
        compact (Result (sequence (zipWith identity (cs <@> r) is)))
  }

derive instance functorPartialResult :: Functor PartialResult
instance applyPartialResult :: Apply PartialResult where
  apply Failed _ = Failed
  apply _ Failed = Failed
  apply Partial _ = Partial
  apply _ Partial = Partial
  apply (Result f) (Result a) = Result (f a)
instance applicativePartialResult :: Applicative PartialResult where
  pure = Result
instance bindPartialResult :: Bind PartialResult where
  bind Failed _ = Failed
  bind Partial _ = Partial
  bind (Result a) f = f a
instance monadPartialResult :: Monad PartialResult
instance compactablePartialResult :: Compactable PartialResult where
  compact (Result Nothing) = Failed
  compact (Result (Just a)) = Result a
  compact Failed = Failed
  compact Partial = Partial
  separate eta = separateDefault eta
-- instance altResult :: Alt PartialResult where
--   alt Failed r = r
--   alt l Failed = l
--   alt Partial _ = Partial
--   alt l@(Result _) _ = l
