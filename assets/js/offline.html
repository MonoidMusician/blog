<!doctype html>
<meta charset="utf-8"/>
<body style="padding:0;margin:0;background:#051627;background:#043147;">
<script src="https://cdn.jsdelivr.net/npm/path-data-polyfill@1.0.3/path-data-polyfill.min.js"></script>
</body>
<style>
  #superpath path:nth-child(2n) {
    stroke: blue;
  }
  .annot path:hover {
    stroke: blue;
    fill: #0059;
    pointer-events: stroke;
  }
</style>
<script>
// https://observablehq.com/@monoidmusician/svg-calligraphy@1926

var guideS = ["M60.745553,110.30621C63.233853,109.12941,64.635756,107.36009,65.218193,105.40807C66.092387,102.47824999999999,65.236723,99.03791,63.205139,96.76966399999999C58.747629,91.79289399999999,49.573695,91.10018399999998,44.47936,95.21885699999999C37.480662,100.87716999999998,34.314857,111.56303999999999,39.176101,119.17626999999999C43.918945,126.60405999999999,48.529125,129.69159,57.683391,130.10899999999998C58.394831,130.14139999999998,58.971176,129.90328999999997,60.22455,128.95573", "M 45.1864 110.3062 C 45.8085 109.1294 46.1589 107.3601 46.3045 105.4081 C 46.5231 102.4782 46.3092 99.0379 45.8013 96.7697 C 44.6869 91.7929 42.3934 91.1002 41.1198 95.2189 C 39.3702 100.8772 38.5787 111.563 39.794 119.1763 C 40.9797 126.6041 42.1323 129.6916 44.4208 130.109 C 44.5987 130.1414 44.7428 129.9033 45.0561 128.9557"][0];

var guideS = [
  {type: "M", values:[60.745553,110.30621]},
  {type: "C", values:[63.233853,109.12941,64.635756,107.36009,65.218193,105.40807]},
  {type: "C", values:[66.092387,102.47824999999999,65.236723,99.03791,63.205139,96.76966399999999]},
  {type: "C", values:[58.747629,91.79289399999999,49.573695,91.10018399999998,44.47936,95.21885699999999]},
  {type: "C", values: [37.480662,100.87716999999998,34.314857,111.56303999999999,39.176101,119.17626999999999]},
  {type: "C", values:[43.918945,126.60405999999999,48.529125,129.69159,57.683391,130.10899999999998]},
  {type: "C", values:[58.394831,130.14139999999998,58.971176,129.90328999999997,60.22455,128.95573]},
];

var nibS = ["M60.224551,128.95573C61.461901999999995,128.18440999999999,62.316894,127.40829999999998,62.955560999999996,126.62948999999999C63.798970999999995,125.60100999999999,64.265124,124.56781,64.736392,123.53466999999999C63.876065,123.99437999999999,62.907411999999994,124.68327,62.023517,125.75223C61.344727,126.57314,60.715922,127.6182,60.224551,128.95573","M60.224551,128.95573L62.955560999999996,126.62948999999999L64.736392,123.53466999999999L62.023517,125.75223L60.224551,128.95573"][0];

var segments = [[[[19.07441902522832,17.446785423636857],[20.370738764806944,16.891219820960305],[21.66705850438557,15.965277149832716]],[[22.593001175513155,15.039334478705127],[23.704132380866263,13.928203273352022],[24.444886517768335,12.44669499954788]],[[22.593001175513155,12.817072067998915],[21.48186997016005,13.18744913644995],[20.00036169635591,13.928203273352022]],[[18.889230491002802,14.85414594447961],[18.148476354100733,16.150465684058233],[17.592910751424178,17.631973957862375]]],[[[18.33366488832625,19.113482231666516],[20.370738764806944,16.891219820960305],[21.66705850438557,15.965277149832716]],[[22.593001175513155,15.039334478705127],[24.81526358621937,13.743014739126503],[24.444886517768335,12.44669499954788]],[[22.407812641287638,13.372637670675468],[21.48186997016005,13.18744913644995],[19.815173162130392,14.298580341803056]],[[17.7780992856497,15.409711547156162],[17.222533682973143,16.33565421828375],[17.592910751424178,17.631973957862375]]]][1];

function toPath(segs) {
  if (!segs.length) return "";
  var p = segs[segs.length-1][2];
  var r = [{type:"M", values:p}];
  for (let seg of segs) {
    r.push({type:"C", values:seg.flatMap(x => x)});
  }
  return r;
}

var curves = (function(segs) {
  if (!segs.length) return "";
  var p = segs[segs.length-1][2];
  var r = [];
  for (let seg of segs) {
    var c = [p, ...seg];
    c.seg = seg;
    r.push(c);
    p = seg[seg.length-1];
  }
  return r;
})(segments)

var getSVG = el => {
  while (el && el.tagName !== "svg")
    el = el.parentElement;
  return el;
}

var scaled = (event,el) => {
  var svg = getSVG(el || event.sourceEvent.target);
  var disp = svg?.getBoundingClientRect();
  var vb = svg?.viewBox?.animVal || svg?.viewBox?.baseVal;
  var scale = (outer, offset, inner, value) => offset + value*inner/outer;
  return {
    x: scale(disp.width, vb.x, vb.width, event.x),
    y: scale(disp.height, vb.y, vb.height, event.y),
  };
}

var curvature = (b0,b1,b2) => {
  let b21 = [b2[0]-b1[0],b2[1]-b1[1]];
  let d0 = [b1[0]-b0[0],b1[1]-b0[1]];
  let d0xb21 = d0[0]*b21[1] - d0[1]*b21[0];
  let delta = Math.sqrt(d0[0]*d0[0] + d0[1]*d0[1]);
  return (2/3)*d0xb21/Math.pow(delta, 3);
}

var oscu = (b0,b1,b2) => {
  let d0 = [b1[0]-b0[0],b1[1]-b0[1]];
  let delta = Math.sqrt(d0[0]*d0[0] + d0[1]*d0[1]);
  let norm = [-d0[1]/delta, d0[0]/delta];
  let r = 1/curvature(b0,b1,b2);
  let c = [norm[0]*r + b0[0], norm[1]*r + b0[1]];
  return svg`<circle cx=${c[0]} cy=${c[1]} r=${Math.abs(r)}>`;
}

var xmlns = "http://www.w3.org/2000/svg";

class Path extends Array {
  constructor(path) {
    super();
    Object.assign(this, path);
  }
  toString() {
    return renderPathData(this);
  }
}

function mkSVG(n) {
  if (n instanceof SVGElement) return n;
  var node = document.createElementNS(xmlns, n.type);
  var attrs = Object.assign({}, n);
  delete attrs.type;
  delete attrs.children;
  for (let a in attrs) {
    var v = attrs[a];
    if (a === "d") v = renderPathData(v);
    else if (a === "style" && typeof v === "object") {
      let r = "";
      for (let k in v) {
        r += (r ? "; " : "") + k + ": " + v[k];
      }
      v = r;
    }
    if (a.startsWith("on")) {
      node[a] = v;
    } else {
      node.setAttribute(a, v);
    }
  }
  if (n.children) {
    for (let c of n.children) {
      if (!(c instanceof SVGElement)) c = mkSVG(c);
      node.appendChild(c);
    }
  }
  if (attrs.id) {
    var other = document.getElementById(attrs.id);
    if (other) {
      other.replaceWith(node);
    }
  }
  return node;
}
function mkPath(d) {
  path = document.createElementNS(xmlns, "path");
  path.setAttribute("d", renderPathData(d));
  return path;
}


function placesI(iters=400) {
  var r = []; for (var i = 0; i < 1; i += 1/iters) r.push(i); return r;
}

var places = placesI();

function pathToCurves(path) {
  path = getPathData(path);
  var r = [];
  var p = [0,0]; var s = null;
  for (let idx in path) {
    let seg = path[idx];
    var [n, s] = getNextStart(seg, p, s);
    var a = absolutize(seg, p);
    switch (seg.type.toLowerCase()) {
      case "c":
        r.push([p].concat(group(a.values, 2)));
        break;
      case "l":
        break;
    }
    p = n;
  }
  return r;
}
function curvesToPath(curves) {
  var r = [];
  var p = null;
  for (let curve of curves) {
    let p1 = curve[0];
    if (!p || p1.toString() !== p.toString()) {
      r.push({type:"M",values:p1});
    }
    r.push({type:"C",values:curve.slice(1).flatMap(x => x)});
    p = curve[curve.length - 1];
  }
  return r;
}

var time_depth = 0;
function time(label, fn, ...args) {
  return fn(...args);
  var start = performance.now();
  time_depth += 1;
  var r = fn(...args);
  time_depth -= 1;
  var end = performance.now();
  console.log(`${label}: ${(end - start).toFixed(2)}ms`);
  return r;
}

function doTheThing(p1, p2, well) {
  var start = performance.now();
  registry = {};
  ps = getPathData(p2);
  p2 = (splitPathAtInflections(p2));
  let c2s = pathToCurves(p2);
  p1 = getPathData(p1);
  let c1s = pathToCurves(p1);
  let rs = [];
  // Then get tangents and concavities to split p1 at
  let allTangents = c2s.flatMap(getTangentsL);
  function getTangentsL(c2) {
    return [tangent(c2[0], c2[1]), tangent(c2[2], c2[3]), tangent(c2[0], c2[3])];
  }
  let allKeys = [];
  for (let c2 of c2s) {
    let tangents = getTangentsL(c2);
    let c1s2 = c1s.flatMap(c1 => splitBezierAtTangents(c1, well === 2 ? allTangents : tangents));
    for (let c1 of c1s2) {
      let r = doTheTask(c1, c2);
      rs.push(...r.map(curvesToPath));
      allKeys.push(c1[0], c1[3]);
    }
  }
  if (well) {
    allKeys = uniqBy(allKeys, x => x.toString());
    for (let [dx,dy] of allKeys) {
      rs.push(curvesToPath(c2s.map(c2 => c2.map(([x,y]) => ([x+dx,y+dy])))));
    }
  }
  console.log((performance.now() - start).toFixed(2));
  return rs;
}
function chop(points, t0, t1) {
  if (t1 < t0) {
    return chop(points.slice().reverse(), 1-t0, 1-t1);
  }
  if (t0 === 0) {
    if (t1 === 1) return points;
    return bsplit(points, t1)[0];
  } else {
    if (t1 === 1) return bsplit(points, t0)[1];
    return bsplitMany(points, [t0,t1])[1];
  }
}
var registry = {};
let lookup = path => {
  curves = pathToCurves(getPathData(path));
  for (let curve of curves) {
    let r = registry[curve.toString()];
    if (r) return r;
  }
  throw new Error("Unknown path " + path.toString());
}
function doTheTask(P, Q) {
  let {T_SOL,compositeI} = calligraphy;
  function add([x0,y0], [x1,y1]) {
    return [x0+x1,y0+y1];
  }
  let Q0 = Q.map(p => add(p, P[0]));
  let Q1 = Q.map(p => add(p, P[3]));
  let ts = [
    [0, P.map(p => add(p, Q[0])), 0],
    [1, P.map(p => add(p, Q[3])), 1],
  ];
  registry[ts[0][1].toString()] = [P,Q];
  registry[ts[1][1].toString()] = [P,Q];
  let tts = [
    [ts[0], ts[1]],
  ];
  let err = 0;
  try {
    ts.push(compositeI(P,Q));
    if (ts[2][1].every(p => p.every(Number.isFinite))) {
      //tts.pop();
      tts.push(
        [ts[0], ts[2]],
        [ts[1], ts[2]],
      );
    }
  } catch(e) {
    try {
      T_SOL(P,Q)(0);
      T_SOL(P,Q)(1);
      //console.error(e);
      err = 1;
    } catch(e2) {
      //console.log(e);
    }
  }
  function chopped([[t0, conn0, d0], [t1, conn1, d1]]) {
    return [
      chop(Q0, t1, t0),
      conn0,
      chop(Q1, d0, d1),
      conn1.slice().reverse(),
    ];
  }
  return tts.map(chopped);
}

function guesstimate(curves) {
  if (curves.length === 1) return new Curve(curves[0]);
  const c0 = curves[0]; const c1 = curves[curves.length-1];
  const f0 = c0[0];
  const f1 = c1[3];
  const d0 = sub(c0[1], c0[0]);
  const d1 = sub(c1[3], c1[2]);
  const k0 = Bcurvature0(c0);
  const k1 = Bcurvature1(c1);
  return fit_check(f0,f1,d0,d1,k0,k1);
}

function center(path) {
  //return startingAt([0,0],path);
  path = getPathData(path);
  let points = getPoints(path);
  let avg = getOrigin(path).map(x => x*points.length);
  for (let point of points) {
    avg[0] -= point[0];
    avg[1] -= point[1];
  }
  avg = avg.map(x => x/points.length);
  return startingAt(avg, path);
}

document.addEventListener("DOMContentLoaded", () => {
  document.body.appendChild(interactive());
});

document.addEventListener("DOMContentLoaded", () => {
  document.body.appendChild(visualize(guideS, toPath(segmentsC)));
});

function listen(to, name, listener) {
  if (!to) to = document;
  let event = e => {
    if (listener)
      return listener(e);
  };
  to.addEventListener(name, event);
  return () => {
    to.removeEventListener(name, event);
  }
}
function mkListeners(obj, df_tgt) {
  for (let k in obj) {
    let v = obj[k];
    let t = v.target;
    if (t === undefined) t = df_tgt;
    if (!t) t = document;
    let a = v.active;
    let is_active = false;
    Object.defineProperty(v, "active", {
      get: () => !!is_active,
      set: actv => {
        if (!!is_active === !!actv) return;
        if (is_active) {
          is_active(); is_active = null;
        } else {
          is_active = listen(t, k, v);
        }
      },
    });
    v.active = a;
  }
}

var localized = (event,el, to) => {
  if (!to) to = {x:0,y:0};
  var svg = getSVG(el || event.target);
  var disp = svg?.getBoundingClientRect();
  var vb = svg?.viewBox?.animVal || svg?.viewBox?.baseVal;
  var scale = (origin, outer, offset, inner, value) => offset + value*inner/outer;
  //console.log(svg, disp, vb);
  return {
    x: scale(disp.left, disp.width, vb.x, vb.width, event.pageX) - to.x,
    y: scale(disp.top, disp.height, vb.y, vb.height, event.pageY) - to.y,
  };
}

function draggable(node, datum=undefined, done=undefined) {
  let dragging = false;
  let o = null;
  let debounce = null;
  let listeners = {
    mousedown: Object.assign(e => {
      o = localized(e, node);
      if (datum) {
        datum(node, o, o, {x:0,y:0}, e);
      }
      listeners.active = true;
    }, {target: node, active: true}),
    mousemove: Object.assign(e => {
      if (datum) {
        let c = localized(e, node);
        datum(node, c, o, {x:c.x-o.x,y:c.y-o.y}, e);
      }
      if (done) {
        if (debounce) clearTimeout(debounce);
        debounce = setTimeout(() => {
          done(node, false);
        }, 50);
      }
    }, {target: null}),
    mouseup: Object.assign(e => {
      o = null;
      listeners.active = false;
      if (done) {
        done(node, true, e);
      }
    }, {target: null}),
  };
  Object.defineProperty(listeners, "active", {
    set: actv => {
      listeners.mousemove.active = actv;
      listeners.mouseup.active = actv;
    }
  });
  mkListeners(listeners);
  return node;
}
var segmentsC = [[[-1.8889230491002778,3.5185821502848356],[0.14815082738041596,1.2963197395786246],[1.4444705669590405,0.3703770684510346]],[[2.370413238086627,-0.5555656026765536],[4.5926756487928415,-1.8518853422551782],[4.222298580341807,-3.148205081833801]],[[2.1852247038611097,-2.2222624107062128],[1.2592820327335232,-2.40745094493173],[-0.4074147752961359,-1.2963197395786246]],[[-2.4444886517768296,-0.18518853422551906],[-3.000054254453385,0.7407541369020691],[-2.6296771860023505,2.0370738764806937]]];
var INPUT = {
  nib: {
    value: [],
  },
};
function rotate([x,y], a) {
  var c = Math.cos(a);
  var s = Math.sin(a);
  return [x*c + y*s, y*c - x*s];
}
function rotateXY({x,y}, a) {
  var c = Math.cos(a);
  var s = Math.sin(a);
  return {x:x*c + y*s, y:y*c - x*s};
}
function toDegrees (angle) {
  return angle * (180 / Math.PI);
}
function toRadians (angle) {
  return angle * (Math.PI / 180);
}
function roundAngle(angle) {
  return toRadians((Math.round(toDegrees(angle) + 45 + 360) % 90) - 45);
}
function interactive() {
  var path = mkPath(toPath(segmentsC));
  var copySegments = () => segmentsC.map(ps => ps.map(p => p.map(xy => xy)));
  var mutateSegments = (fn,against) => {
    if (!against) against = segmentsC;
    for (let i in segmentsC) {
      for (let j in segmentsC[i]) {
        var p = fn(against[i][j]);
        Object.assign(segmentsC[i][j], p);
        segmentsC[i][j].node.setAttribute("cx", segmentsC[i][j][0]);
        segmentsC[i][j].node.setAttribute("cy", segmentsC[i][j][1]);
        path.setAttribute("d", renderPathData(toPath(segmentsC)));
      }
    }
  };
  var restoreSegments = against => mutateSegments(p => p, against);
  var rotating = f => ([x,y]) => {
    return rotate(f(rotate([x,y], angle)), -angle);
  };
  let update = () => requestAnimationFrame(() => visualize(guideS, toPath(segmentsC)));
  let update2 = (_, reallyDone) => {
    mkSVG({
      type: "g",
      id: "superpath",
      fill: "none",
      children: pathToCurves(splitPathAtInflections(toPath(segmentsC))).map(c => mkPath(curvesToPath([c]))),
    });
    if (reallyDone) update();
  };
  let angle = toRadians(1 ? -44 : -37);
  var superpath = mkSVG({
    type: "g",
    id: "superpath",
    fill: "none",
    children: pathToCurves(splitPathAtInflections(toPath(segmentsC))).map(c => mkPath(curvesToPath([c]))),
  });
  let arcs = [
    "M 0 9.95 A 10 10 0 0 0 2 9.75 M 0 9.95 A 10 10 0 0 1 -2 9.75",
    "M 0 -9.95 A 10 10 0 0 1 2 -9.75 M 0 -9.95 A 10 10 0 0 0 -2 -9.75",
    "M 9.95 0 A 10 10 0 0 1 9.75 2 M 9.95 0 A 10 10 0 0 0 9.75 -2",
    "M -9.95 0 A 10 10 0 0 0 -9.75 2 M -9.95 0 A 10 10 0 0 1 -9.75 -2",
  ]
  return mkSVG({
    type: "svg",
    id: "vis",
    "viewBox": [-10, -10, 20, 20],
    "style": {
      "max-width": "calc(50vw - 5px)",
      "max-height": "calc(100vh - 5px)",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "fill": "#000",
      "stroke": "#444",
      "stroke-width": 0.8,
    },
    children: [
      {type:"g",style:{"fill":"none"},children:[path]},
      //superpath,
      picks = mkSVG({
        type: "g",
        style: {
          "fill": "none",
          "stroke": "transparent",
          "stroke-width": 0.25,
          "stroke-linecap": "butt",
          "transform": `rotate(${angle}rad)`,
        },
        children: [
          draggable(mkSVG({
            type: "line",
            style: {
              "cursor": "ns-resize",
            },
            x1: -0, x2: 0, y1: -10, y2: 10,
          }), (_, current, start) => {
            if (current === start) {
              start.points = copySegments();
            } else {
              var scale = rotateXY(current, angle).y / rotateXY(start, angle).y;
              mutateSegments(rotating(([x,y]) => ([x,scale*y])), start.points);
            }
          }, update2),
          draggable(mkSVG({
            type: "line",
            style: {
              "cursor": "ew-resize",
            },
            x1: -10, x2: 10, y1: -0, y2: 0,
          }), (_, current, start) => {
            if (current === start) {
              start.points = copySegments();
            } else {
              var scale = rotateXY(current, angle).x / rotateXY(start, angle).x;
              mutateSegments(rotating(([x,y]) => ([scale*x,y])), start.points);
            }
          }, update2),
          draggable(mkSVG({
            type: "circle",
            style: {
              "fill": "transparent",
              "cursor": "move",
            },
            cx: 0, cy: 0, r: 0.25,
          }), (_, current, start, delta) => {
            if (current === start) {
              start.points = copySegments();
            } else {
              let factor = 1;
              mutateSegments(([x,y]) => ([x + factor*delta.x, y + factor*delta.y]), start.points);
            }
          }, update2),
          ...arcs.map(arc => draggable(mkSVG({
            type: "path",
            d: arc,
            style: {cursor:"crosshair"},
          }), (_node, current, start, _delta, event) => {
            if (current === start) {
              start.original_angle = angle;
              start.angle = Math.atan2(start.y, start.x);
              start.points = copySegments();
            } else {
              current.angle = Math.atan2(current.y, current.x);
              angle = roundAngle(current.angle - start.angle) + start.original_angle;
              gui.style.transform = `rotate(${angle}rad)`;
              picks.style.transform = `rotate(${angle}rad)`;
              if (!event.shiftKey) {
                mutateSegments(p => rotate(p, toRadians(Math.round(toDegrees(start.angle - current.angle)))), start.points);
              } else {
                restoreSegments(start.points);
              }
            }
          }, update2)),
        ]
      }),
      {
        type:"g",
        children: segmentsC.flatMap(x=>x).map(p =>
          draggable(p.node = mkSVG({
            type: "circle",
            "cx": p[0],
            "cy": p[1],
            "r": .15,
            "fill": "gray",
            "stroke": "lightgray",
            "stroke-width": 0.05,
          }), (node, current, start) => {
            p[0] = current.x;
            p[1] = current.y;
            node.setAttribute("cx", current.x);
            node.setAttribute("cy", current.y);
            path.setAttribute("d", renderPathData(toPath(segmentsC)));
            mkSVG({
              type: "g",
              id: "superpath",
              fill: "none",
              children: pathToCurves(splitPathAtInflections(toPath(segmentsC))).map(c => mkPath(curvesToPath([c]))),
            });
          }, update)
        ),
      },
      gui = mkSVG({
        type: "g",
        style: {
          "fill": "none",
          "stroke": "#76cbe79e",
          "stroke-width": 0.05,
          "stroke-dasharray": 20/21*1/5,
          "stroke-linecap": "butt",
          "pointer-events": "none",
          "transform": `rotate(${angle}rad)`,
        },
        children: [
          {
            type: "line",
            x1: -0, x2: 0, y1: -10, y2: 10,
          },
          {
            type: "line",
            x1: -10, x2: 10, y1: -0, y2: 0,
          },
          ...arcs.map(mkPath),
        ]
      }),
    ],
  });
}

// easySVG
// - drag n drop
// - underlying re-coordinator
//   and listeners for … stuff
// - prioritizer

function visualize(p1, p2, prec) {
  var YEAH = doTheThing(p1, p2);
  return mkSVG({
    type: "svg",
    id: "PREVIEW",
    "viewBox": [30, 85, 50, 50],
    "fill": "#000",
    "stroke": "#000",
    "stroke-width": 0.8,
    "style": {
      "max-width": "calc(50vw - 5px)",
      "max-height": "calc(100vh - 5px)",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
    },
    "ondblclick": () => {
      if (!prec || prec < 500) {
        visualize(p1, p2, (prec || 00) + 100);
      }
    },
    children: [
      {
        type: "g",
        "fill": "red",
        "stroke": "red",
        children: placesI(prec || 00).map(i => mkPath(startingAt(calcP(p1, i), p2, true).toString())),
      },
      {
        type: "g",
        children: YEAH.map(mkPath),
      },
      {
        type: "g",
        "class": "annot",
        "fill": "none",
        "stroke": "#0804",
        "stroke-width": 0.1,
        children: YEAH.map(d => ({
          type: "path",
          "d": d,
          "onclick": e => {
            let [P,Q] = lookup(e.target);
            let cs = pathToCurves(getPathData(e.target));
            console.log(P, Q);
            try {
              console.log(calligraphy.composite(P, Q));
            } catch(e) {
              console.error(e);
            }
          },
          "ondblclick": e => {e.target.remove();e.stopPropagation()},
        })),
      }
    ],
  });
}

function getPathData(path, copy) {
  if (typeof path === 'string') {
    path = mkPath(path);
  }
  if (path instanceof SVGPathElement) {
    path = path.getPathData();
  } else if (copy) {
    path = path.map(({ type, values }) => ({ type, values: values.map(v => v) }));
  }
  return new Path(path);
}

function trunc(path) {
  return getPathData(path).map(({ type, values }) => ({ type, values: values.map(v => +v.toFixed(3)) }));
}

function group(vs, l=2) {
  var vs = Array.from(vs);
  var r = [];
  while (vs.length) {
    r.push(vs.slice(0, l));
    vs.splice(0, l);
  }
  return r;
}

function toBs(path) {
  path = getPathData(path);
  var p = [0, 0];
  var s = getOrigin(path);
  var bs = [];
  for (let seg of path) {
    var t = seg.type.toLowerCase();
    var adj = q => [q[0]+p[0], q[1]+p[1]];
    if (t !== seg.type) {
      adj = q => q;
    }
    switch (t) {
      case "m":
        p = seg.values;
        break;
      case "z":
        if (p[0] !== s[0] || p[1] !== s[1]) {
          bs.push([p, s]);
        }
        p = s;
      case "c":
        bs.push([p, ...group(seg.values, 2).map(adj)]);
        p = seg.values.slice(-2);
        break;
      default:
        throw new Error("Unknown command: " + seg.type);
    }
  }
  return bs;
}

function reversePath(path) {
  path = getPathData(path, true);
  var rev = [];
  var p = [0,0]; var s = 0;
  for (let seg of path) {
    var s0 = Object.assign({}, seg);
    var [n,s] = getNextStart(seg, p, s);
    var abs = (seg.type.toLowerCase() !== seg.type);
    switch (seg.type) {
      case "h":
      case "v":
        seg.values[0] *= -1;
        break;
      case "H":
        seg.values[0] = n[0];
        break;
      case "V":
        seg.values[0] = n[1];
        break;
      default:
        if (abs) {
          var adj = (q,i) => i > 0 ? q : p;
        } else {
          var adj = (q,i) => i > 0 ? [p[0]+q[0]-n[0], p[1]+q[1]-n[1]] : [-q[0], -q[1]];
        }
        var vs = group(seg.values, 2).reverse().map(adj);
        vs.push(vs.shift());
        seg.values = [].concat(...vs);
    }
    p = n;
    rev.unshift(seg);
  }
  if (rev[rev.length-1].type === "M")
    rev.pop();
  rev.unshift({ type: "M", values: p });
  return getPathData(rev);
}

function calcB(coords, t) {
  if (coords.length === 1) return coords[0];
  var c1 = coords.slice(0, -1);
  var p1 = calcB(c1, t);
  var c2 = coords.slice(1);
  var p2 = calcB(c2, t);
  return [(1-t)*p1[0] + t*p2[0], (1-t)*p1[1] + t*p2[1]];
}

function lengthB(coords) {
  var dx = coords[0][0] - coords[coords.length-1][0];
  var dy = coords[0][1] - coords[coords.length-1][1];
  return Math.sqrt(dx*dx + dy*dy);
}

function calcP(path, t) {
  var bs = toBs(path);
  var l = bs.reduce((r, b) => r+lengthB(b), 0);
  var i = 0; var li = lengthB(bs[i]);
  var lt = l * t;
  while (lt > li) {
    lt -= li;
    i += 1;
    li = lengthB(bs[i]);
  }
  return calcB(bs[i], lt/li);
}

function renderPathData(segs) {
  if (typeof segs === 'string') return segs;
  return segs.reduce((r, c) => {
    return (r ? r + " " : r) + (c.type ? c.type + c.values : renderPathData(c));
  }, "");
  var path = document.createElementNS(xmlns, "path");
  path.setPathData(segs);
  return path.getAttribute("d");
}

function getPoints(path) {
  var points = [];
  path = getPathData(path);
  var p = [0, 0]; var s = [0, 0];
  for (let seg of path) {
    var t = seg.type.toLowerCase();
    points.push(p = getNext(seg, p, s));
    if (t === "m")
      s = p;
  }
  return points;
}

function getNext(seg, prev, start) {
  var t = seg.type.toLowerCase();
  if (!prev || seg.type !== t) {
    prev = [0,0];
  }
  if ("mclsaqt".includes(t)) {
    var v = seg.values.slice(-2);
    return [prev[0] + v[0], prev[1] + v[1]];
  } else if (t === "h") {
    return [prev[0] + seg.values[0], prev[1]];
  } else if (t === "v") {
    return [prev[0], prev[1] + seg.values[0]];
  } else if (t === "z") {
    return start;
  } else {
    console.log("Unknown: ", seg);
  }
}

function getNextStart(seg, prev, start) {
  var next = getNext(seg, prev, start);
  if (!start) start = next;
  else if (seg.type === "m") start = null;
  return [next, start];
}

function getNextStart2(seg, prev, start) {
  var n = getNext(seg, prev, start);
  var p = prev;
  var s = start;
  switch (seg.type.toLowerCase()) {
    case "m":
      if (s && p && n.toString() !== p.toString()) {
        s = null;
      }
      break;
    case "z":
      if (s) {
        s = null;
      }
      break;
    default:
      if (!s) {
        s = p;
      } else if (n.toString() === s.toString()) {
        s = null;
      }
  }
  return [n, s];
}

function getEndpoints(path) {
  path = getPathData(path);
  var r = [];
  var p = null;
  var s = null;
  for (let seg of path) {
    var t = seg.type.toLowerCase();
    var n = getNext(seg, p, s);
    switch (t) {
      case "m":
        if (s && p && n.toString() !== p.toString()) {
          r.push(p);
          s = null;
        }
        break;
      case "z":
        if (s) {
          r.pop();
          s = null;
        }
        break;
      default:
        if (!s) {
          s = p;
          r.push(s);
        } else if (n.toString() === s.toString()) {
          r.pop();
          s = null;
        }
    }
    p = n;
  }
  if (s && p) {
    r.push(p);
  }
  return r;
}

function getSections(path) {
  path = getPathData(path);
  var r = [];
  var p = null;
  var s = null;
  for (let seg of path) {
    var t = seg.type.toLowerCase();
    //if (trivial(seg, p, s)) continue;
    if (seg.type.toLowerCase() !== "m") {
      if (!s) {
        r.push([{ type: "M", values: p }]);
      }
      r[r.length-1].push(seg);
    }
    var [n,s] = getNextStart2(seg, p, s);
    p = n;
  }
  return r;
}

function getOrigin(path) {
  var points = getPoints(path);
  return points[0] || [0,0];
}

function adjust(seg, prev) {
  var t = seg.type.toLowerCase();
  if (seg.type === t) {
    return function(p) {
      return [p[0]+prev[0], p[1]+prev[1]];
    }
  } else {
    return function(p) {
      return p;
    }
  }
}

function absolutize(seg, prev) {
  var t = seg.type.toLowerCase();
  var T = seg.type.toUpperCase();
  if (!prev || seg.type !== t) {
    prev = [0,0];
  }
  if ("mclsaqt".includes(t)) {
    return { ...seg, type: T, values: [].concat(...group(seg.values, 2).map(adjust(seg, prev))) };
  } else if (seg.type === "h") {
    return { ...seg, type: T, values: [seg.values[0]+prev[0]] };
  } else if (seg.type === "v") {
    return { ...seg, type: T, values: [seg.values[0]+prev[1]] };
  } else {
    return seg;
  }
}

function tangent(p1, p2) {
  var delta = [p2[0]-p1[0], p2[1]-p1[1]];
  return { slope: delta[1]/delta[0], p1, p2, delta };
}

function bezierDeriv([p0, p1, p2, p3]) {
  return [0,1].map(i => [-3*p0[i] + 9*p1[i] - 9*p2[i] + 3*p3[i], 6*p0[i] - 12*p1[i] + 6*p2[i], -3*p0[i] + 3*p1[i]]);
}

function solveTangent(c1, c2, v1, v2) {
  return solveQuadratic([0,1,2].map(i => c1[i]*v2 - c2[i]*v1)).filter(t => 0 <= t && t <= 1).sort();
}

function solveQuadratic([a,b,c], v) {
  if (v) c -= v;
  var disc = b*b - 4*a*c;
  if (disc === 0) return [-b/a/2];
  if (disc < 0) return [];
  return [Math.sqrt(disc),-Math.sqrt(disc)].map(sdisc => (-b + sdisc)/a/2);
}

function findBezierTangents(c, tangents) {
  var d = bezierDeriv(c);
  var sols = [];
  for (let tan of tangents) {
    sols.push(...solveTangent(...d, ...tan.delta).map(t => ({t, tan})));
  }
  return uniqBy(sols, x => x).sort((a,b) => a.t - b.t);
}

function bsplit(points, t0) {
  var n = points.length - 1; // number of control points
  var b = [];		   	   // coefficients as in De Casteljau's algorithm
  var res1 = [];		   // first curve resulting control points
  var res2 = [];		   // second curve resulting control points
  var t1 = 1 - t0;

  // multiply point with scalar factor
  var pf = function(p, f) {
    var res = [];
    for(var i = 0; i < p.length; i++) {
      res.push(f * p[i]);
    }
    return res;
  };
  // add points as vectors
  var pp = function(p1, p2) {
    var res = [];
    for(var i = 0; i < Math.min(p1.length, p2.length); i++) {
      res.push(p1[i] + p2[i]);
    }
    return res;
  };

  // set original coefficients: b[i][0] = points[i]
  for(var i = 0; i <= n; i++) {
    points[i] = (typeof points[i] == "object") ? points[i] : [points[i]];
    b.push([ points[i] ]);
  }
  // get all coefficients
  for(var j = 1; j <= n; j++) {
    for(var i = 0; i <= (n-j); i++) {
      b[i].push( pp(
        pf(b[i][j-1], t1),
        pf(b[i+1][j-1], t0)
      ));
    }
  }
  // set result: res1 & res2
  for(var j = 0; j <= n; j++) {
    res1.push(b[0][j]);
    res2.push(b[j][n-j]);
  }

  return [res1, res2];
}

function bsplitMany(points, ts) {
  var ts = ts.sort();
  var r = [points];
  var t0 = 0;
  for (let t of ts) {
    if (t <= 0 || t >= 1) continue;
    var ti = (t - t0)/(1 - t0);
    var [a, b] = bsplit(r[r.length-1], ti);
    r[r.length-1] = a;
    r.push(b);
    t0 = t;
  }
  return r;
}

function splitBezierAtTangents(c, tangents) {
  return bsplitMany(c, findBezierTangents(c, tangents).map(({t}) => t));
}

function splitSegAtTangents(seg, p, tangents) {
  if (seg.type.toLowerCase() !== "c") throw new Error("Cannot split segment: ", seg);
  var c = [p, ...group(absolutize(seg, p).values, 2)];
  var cs = splitBezierAtTangents(c, tangents);
  return cs.map(ci => ({ type: "C", values: [].concat(...ci.slice(1)) }));
}

function splitPathAtTangents(path1, tangents) {
  path1 = getPathData(path1);
  var p = [0,0]; var s = null;
  var r = [];
  for (let seg of path1) {
    if (seg.type.toLowerCase() === "c") {
      var segs = splitSegAtTangents(seg, p, tangents);
      r.push(...segs);
    } else {
      r.push(seg);
    }
    [p, s] = getNextStart(seg, p, s);
  }
  return r;
}

function splitPathAtExtremities(path1) {
  path1 = getPathData(path1);
  var p = [0,0]; var s = null;
  var r = [];
  for (let seg of path1) {
    if (seg.type.toLowerCase() === "c") {
      var segs = splitSegAtTangents(seg, p, [tangent(p, seg.values.slice(-2))]);
      r.push(...segs);
    } else {
      r.push(seg);
    }
    [p, s] = getNextStart(seg, p, s);
  }
  return r;
}

function splitPathAtTangentsOf(path1, path2) {
  return splitPathAtTangents(path1, getTangents(path2));
}

function findBezierInflections(c) {
  return calligraphy.INFLXNS(c).filter(t => 0 <= t && t <= 1);
}

function splitBezierAtInflections(c) {
  return bsplitMany(c, findBezierInflections(c));
}

function splitSegAtInflections(seg, p) {
  if (seg.type.toLowerCase() !== "c") throw new Error("Cannot split segment: ", seg);
  var c = [p, ...group(absolutize(seg, p).values, 2)];
  var cs = splitBezierAtInflections(c);
  return cs.map(ci => ({ type: "C", values: [].concat(...ci.slice(1)) }));
}

function splitPathAtInflections(path1) {
  path1 = getPathData(path1);
  var p = [0,0]; var s = null;
  var r = [];
  for (let seg of path1) {
    if (seg.type.toLowerCase() === "c") {
      var segs = splitSegAtInflections(seg, p);
      r.push(...segs);
    } else {
      r.push(seg);
    }
    [p, s] = getNextStart(seg, p, s);
  }
  return r;
}

function getTangents(path) {
  path = getPathData(path);
  var r = [];
  var p = [0,0]; var s = null;
  for (let idx in path) {
    let seg = path[idx];
    var [n, s] = getNextStart(seg, p, s);
    var a = absolutize(seg, p);
    switch (seg.type.toLowerCase()) {
      case "c":
        var ps = [p].concat(group(a.values, 2));
        r.push(Object.assign(tangent(ps[0], ps[1]), {idx, end:0, c: ps}));
        r.push(Object.assign(tangent(ps[2], ps[3]), {idx, end:1, c: ps.slice().reverse()}));
        break;
      case "l":
        r.push(tangent(p, a.values));
        break;
    }
    p = n;
  }
  return r;
}

function startingAt([x,y], path, relative=false) {
  path = getPathData(path, true);
  var origin = getOrigin(path);
  var diff = [x - +!relative*origin[0], y - +!relative*origin[1]];
  for (let seg of path) {
    if (seg.type !== seg.type.toLowerCase()) {
      if (seg.type === "H") {
        seg.values[0] += diff[0];
      } else if (seg.type === "V") {
        seg.values[0] += diff[1];
      } else {
        for (let i in seg.values) {
          seg.values[i] += diff[i % 2];
        }
      }
    }
  }
  return path;
}

function smashProduct(p1, p2) {
  var o = getOrigin(p1);
  p1 = startingAt(o, getPathData(p1));
  p2 = startingAt(o, getPathData(p2));
  var p1ps = uniqBy(getPoints(p1), v => v.toString());
  var p2ps = uniqBy(getPoints(p2), v => v.toString());
  var p1s = p2ps.map(p => startingAt(p, p1));
  var p2s = p1ps.map(p => startingAt(p, p2));
  return [p1s, p2s];
}

function uniqBy(vs, keyer) {
  const found = [];
  const r = [];
  for (const v of vs) {
    const k = keyer(v);
    if (found.indexOf(k) === -1) {
      found.push(k);
      r.push(v);
    }
  }
  return r;
}

function fillProduct(p1, p2) {
  p1 = getPathData(p1);
  p2 = getPathData(p2);
  var r = [];
  for (let section of getSections(p1)) {
    var reversed = reversePath(section);
    var o = getOrigin(section);
    var es = getEndpoints(section);
    var p = o; var s = null;
    var p2o = startingAt(o, p2);
    for (let seg of p2o) {
      var e = !!es.length;
      var [n, s, t] = getNextStart2(seg, p, s);
      if (!t && seg.type.toLowerCase() !== "m") {
        if (!e) {
          r.push([...startingAt(p, section), ...reversePath(startingAt(n, section))]);
        } else {
          r.push([
            ...reversePath(trunc([{type: "M", values: p}, seg])),
            ...startingAt(p, section).slice(1),
            ...startingAt([p[0] + es[1][0] - o[0], p[1] + es[1][1] - o[1]], [{type: "M", values: [p[0], p[1]]}, seg]).slice(1),
            ...reversePath(startingAt(n, section)).slice(1),
          ]);
        }
      }
      p = n;
    }
  }
  return r;
}

function fullFillProduct(p1, p2) {
  p2 = getPathData(p2);
  p1 = splitPathAtTangentsOf(p1, p2);
  return [...fillProduct(p1, p2), ...smashProduct(p1, p2)[1]];
}

</script>

<script>
  // node -i -e 'var c = require("./calligraphy.js")'
  (function() {
  class Vec extends Array {
    constructor(v) {
      super();
      Object.assign(this, v);
    }
    map(f) {return new Vec(super.map(f));}
    slice(...args) {return new Vec(super.slice(...args));}
    toString() {
      return "⟨" + super.join(", ") + "⟩"
    }
  }
  class Curve extends Array {
    constructor(v) {
      super();
      Object.assign(this, v);
    }
    map(f) {return new Curve(super.map(f));}
    slice(...args) {return new Curve(super.slice(...args));}
    toString() {
      return '<' + this.join(" ") + '>';
    }
  }
  class Poly extends Array {
    constructor(v) {
      super();
      Object.assign(this, v);
    }
    map(f) {return new Poly(super.map(f));}
    slice(...args) {return new Poly(super.slice(...args));}
    toString() {
      if (!this.length) return "0";
      Poly.prime += 1;
      let cs = this.map(v => v.toString());
      Poly.prime -= 1;
      let vars = ["X", "Y", "Z"];
      return cs.reduce((r, v, i) => v ? (r[0] !== "0" || r[1] === "." ? r + " + " : "") + (v !== "1" ? (v.includes("+") ? "(" + v + ")" : v) + "*" : "")+(vars[Poly.prime]||"t_"+Poly.prime)+"^"+i : r);
    }
  }
  Poly.prime = 0;
  const curveD = ps => new Curve(ps).map(p => new Vec(p));

  const construct_like = (d, cs) => {
    if (!cs.length) return d;
    var p = cs[0].__proto__;
    if (p === Array.prototype || p === Number.prototype) {
      return d;
    }
    for (let c of cs) {
      if (p !== c.__proto__) {
        return d;
      }
    }
    return new p.constructor(d);
  };

  const zipWith = (f,d1,d2) => (cs1, cs2) => {
    var r = [];
    for (let i = 0; i < cs1.length || i < cs2.length; i += 1) {
      var v1 = i in cs1 ? cs1[i] : d1;
      var v2 = i in cs2 ? cs2[i] : d2;
      r.push(f(v1, v2));
    }
    return construct_like(r, [cs1, cs2]);
  };

  const map = f => vs => vs.map(f);

  const compose = (...fs) => i => {
    var o = i;
    for (let f of fs.reverse()) {
      o = f(o);
    }
    return o;
  };

  const lift2 = (op, annihilate) => (vs1, vs2) => {
    if (vs2 === 0) return vs1;
    if (vs1 === 0) return vs2;
    if (typeof vs1 === 'number' && typeof vs2 === 'number')
      return op(vs1,vs2);
    return zipWith(lift2(op), 0, 0)(vs1, vs2);
  };
  const lift1 = op => (vs1) => {
    if (typeof vs1 === 'number')
      return op(vs1);
    return vs1.map(lift1(op));
  };
  const summate = vs1 => {
    if (typeof vs1 === 'number')
      return vs1;
    if (!vs1.length) return 0;
    return vs1.map(sum).reduce((a, b) => a+b);
  };
  const sum = vs1 => {
    if (!vs1.length) return 0;
    return vs1.reduce(add);
  };
  const add = lift2((v1,v2) => v1+v2);
  const sub = (vs1, vs2) => add(vs1, mul(-1, vs2));
  const mul = (c,cs) => lift1(v => c*v)(cs);
  const muldot = (cs, css) => sum(zipWith((z, zs) => mul(z, zs))(cs, css));
  const dot = (vs1, vs2) => summate(lift2((v1,v2) => mul(v1,v2), true)(vs1, vs2));
  const dmul = (cs1, cs2) => cs1.map(c1 => mul(c1, cs2));
  const pmul = (cs1, cs2) => sum(cs1.map((c1, i) => raise(i)(mul(c1, cs2))));

  const transpose = vss => {
    var rss = [];
    for (let i in vss) {
      for (let j in vss[i]) {
        rss[j] = rss[j] || construct_like([], [vss]);
        rss[j][i] = vss[i][j];
      }
    }
    return construct_like(rss, [...vss]);
  };
  const transposed = f => compose(map(f), transpose);
  const transposing = f => compose(transpose, map(f), transpose);
  const bases = dim => {
    var zeros = [];
    for (let i = 0; i < dim; i += 1) zeros.push(0);
    return zeros.map((_, i) => new Vec(zeros.map((_, j) => +(i == j))));
  };

  const value = cs => t => cs.reduce((r, c, i) => r + c * Math.pow(t, i), 0);
  const values = vcs => t => vcs.map(cs => value(cs)(t));
  const EVAL = cvs => t => transposed(cs => value(cs)(t))(cvs);
  const deriv = cs => cs.map((v, i) => i * v).slice(1);
  const DERIV = transposing(deriv);

  const raise = n => n <= 0 ? (cs => cs) : cs => raise(n-1)(N(cs));
  const N = cs => construct_like([0].concat(cs), [cs]);
  const Y = cs => sub(cs, N(cs));

  const b = ps => {
    if (typeof ps === 'number') {
      return new Vec(bases(ps)).map(b);
    }
    // c.b(ps) === c.muldot(ps, c.b(ps.length))
    if (ps.length <= 1) return new Poly(ps);
    return add(Y(b(ps.slice(0, -1))), N(b(ps.slice(1))));
  };
  const B = transposing(b);
  const curvature = (XX,YY,XXX,YYY) => {
    return (XX*YYY - YY*XXX)/Math.pow(XX*XX + YY*YY, 1.5);
  };
  const Bcurvature0 = ([b0,b1,b2,_]) => {
    let b21 = [b2[0]-b1[0],b2[1]-b1[1]];
    let d0 = [b1[0]-b0[0],b1[1]-b0[1]];
    let d0xb21 = d0[0]*b21[1] - d0[1]*b21[0];
    let delta = Math.sqrt(d0[0]*d0[0] + d0[1]*d0[1]);
    return (2/3)*d0xb21/Math.pow(delta, 3);
  };
  const Bcurvature1 = ([b0,b1,b2,b3]) => -Bcurvature0([b3,b2,b1,b0]);
  const Bcurvature = C => t => {
    let [numer, denom] = Bcurvature_polys(C).map(p => value(p)(t));
    return numer/Math.pow(denom, 1.5);
  };
  const Bcurvature_polys = C => {
    let CC = DERIV(B(C));
    let XX = transpose(CC)[0];
    let YY = transpose(CC)[1];
    let CCC = DERIV(CC);
    let XXX = transpose(CCC)[0];
    let YYY = transpose(CCC)[1];
    return [sub(pmul(XX,YYY), pmul(YY,XXX)), add(pmul(XX,XX), pmul(YY,YY))];
  };
  const norm2 = v => v[0]*v[0] + v[1]*v[1];
  const norm = v => Math.sqrt(norm2(v));
  const normalize = v => {let n = norm(v); return [v[0]/n, v[1]/n]};
  const cross2 = (v1,v2) => v1[0]*v2[1] - v1[1]*v2[0];
  const solve_quartic = cs => {
    let rs = quartic(cs.slice().reverse());
    var ep = 1e-9;
    let rs2 = rs.filter(r => Math.abs(r.im) < ep).map(r => r.re);
    return rs2;
  };
  const fit_checks = (f0,f1,d0,d1,k0,k1) => {
    let ep = 1e-8;
    let matches = (ki,ko) =>
      (Math.sign(ki) === Math.sign(ko)) || (Math.abs(ki) < ep && Math.abs(ko) < ep);
    let rs = fit(f0,f1,d0,d1,k0,k1);
    let rrs = rs.filter(r => matches(Bcurvature0(r), k0) && matches(Bcurvature1(r), k1));
    return rrs.length ? rrs : rs;
  };
  const fit_check = (f0,f1,d0,d1,k0,k1) => {
    let rs = fit_checks(f0,f1,d0,d1,k0,k1);
    if (rs.length <= 1) return rs[0];
    let score = ([b0,b1,b2,b3]) => {
      let d0 = sub(b1, b0);
      let d1 = sub(b3, b2);
      return norm2(d0) + norm2(d1);
    };
    return rs.sort((a, b) => score(a) - score(b))[0];
  };
  const fit = (f0,f1,d0,d1,k0,k1) => {
    d0 = normalize(d0); d1 = normalize(d1);
    let d0xd1 = cross2(d0, d1);
    let a = sub(f1, f0);
    let d0xa = cross2(d0, a);
    let axd1 = cross2(a, d1);
    let δs;
    if (d0xd1 === 0) {
      δs = [Math.sqrt((2/3)*(d0xa)/k0), Math.sqrt((2/3)*(axd1)/k1)];
    } else {
      let ep = 1e-9;
      if (Math.abs(axd1) < ep || Math.abs(d0xa) < ep) {
        throw new Error("parallel " + [a, axd1, d0xa]);
      }
      // https://herbie.uwplse.org/
      /**/
      let ρs;
      //let R0 = (3/2)*(k0*axd1*axd1)/(d0xa*d0xd1*d0xd1);
      let R0 = 1.5 * (((axd1 / d0xa) / (d0xd1 / k0)) / (d0xd1 / axd1));
      //let R1 = (3/2)*(k1*d0xa*d0xa)/(axd1*d0xd1*d0xd1);
      let R1 = 1.5 * (((d0xa / axd1) / (d0xd1 / k1)) / (d0xd1 / d0xa));
      if (!Number.isFinite(R0) || !Number.isFinite(R1)) {
        throw new Error("NaNaNaNaNa " + [R0,R1,k0,k1] + "; " + [a, axd1, d0xa]);
      }
      let c0 = [1-R1, -1, 2*R1*R0, 0, -R1*R0*R0];
      let c1 = [1-R0, -1, 2*R0*R1, 0, -R0*R1*R1];
      let ρ0s = solve_quartic(c0);
      let ρ1s = solve_quartic(c1);
      ρs = [
        ρ0s.map(ρ0 => [ρ0, 1 - R0*ρ0*ρ0]),
        ρ1s.map(ρ1 => [1 - R1*ρ1*ρ1, ρ1]),
        ρ0s.flatMap(ρ0 => ρ1s.map(ρ1 => [ρ0, ρ1])),
      ][1].filter(p => p.every(Number.isFinite));
      if (!ρs.length) {
        throw new Error("no quartic solutions " + [c0, ρ0s, c1, ρ1s].join("; "));
      }
      δs = ρs.map(([ρ0,ρ1]) => [ρ0 * axd1 / d0xd1, ρ1 * d0xa / d0xd1]);
      let δδs = δs;
      δs = δs.filter(([δ0,δ1]) => δ0 >= 0 && δ1 >= 0);
      if (!δs.length && δδs.length) {
        throw new Error("filtered out " + δδs.join("; "));
        //δs = δδs;
      }
    }
    return δs.map(([δ0,δ1]) => [f0,add(f0, mul(δ0, d0)),sub(f1, mul(δ1, d1)),f1]);
  };
  const fit_existing = P => {
    return fit_check(P[0], P[3], sub(P[1], P[0]), sub(P[3], P[2]), Bcurvature0(P), Bcurvature1(P));
  };
  const fit_existing_score = P => {
    let Q = fit_existing(P);
    return {
      P, Q,
      P0: Bcurvature0(P), P1: Bcurvature1(P),
      Q0: Bcurvature0(Q), Q1: Bcurvature1(Q),
    };
  }

  const degree = cs => {
    var d = 0;
    for (let i in cs) {
      if (cs[i]) d = +i;
    }
    return d;
  };

  const solve = eq => {
    var d = degree(eq);
    if (d === 0) {
      if (eq[0]) return [];
      return null; // everything is a solution
    } else if (d === 1) {
      return [-eq[0]/eq[1]];
    } else if (d === 2) {
      var disc = eq[1]*eq[1] - 4*eq[2]*eq[0];
      var ep = 1e-10;
      if (Math.abs(disc) < ep) disc = 0;
      if (disc < 0) return [];
      if (disc === 0) return [-eq[1]/eq[2]/2];
      var r = Math.sqrt(disc);
      return [+r,-r].map(sr => (-eq[1] + sr)/eq[2]/2);
    }
    throw new Error("Cannot solve equation of degree " + d);
  };
  const solve_norm = eq => solve_norm_sgn(eq)[0];
  const solve_norm_sgn = eq => {
    var sols = solve(eq);
    if (sols.length === 0) {
      var disc = eq[1]*eq[1] - 4*eq[2]*eq[0];
      throw new Error("No solutions to " + eq + " with disc = " + disc);
    }
    var ep = 1e-5;
    var norm_sols = sols.filter(t => 0-ep <= t && t <= 1+ep).map(t => Math.max(0, Math.min(1, t)));
    if (norm_sols.length === 1) {
      return [norm_sols[0], [+1, -1][sols.findIndex(t => t == norm_sols[0])]];
    }
    throw new Error("Solutions were " + sols + " (to " + eq + ")");
  };
  const solve_deriv = (eq, dq) => {
    if (degree(eq) > 2) throw Error(eq);
    let q = solve_norm(eq);
    if ((2*eq[2]*q + eq[1]) === 0) {
      console.error("DISASTER", {eq,dq,q});
      let rs = solve_deriv_(eq, dq);
      console.error("DISASTER", {eq,dq,q,rs});
      return rs[4];
    }
    return -(dq[2]*q*q + dq[1]*q + dq[0])/(2*eq[2]*q + eq[1]);
  };
  const solve_deriv2 = (eq, dq, cq) => {
    if (degree(eq) > 2) throw Error(eq);
    let q = solve_norm(eq);
    let qq = solve_deriv(eq, dq);
    return (-2*eq[2]*qq*qq + cq[2]*q*q + cq[1]*q + cq[0])/(2*eq[2]*q + eq[1]);
  };
  const solve_deriv_ = (eq, dq) => {
    return [ -1e-3, -1e-4, -1e-5, -1e-6, -1e-7, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3 ].map(dp => {
      return (solve_norm(eq) - solve_norm(add(mul(dp, dq), eq)))/dp;
    });
  };

  const T_THINGY = (P,Q) => {
    var PP = DERIV(B(P));
    var QQ = transpose(DERIV(B(Q)));
    return PP.map(cd => {
      return sub(mul(cd[0], QQ[1]), mul(cd[1], QQ[0]));
    });
  };
  // PP : p :: QQ : q
  // QQ_x(q)*PP_y(p) - QQ_y(q)*PP_x(p) = 0
  const T_IMPLICIT = (P,Q) => {
    var PP = transpose(DERIV(B(P)));
    var QQ = transpose(DERIV(B(Q)));
    return sub(dmul(QQ[1], PP[0]), dmul(QQ[0], PP[1]));
  };
  const T_SOL = (P,Q) => p => solve_norm(values(T_IMPLICIT(P,Q))(p));
  const COMP = (P,Q) => p => add(EVAL(B(P))(p), EVAL(B(Q))(T_SOL(P,Q)(p)));
  const T_DERIV = (P,Q) => p => {
    // multivariate polynomial in q,p
    let EQ = T_IMPLICIT(P,Q);
    // quadratic equation for q at p
    let eq = values(EQ)(p);
    // derivative of eq
    let dq = values(EQ.map(deriv))(p);
    return solve_deriv(eq, dq);
  };
  // c.T_DERIVS(c.ex.P, c.ex.Q)(0.36657)
  const T_DERIVS = (P,Q) => p => {
    var q = T_SOL(P,Q)(p);
    return [ -1e-3, -1e-4, -1e-5, -1e-6, -1e-7, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3 ].map(dp => {
      return (T_SOL(P,Q)(dp+p) - q)/dp;
    });
  };
  const PQ_CURVATURE = (P,Q) => {
    let PP = DERIV(B(P));
    let PPE = EVAL(PP);
    let QQ = DERIV(B(Q));
    let QQE = EVAL(QQ);
    let PPPE = EVAL(DERIV(PP));
    let QQQE = EVAL(DERIV(QQ));
    let TT = T_DERIV(P,Q);
    return (p,q=undefined) => {
      if (q === undefined) q = T_SOL(P,Q)(p);
      let PPp = PPE(p);
      let QQq = QQE(q);
      let PPPp = PPPE(p);
      let QQQq = QQQE(q);
      let R = TT(p);
      let XX = PPp[0] + QQq[0]*R;
      let YY = PPp[1] + QQq[1]*R;
      let XXXYY = PPPp[0]*PPp[1] + PPPp[0]*QQq[1]*R + QQQq[0]*R*R*PPp[1] + QQQq[0]*QQq[1]*R*R*R;
      let YYYXX = PPPp[1]*PPp[0] + PPPp[1]*QQq[0]*R + QQQq[1]*R*R*PPp[0] + QQQq[1]*QQq[0]*R*R*R;
      let speed = Math.pow(XX*XX + YY*YY, 3/2);
      let k = (XXXYY - YYYXX)/speed;
      if (!Number.isFinite(k)) {
        console.error("NaN", {k,R,speed,p,q,P,Q});
        throw new Error("NaN");
      }
      return k;
      /*
      (x''y' - y''x')/((x'2 + y'2)^3/2)
      */
    };
  };
  const T_VERIFY = (P,Q) => (p, q) => value(values(T_IMPLICIT(P,Q))(p))(q === undefined ? T_SOL(P,Q)(p) : q);
  const T_VERIFY2 = (P,Q) => (p, q) => value(values(T_IMPLICIT(Q,P))(q === undefined ? T_SOL(P,Q)(p) : q))(p);
  const T_VERIFYT = (P,Q) => (p, q) => {
    if (p === undefined) q = T_SOL(P,Q)(p);
    var PPp = EVAL(DERIV(B(P)))(p);
    var TPp = PPp[1]/PPp[0];
    var QQq = EVAL(DERIV(B(Q)))(q);
    var TQq = QQq[1]/QQq[0];
    return [ TPp, TQq, TPp - TQq ];
  };
  const T_VERIFY3 = (P,Q) => (p, q) => {
    if (q === undefined) q = T_SOL(P,Q)(p);
    return [ T_VERIFY, T_VERIFY2, T_VERIFYT ].map(f => f(P,Q)(p, q));
  };

  function composite(P,Q) {
    return compositeI(P,Q)[1];
  }

  function compositeI(P,Q) {
    let P0 = P[0];
    let P1 = P[3];
    let Qt = EVAL(B(Q));
    let q = T_SOL(P,Q);
    let q0 = q(0);
    let Q0 = Qt(q0);
    let q1 = q(1);
    let Q1 = Qt(q1);
    const f0 = add(P0, Q0);
    const f1 = add(P1, Q1);
    const d0 = sub(P[1], P[0]);
    const d1 = sub(P[3], P[2]);
    const k = PQ_CURVATURE(P,Q);
    const k0 = k(0,q0);
    const k1 = k(1,q1);
    return [q0, fit_check(f0,f1,d0,d1,-k0,-k1), q1];
  }

  function INFLXNS(P) {
    let PP = transpose(DERIV(B(P)));
    let PPP = transpose(DERIV(DERIV(B(P))));
    let EQ = sub(pmul(PPP[0], PP[1]), pmul(PPP[1], PP[0]));
    let rs = solve(EQ);
    return rs;
  }

  //const T_DERIV = ;

  window.calligraphy = {
    Vec, Poly, Curve,
    zipWith, add, sub, mul, compose, transpose, dot, lift1, lift2, map, value, deriv, N, Y, b, B, bases,
    muldot, summate, sum, DERIV, EVAL, values, dmul,
    transposing, transposed,
    solve_norm, solve, solve_deriv, solve_deriv_,
    T_IMPLICIT, T_SOL, T_VERIFY, T_VERIFY2, T_VERIFYT, T_VERIFY3,
    T_DERIV, T_DERIVS, COMP, INFLXNS,
    curvature, Bcurvature, Bcurvature_polys, Bcurvature0, Bcurvature1,
    composite, compositeI,
    fit, fit_check, fit_existing, fit_existing_score,
    raise, pmul, norm, normalize,
    ex: (function() {
      let r = {};
      try {
        r.P = curveD([[7,6],[4,2],[1,2],[5,1]]);
        r.PP = transpose(DERIV(B(r.P)));
        r.Q = curveD([[1,3],[4,5],[6,7],[1,3]]);
        r.QQ = transpose(DERIV(B(r.Q)));
        r.t = 0.4;
        r.tt = T_SOL(r.P, r.Q)(r.t);
      } catch (e) {
        console.log(e);
      }
      return r;
    })(),
  };
  })();
</script>




<script>
  function QuadSD_ak1(NN, u, v, p, q, iPar) {

    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b

    // iPar is a dummy variable for passing in the two parameters--a and b--by reference

    q[0] = iPar.b = p[0];
    q[1] = iPar.a = -(u * iPar.b) + p[1];

    for (var i = 2; i < NN; i++) {
      q[i] = -(u * iPar.a + v * iPar.b) + p[i];
      iPar.b = iPar.a;
      iPar.a = q[i];
    } // End for i

    return;
  } // End QuadSD_ak1

  function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {

    // This routine calculates scalar quantities used to compute the next K polynomial and
    // new estimates of the quadratic coefficients.

    // calcSC - integer variable set here indicating how the calculations are normalized
    //      to avoid overflow.

    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h--by reference

    var sdPar = new Object(); // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference

    var dumFlag = 3; // TYPE = 3 indicates the quadratic is almost a factor of K

    // Synthetic division of K by the quadratic 1, u, v
    sdPar.b = sdPar.a = 0.0;
    QuadSD_ak1(N, u, v, K, qk, sdPar);
    iPar.c = sdPar.a;
    iPar.d = sdPar.b;

    if (Math.abs(iPar.c) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 1])) {
      if (Math.abs(iPar.d) <= 100.0 * DBL_EPSILON * Math.abs(K[N - 2])) return dumFlag;
    } // End if (abs(c) <= (100.0*DBL_EPSILON*abs(K[N - 1])))

    iPar.h = v * b;
    if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {
      dumFlag = 2; // TYPE = 2 indicates that all formulas are divided by d
      iPar.e = a / iPar.d;
      iPar.f = iPar.c / iPar.d;
      iPar.g = u * b;
      iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);
      iPar.a1 = -a + iPar.f * b;
      iPar.a7 = iPar.h + (iPar.f + u) * a;
    } // End if(abs(d) >= abs(c))
    else {
        dumFlag = 1; // TYPE = 1 indicates that all formulas are divided by c;
        iPar.e = a / iPar.c;
        iPar.f = iPar.d / iPar.c;
        iPar.g = iPar.e * u;
        iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;
        iPar.a1 = -(a * (iPar.d / iPar.c)) + b;
        iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;
      } // End else

    return dumFlag;
  } // End calcSC_ak1

  function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {

    // Computes the next K polynomials using the scalars computed in calcSC_ak1

    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7

    var temp;

    if (tFlag == 3) {// Use unscaled form of the recurrence
      K[1] = K[0] = 0.0;

      for (var i = 2; i < N; i++) K[i] = qk[i - 2];

      return;
    } // End if (tFlag == 3)

    temp = tFlag == 1 ? b : a;

    if (Math.abs(iPar.a1) > 10.0 * DBL_EPSILON * Math.abs(temp)) {
      // Use scaled form of the recurrence

      iPar.a7 /= iPar.a1;
      iPar.a3 /= iPar.a1;
      K[0] = qp[0];
      K[1] = -(qp[0] * iPar.a7) + qp[1];

      for (var i = 2; i < N; i++) K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];

    } // End if (abs(a1) > (10.0*DBL_EPSILON*abs(temp)))
    else {
        // If a1 is nearly zero, then use a special form of the recurrence

        K[0] = 0.0;
        K[1] = -(qp[0] * iPar.a7);

        for (var i = 2; i < N; i++) K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;
      } // End else

    return;
  } // End nextK_ak1

  function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {
    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1

    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference
    // iPar.a = uu, iPar.b = vv

    var a4, a5, b1, b2, c1, c2, c3, c4, temp;

    iPar.b = iPar.a = 0.0; // The quadratic is zeroed

    if (tFlag != 3) {

      if (tFlag != 2) {
        a4 = a + u * b + h * f;
        a5 = c + (u + v * f) * d;
      } // End if (tFlag != 2)
      else {// else tFlag == 2
          a4 = (a + g) * f + h;
          a5 = (f + u) * c + v * d;
        } // End else tFlag == 2

      // Evaluate new quadratic coefficients

      b1 = -(K[N - 1] / p[N]);
      b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];
      c1 = v * b2 * a1;
      c2 = b1 * a7;
      c3 = b1 * b1 * a3;
      c4 = -(c2 + c3) + c1;
      temp = -c4 + a5 + b1 * a4;
      if (temp != 0.0) {
        iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;
        iPar.b = v * (1.0 + c4 / temp);
      } // End if (temp != 0)

    } // End if (tFlag != 3)

    return;
  } // End newest_ak1

  function Quad_ak1(a, b1, c, iPar) {
    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c
    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the
    // zeros are real and both zeros are complex. The smaller real zero is found directly from
    // the product of the zeros c/a.

    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference

    var b, d, e;

    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;

    if (a == 0) {
      iPar.sr = b1 != 0 ? -(c / b1) : iPar.sr;
      return;
    } // End if (a == 0))

    if (c == 0) {
      iPar.lr = -(b1 / a);
      return;
    } // End if (c == 0)

    // Compute discriminant avoiding overflow

    b = b1 / 2.0;
    if (Math.abs(b) < Math.abs(c)) {
      e = c >= 0 ? a : -a;
      e = -e + b * (b / Math.abs(c));
      d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));
    } // End if (Math.abs(b) < Math.abs(c))
    else {// Else (abs(b) >= abs(c))
        e = -(a / b * (c / b)) + 1.0;
        d = Math.sqrt(Math.abs(e)) * Math.abs(b);
      } // End else (abs(b) >= abs(c))

    if (e >= 0) {
      // Real zeros

      d = b >= 0 ? -d : d;
      iPar.lr = (-b + d) / a;
      iPar.sr = iPar.lr != 0 ? c / iPar.lr / a : iPar.sr;
    } // End if (e >= 0)
    else {// Else (e < 0)
        // Complex conjugate zeros

        iPar.lr = iPar.sr = -(b / a);
        iPar.si = Math.abs(d / a);
        iPar.li = -iPar.si;
      } // End else (e < 0)

    return;
  } // End of Quad_ak1

  function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {

    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the
    // zeros are equimodular or nearly so.

    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference
    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference
    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h--in by reference

    var qPar = new Object(); // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference

    var ee, mp, omp, relstp, t, u, ui, v, vi, zm;
    var i,j = 0,tFlag,triedFlag = 0; // Integer variables

    iPar.NZ = 0; // Number of zeros found
    u = uu; // uu and vv are coefficients of the starting quadratic
    v = vv;

    do {
      qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;
      Quad_ak1(1.0, u, v, qPar);
      iPar.szr = qPar.sr;
      iPar.szi = qPar.si;
      iPar.lzr = qPar.lr;
      iPar.lzi = qPar.li;

      // Return if roots of the quadratic are real and not close to multiple or nearly
      // equal and of opposite sign.

      if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr)) break;

      // Evaluate polynomial by quadratic synthetic division

      QuadSD_ak1(NN, u, v, p, qp, sdPar);

      mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b);

      // Compute a rigorous bound on the rounding error in evaluating p

      zm = Math.sqrt(Math.abs(v));
      ee = 2.0 * Math.abs(qp[0]);
      t = -(iPar.szr * sdPar.b);

      for (i = 1; i < N; i++) ee = ee * zm + Math.abs(qp[i]);

      ee = ee * zm + Math.abs(t + sdPar.a);

      ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON;

      // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound

      if (mp <= 20.0 * ee) {
        iPar.NZ = 2;
        break;
      } // End if (mp <= 20.0*ee)

      j++;

      // Stop iteration after 20 steps
      if (j > 20) break;

      if (j >= 2) {
        if (relstp <= 0.01 && mp >= omp && !triedFlag) {
          // A cluster appears to be stalling the convergence. Five fixed shift
          // steps are taken with a u, v close to the cluster.

          relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);

          u -= u * relstp;
          v += v * relstp;

          QuadSD_ak1(NN, u, v, p, qp, sdPar);

          for (i = 0; i < 5; i++) {
            tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
            nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
          } // End for i

          triedFlag = 1;
          j = 0;

        } // End if ((relstp <= 0.01) && (mp >= omp) && (!triedFlag))

      } // End if (j >= 2)

      omp = mp;

      // Calculate next K polynomial and new u and v

      tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
      nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
      tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
      newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);
      ui = sdPar.a;
      vi = sdPar.b;

      // If vi is zero, the iteration is not converging
      if (vi != 0) {
        relstp = Math.abs((-v + vi) / vi);
        u = ui;
        v = vi;
      } // End if (vi != 0)
    } while (vi != 0); // End do-while loop

    return;
  } //End QuadIT_ak1

  function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {

    // Variable-shift H-polynomial iteration for a real zero

    // sss  - starting iterate = sdPar.a
    // NZ   - number of zeros found = iPar.NZ
    // dumFlag  - flag to indicate a pair of zeros near real axis, returned to iFlag

    var ee, kv, mp, ms, omp, pv, s, t;
    var dumFlag,i,j,nm1 = N - 1; // Integer variables

    iPar.NZ = j = dumFlag = 0;
    s = sdPar.a;

    for (;;) {
      qp[0] = pv = p[0];

      // Evaluate p at s
      for (i = 1; i < NN; i++) qp[i] = pv = pv * s + p[i];

      mp = Math.abs(pv);

      // Compute a rigorous bound on the error in evaluating p

      ms = Math.abs(s);
      ee = 0.5 * Math.abs(qp[0]);
      for (i = 1; i < NN; i++) ee = ee * ms + Math.abs(qp[i]);

      // Iteration has converged sufficiently if the polynomial value is less than
      // 20 times this bound

      if (mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {
        iPar.NZ = 1;
        iPar.szr = s;
        iPar.szi = 0.0;
        break;
      } // End if (mp <= 20.0*DBL_EPSILON*(2.0*ee - mp))

      j++;

      // Stop iteration after 10 steps
      if (j > 10) break;

      if (j >= 2) {
        if (Math.abs(t) <= 0.001 * Math.abs(-t + s) && mp > omp) {
          // A cluster of zeros near the real axis has been encountered.
          // Return with iFlag set to initiate a quadratic iteration.

          dumFlag = 1;
          iPar.a = s;
          break;
        } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))

      } //End if (j >= 2)

      // Return if the polynomial value has increased significantly

      omp = mp;

      // Compute t, the next polynomial and the new iterate
      qk[0] = kv = K[0];
      for (i = 1; i < N; i++) qk[i] = kv = kv * s + K[i];

      if (Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {
        // Use the scaled form of the recurrence if the value of K at s is non-zero
        t = -(pv / kv);
        K[0] = qp[0];
        for (i = 1; i < N; i++) K[i] = t * qk[i - 1] + qp[i];
      } // End if (fabs(kv) > fabs(K[nm1])*10.0*DBL_EPSILON)
      else {// else (fabs(kv) <= fabs(K[nm1])*10.0*DBL_EPSILON)
          // Use unscaled form
          K[0] = 0.0;
          for (i = 1; i < N; i++) K[i] = qk[i - 1];
        } // End else (fabs(kv) <= fabs(K[nm1])*10.0*DBL_EPSILON)

      kv = K[0];
      for (i = 1; i < N; i++) kv = kv * s + K[i];

      t = Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON ? -(pv / kv) : 0.0;

      s += t;

    } // End infinite for loop

    return dumFlag;
  } // End RealIT_ak1

  function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, bnd, K, N, p, NN, qp, iPar) {

    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or
    // quadratic case. Initiates one of the variable shift iterations and returns with the
    // number of zeros found.

    // L2 limit of fixed shift steps

    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference
    // NZ number of zeros found

    var sdPar = new Object(); // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference
    var calcPar = new Object();
    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h--into calcSC_ak1 by reference

    var qk = new Array(MDP1);
    var svk = new Array(MDP1);

    var a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, u, ui, v, vi, vv;

    var fflag, i, iFlag, j, spass, stry, tFlag, vpass, vtry; // Integer variables

    iPar.NZ = 0;
    betav = betas = 0.25;
    u = -(2.0 * sr);
    oss = sr;
    ovv = v = bnd;

    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = sdPar.b = sdPar.a = 0.0;

    //Evaluate polynomial by synthetic division
    QuadSD_ak1(NN, u, v, p, qp, sdPar);

    a = sdPar.a;
    b = sdPar.b;

    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);

    for (j = 0; j < L2; j++) {

      // Calculate next K polynomial and estimate v
      nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);
      tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);

      // Use sdPar for passing in uu and vv instead of defining a brand-new variable.
      // sdPar.a = ui, sdPar.b = vi

      newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);

      ui = sdPar.a;
      vv = vi = sdPar.b;

      // Estimate s

      ss = K[N - 1] != 0.0 ? -(p[N] / K[N - 1]) : 0.0;

      ts = tv = 1.0;

      if (j != 0 && tFlag != 3) {

        // Compute relative measures of convergence of s and v sequences

        tv = vv != 0.0 ? Math.abs((vv - ovv) / vv) : tv;
        ts = ss != 0.0 ? Math.abs((ss - oss) / ss) : ts;

        // If decreasing, multiply the two most recent convergence measures

        tvv = tv < otv ? tv * otv : 1.0;
        tss = ts < ots ? ts * ots : 1.0;

        // Compare with convergence criteria

        vpass = tvv < betav ? 1 : 0;
        spass = tss < betas ? 1 : 0;

        if (spass || vpass) {

          // At least one sequence has passed the convergence test.
          // Store variables before iterating

          for (i = 0; i < N; i++) svk[i] = K[i];

          s = ss;

          // Choose iteration according to the fastest converging sequence

          stry = vtry = 0;
          fflag = 1;

          do {

            iFlag = 1; // Begin each loop by assuming RealIT will be called UNLESS iFlag changed below

            if (fflag && (fflag = 0) == 0 && spass && (!vpass || tss < tvv)) {
              ; // Do nothing. Provides a quick "short circuit".
            } // End if (fflag)
            else
              {// else !fflag

                QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);

                a = sdPar.a;
                b = sdPar.b;

                if (iPar.NZ > 0) return;

                // Quadratic iteration has failed. Flag that it has been tried and decrease the
                // convergence criterion

                vtry = 1;
                betav *= 0.25;

                // Try linear iteration if it has not been tried and the s sequence is converging
                if (stry || !spass) {
                  iFlag = 0;
                } // End if (stry || (!spass))
                else {
                    for (i = 0; i < N; i++) K[i] = svk[i];
                  } // End if (stry || !spass)

              } // End else !fflag

            if (iFlag != 0) {

              // Use sdPar for passing in s instead of defining a brand-new variable.
              // sdPar.a = s

              sdPar.a = s;
              iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);
              s = sdPar.a;

              if (iPar.NZ > 0) return;

              // Linear iteration has failed. Flag that it has been tried and decrease the
              // convergence criterion

              stry = 1;
              betas *= 0.25;

              if (iFlag != 0) {

                // If linear iteration signals an almost double real zero, attempt quadratic iteration

                ui = -(s + s);
                vi = s * s;
                continue;

              } // End if (iFlag != 0)
            } // End if (iFlag != 0)

            // Restore variables
            for (i = 0; i < N; i++) K[i] = svk[i];

            // Try quadratic iteration if it has not been tried and the v sequence is converging

          } while (vpass && !vtry); // End do-while loop

          // Re-compute qp and scalar values to continue the second stage

          QuadSD_ak1(NN, u, v, p, qp, sdPar);
          a = sdPar.a;
          b = sdPar.b;

          tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);

        } // End if ((spass) || (vpass))

      } // End if ((j != 0) && (tFlag != 3))

      ovv = vv;
      oss = ss;
      otv = tv;
      ots = ts;
    } // End for j

    return;
  } // End of Fxshfr_ak1

  function rpSolve(degPar, p, zeror, zeroi) {

    var N = degPar.Degree;
    var RADFAC = 3.14159265358979323846 / 180; // Degrees-to-radians conversion factor = PI/180
    var CPP_FLT_MIN = 1.17549435082229e-038; // Value of FLT_MIN from C++
    var CPP_FLT_MAX = 3.40282346638529e+038; // Value of FLT_MAX from C++
    var LB2 = Math.LN2; // Dummy variable to avoid re-calculating this value in loop below

    var MDP1 = degPar.Degree + 1;
    var K = new Array(MDP1);
    var pt = new Array(MDP1);
    var qp = new Array(MDP1);
    var temp = new Array(MDP1);

    var qPar = new Object(); // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference
    var Fxshfr_Par = new Object(); // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);

    var bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm;
    var aa, bb, cc, sr, t, xxx;

    var j, jj, l, NM1, NN, zerok; // Integer variables

    // Calculate the machine epsilon and store in the variable DBL_EPSILON.
    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block

    aa = 1.0;
    do {
      DBL_EPSILON = aa;
      aa /= 2;
      bb = 1.0 + aa;
    } while (bb > 1.0);

    var LO = CPP_FLT_MIN / DBL_EPSILON;
    var cosr = Math.cos(94.0 * RADFAC); // = -0.069756474
    var sinr = Math.sin(94.0 * RADFAC); // = 0.99756405
    var xx = Math.sqrt(0.5); // = 0.70710678
    var yy = -xx;

    Fxshfr_Par.NZ = j = 0;
    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;

    // Remove zeros at the origin, if any
    while (p[N] == 0) {
      zeror[j] = zeroi[j] = 0;
      N--;
      j++;
    } // End while (p[N] == 0)

    NN = N + 1;

    // ============================ Begin Main Loop ===================================

    while (N >= 1) {// Main loop
      // Start the algorithm for one zero
      if (N <= 2) {
        // Calculate the final zero or pair of zeros
        if (N < 2) {
          zeror[degPar.Degree - 1] = -(p[1] / p[0]);
          zeroi[degPar.Degree - 1] = 0;
        } // End if (N < 2)
        else {// else N == 2
            qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;
            Quad_ak1(p[0], p[1], p[2], qPar);
            zeror[degPar.Degree - 2] = qPar.sr;
            zeroi[degPar.Degree - 2] = qPar.si;
            zeror[degPar.Degree - 1] = qPar.lr;
            zeroi[degPar.Degree - 1] = qPar.li;
          } // End else N == 2
        break;
      } // End if (N <= 2)

      // Find the largest and smallest moduli of the coefficients
      moduli_max = 0.0;
      moduli_min = CPP_FLT_MAX;

      for (i = 0; i < NN; i++) {
        x = Math.abs(p[i]);
        if (x > moduli_max) moduli_max = x;
        if (x != 0 && x < moduli_min) moduli_min = x;
      } // End for i

      // Scale if there are large or very small coefficients
      // Computes a scale factor to multiply the coefficients of the polynomial. The scaling
      // is done to avoid overflow and to avoid undetected underflow interfering with the
      // convergence criterion.
      // The factor is a power of the base.

      sc = LO / moduli_min;

      if (sc <= 1.0 && moduli_max >= 10 || sc > 1.0 && CPP_FLT_MAX / sc >= moduli_max) {
        sc = sc == 0 ? CPP_FLT_MIN : sc;
        l = Math.floor(Math.log(sc) / LB2 + 0.5);
        factor = Math.pow(2.0, l);
        if (factor != 1.0) {
          for (i = 0; i < NN; i++) p[i] *= factor;
        } // End if (factor != 1.0)
      } // End if (((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (CPP_FLT_MAX/sc >= moduli_max)))

      // Compute lower bound on moduli of zeros

      for (var i = 0; i < NN; i++) pt[i] = Math.abs(p[i]);
      pt[N] = -pt[N];

      NM1 = N - 1;

      // Compute upper estimate of bound

      x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);

      if (pt[NM1] != 0) {
        // If Newton step at the origin is better, use it
        xm = -pt[N] / pt[NM1];
        x = xm < x ? xm : x;
      } // End if (pt[NM1] != 0)

      // Chop the interval (0, x) until ff <= 0

      xm = x;
      do {
        x = xm;
        xm = 0.1 * x;
        ff = pt[0];
        for (var i = 1; i < NN; i++) ff = ff * xm + pt[i];
      } while (ff > 0); // End do-while loop

      dx = x;

      // Do Newton iteration until x converges to two decimal places

      while (Math.abs(dx / x) > 0.005) {
        df = ff = pt[0];
        for (var i = 1; i < N; i++) {
          ff = x * ff + pt[i];
          df = x * df + ff;
        } // End for i
        ff = x * ff + pt[N];
        dx = ff / df;
        x -= dx;
      } // End while loop

      bnd = x;

      // Compute the derivative as the initial K polynomial and do 5 steps with no shift

      for (var i = 1; i < N; i++) K[i] = (N - i) * p[i] / N;
      K[0] = p[0];

      aa = p[N];
      bb = p[NM1];
      zerok = K[NM1] == 0 ? 1 : 0;

      for (jj = 0; jj < 5; jj++) {
        cc = K[NM1];
        if (zerok) {
          // Use unscaled form of recurrence
          for (var i = 0; i < NM1; i++) {
            j = NM1 - i;
            K[j] = K[j - 1];
          } // End for i
          K[0] = 0;
          zerok = K[NM1] == 0 ? 1 : 0;
        } // End if (zerok)
        else
          {// else !zerok
            // Used scaled form of recurrence if value of K at 0 is nonzero
            t = -aa / cc;
            for (var i = 0; i < NM1; i++) {
              j = NM1 - i;
              K[j] = t * K[j - 1] + p[j];
            } // End for i
            K[0] = p[0];
            zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0 ? 1 : 0;
          } // End else !zerok

      } // End for jj

      // Save K for restarts with new shifts

      for (var i = 0; i < N; i++) temp[i] = K[i];

      // Loop to select the quadratic corresponding to each new shift

      for (jj = 1; jj <= 20; jj++) {

        // Quadratic corresponds to a double shift to a non-real point and its
        // complex conjugate. The point has modulus BND and amplitude rotated
        // by 94 degrees from the previous shift.

        xxx = -(sinr * yy) + cosr * xx;
        yy = sinr * xx + cosr * yy;
        xx = xxx;
        sr = bnd * xx;

        // Second stage calculation, fixed quadratic
        Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, Fxshfr_Par);

        if (Fxshfr_Par.NZ != 0) {

          // The second stage jumps directly to one of the third stage iterations and
          // returns here if successful. Deflate the polynomial, store the zero or
          // zeros, and return to the main algorithm.

          j = degPar.Degree - N;
          zeror[j] = Fxshfr_Par.szr;
          zeroi[j] = Fxshfr_Par.szi;
          NN = NN - Fxshfr_Par.NZ;
          N = NN - 1;
          for (var i = 0; i < NN; i++) p[i] = qp[i];
          if (Fxshfr_Par.NZ != 1) {
            zeror[j + 1] = Fxshfr_Par.lzr;
            zeroi[j + 1] = Fxshfr_Par.lzi;
          } // End if (NZ != 1)
          break;
        } // End if (NZ != 0)
        else {// Else (NZ == 0)

            // If the iteration is unsuccessful, another quadratic is chosen after restoring K
            for (var i = 0; i < N; i++) K[i] = temp[i];

          } // End else (NZ == 0)

      } // End for jj

      // Return with failure if no convergence with 20 shifts
      if (jj > 20) {
        degPar.Degree -= N;
        break;
      } // End if (jj > 20)

    } // End while (N >= 1)

    return;
  }

  window.quartic = function (coeffs) {
    var POLYDEGREE = 4;

    // Vector of real components of roots
    var zeror = [];
    // Vector of imaginary components of roots
    var zeroi = [];
    var errCodeOutFlag = null;
    // degreePar is a dummy variable for passing the parameter Degree by reference
    var degreePar = {};
    degreePar.Degree = POLYDEGREE;

    for (var i = 0; i < POLYDEGREE; i++) {
      zeroi[i] = zeror[i] = 0;
    }

    rpSolve(degreePar, coeffs, zeror, zeroi);

    var ret = [];

    for (var i = 0; i < 4; i++) {
      ret.push({re:zeror[i], im:zeroi[i]});
    }

    return ret;
  };
</script>
