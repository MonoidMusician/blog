## Aliases for builtins
## alias <existing> <additionalName>
alias ++ +1
alias -- -1
alias powerset 𝒫


def single
  1#{}
end

def dup
  [.0]
end

def swap
  2#[.0 .1]
end

def rot
  3#[.1 .0 .2]
end

def drop
  1#[]
end

0 set false
1 set true

alias false ⊥
alias true  ⊤

alias not ¬
def not
  0 ==
end

## Unpack a singleton set
def unsingle
  #
  1 != if
    throw
  end
end

## Kuratowski encoding of ordered pairs
alias pair >-
def pair
  2#[ {{.0}, {.0, .1}} ]
end

## Unpack an ordered pair
alias unpair -<
def unpair
  #
  2 match
    drop
    2#[
      .0 .1 .\ unsingle
      .0 unsingle
    ]
    return
  end
  1 match
    drop
    unsingle
    dup
    return
  end
  throw
end

## Project out the first element of the pair
## (the top of the stack)
def fst
  unpair 2#[ .0 ]
end

## Project out the second element of the pair
## (just below the top of the stack)
def snd
  unpair 2#[ .1 ]
end

## Maps are (finite) graphs of functions,
## a set of pairs
alias apply @@
def apply
  2#[ .1# .0 ]
  ⎛ $1 while
  ⎜ 3#[ .1-- .0  .2 ]
  ⎜ unpair
  ⎜ $2 == if
  ⎜   $2 3+ #[ .0 ]
  ⎜   return
  ⎜ end
  ⎝ drop
  throw
end

## Domain of a map
def domain
  #
  {}
  begin
    $1 while
    3#[ .1-- , .0 , .2 fst {.} | ]
  end
  swap drop
end

## Range of a map
def range
  #
  {}
  ⎛ $1 while
  ⎝ 3#[ .1-- , .0 , .2 snd {.} | ]
  2#[ .0 ]
end

## The Zermelo encoding of natural numbers
## as nested singleton sets
def Zermelo
  {} swap
  begin
    dup while
    2#[ {.1} , .0-- ]
  end
  drop
end

## The von Neumann ordinals
def vonNeumann
  {} swap
  begin
    dup while
    2#[ .1 {.1} | , .0-- ]
  end
  drop
end

## Truncating integer square root, adapted from
## https://github.com/waldemarhorwat/integer-roots
alias sqrt √
def sqrt
  ## Special case 0
  0 match
    return
  end
  ## Compute the initial estimate
  ## 2 ^ (log2 .0 / 2)
  ## (A lower bound, since both log2
  ## and 1>>. are truncating)
  [ .0 width-- 1>>. 1.<< ]
  ## Apply one step of Newton's method
  ## to get an overapproximation
  1#[ .0 .1 .0 /. + 1>>. ]
  begin
    ## Iterate downwards
    [ .0 .1 .0 /. + 1>>. ]
    [ .0 .1 < ]
    while
    2#[ .0 ]
  end
  ## Take previous approximation,
  ## not the last guess
  3#[ .1 ]
  Dec
end

## The Cantor pairing function
def pairCantor 2#[
  .0 .1 + $0++ * 2 /. .1 +
] end

def unpairCantor 1#[
  .0 8 * ++ sqrt -- 2 /. ## w
  [ .0 2 ^. .0 + 2 /. ] ## t
    .0 .- ## y
  [ .1 .0 -. ] ## x
  3#[ .1 .0 ] ## w y x : y x
] end

## Bit interleaving
def pairBits 2#[
  .1 not .0 not && if
    0
  else
    .1 1>>. .0 1>>. pairBits 2<<.
      .1 1& 1<<. .0 1& | |
  end
] end

def unpairBits 1#[
  .0 if
    .0 2& 1>>.
    .0 1&
    .0 2>>. unpairBits
    4#[
      .1 1<<. .3 |
      .0 1<<. .2 |
    ]
  else
    0 0
  end
] end

## Elegant pairing function by Szudzik
## https://en.wikipedia.org/wiki/Pairing_function#Other_pairing_functions
def pairElegant 2#[
  .0 .1 \/ 2 ^.
    .1 +
    .0  .0 .1 <= *  +
] end

def unpairElegant 1#[
  .0 sqrt
  $0 2 ^. .0 .-
  [ .0 .1 < ] if
    swap
  else
    $1 -.
  end
] end
