## Aliases for builtins
## alias <existing> <additionalName>
alias ++ +1
alias -- -1
alias powerset ð’«


def single
  1#{}
end

def dup
  [.0]
end

def swap
  2#[.0 .1]
end

def rot
  3#[.1 .0 .2]
end

def bury
  3#[.0 .2 .1]
end

def drop
  1#[]
end

0 set false
1 set true

alias false âŠ¥
alias true  âŠ¤

alias not Â¬
def not
  0 ==
end

## Unpack a singleton set
def unsingle
  #
  1 != if
    throw
  end
end


## A simple encoding of ordered pairs
alias pair >-
def pair
  2#[ { { .0, 0 }, { {.1}, 1 } } ]
end

## Unpack an ordered pair
alias unpair -<
def unpair
  # 2 != if throw end
  ## Make sure $1 is the one that contains 0
  $0 0 .@ if swap end

  # 2 matched
    1 != if throw end
  else
    1 != if throw end
  end
  unsingle

  swap
  # 2 matched
    0 != if throw end
  else
    1 != if throw end
  end
end

## Project out the first element of the pair
## (the top of the stack)
def fst
  unpair 2#[ .0 ]
end

## Project out the second element of the pair
## (just below the top of the stack)
def snd
  unpair 2#[ .1 ]
end

## Maps are (finite) graphs of functions,
## a set of pairs
alias apply @@
def apply
  2#[ .1# .0 ]
  âŽ› $1 while
  âŽœ 3#[ .1-- .0  .2 ]
  âŽœ unpair
  âŽœ $2 == if
  âŽœ   $2 3+ #[ .0 ]
  âŽœ   return
  âŽœ end
  âŽ drop
  throw
end

alias apply0 @?
def apply0
  2#[ .1# .0 ]
  âŽ› $1 while
  âŽœ 3#[ .1-- .0  .2 ]
  âŽœ unpair
  âŽœ $2 == if
  âŽœ   $2 3+ #[ .0 ]
  âŽœ   return
  âŽœ end
  âŽ drop
  2#[ 0 ]
end

## Domain of a map
def domain
  #
  {}
  begin
    $1 while
    3#[ .1-- , .0 , .2 fst {.} | ]
  end
  swap drop
end

## Range of a map
def range
  #
  {}
  âŽ› $1 while
  âŽ 3#[ .1-- , .0 , .2 snd {.} | ]
  2#[ .0 ]
end

## The Zermelo encoding of natural numbers
## as nested singleton sets
def Zermelo
  {} swap
  begin
    dup while
    2#[ {.1} , .0-- ]
  end
  drop
end

## The von Neumann ordinals
def vonNeumann
  {} swap
  begin
    dup while
    2#[ .1 {.1} | , .0-- ]
  end
  drop
end

## Truncating integer square root, adapted from
## https://github.com/waldemarhorwat/integer-roots
alias sqrt âˆš
def sqrt
  ## Special case 0
  0 match
    return
  end
  ## Compute the initial estimate
  ## 2 ^ (log2 .0 / 2)
  ## (A lower bound, since both log2
  ## and 1>>. are truncating)
  [ .0 width-- 1>>. 1.<< ]
  ## Apply one step of Newton's method
  ## to get an overapproximation
  1#[ .0 .1 .0 /. + 1>>. ]
  begin
    ## Iterate downwards
    [ .0 .1 .0 /. + 1>>. ]
    [ .0 .1 < ]
    while
    2#[ .0 ]
  end
  ## Take previous approximation,
  ## not the last guess
  3#[ .1 ]
  Dec
end

## Kuratowski encoding of ordered pairs
## (not a pairing function)
def pairKuratowski
  2#[ {{.0}, {.0, .1}} ]
end

def unpairKuratowski
  #
  2 matched
    2#[
      .0 .1 .\ unsingle
      .0 unsingle
    ]
  ret
  1 matched
    unsingle
    dup
  ret
  throw
end

## The Cantor pairing function
def pairCantor 2#[
  .0 .1 + $0++ * 2 /. .1 +
] end

def unpairCantor 1#[
  .0 8 * ++ sqrt -- 2 /. ## w
  [ .0 2 ^. .0 + 2 /. ] ## t
    .0 .- ## y
  [ .1 .0 -. ] ## x
  3#[ .1 .0 ] ## w y x : y x
] end

## Bit interleaving
def pairBits 2#[
  .1 not .0 not && if
    0
  else
    .1 1>>. .0 1>>. pairBits 2<<.
      .1 1& 1<<. .0 1& | |
  end
] end

def unpairBits 1#[
  .0 if
    .0 2& 1>>.
    .0 1&
    .0 2>>. unpairBits
    4#[
      .1 1<<. .3 |
      .0 1<<. .2 |
    ]
  else
    0 0
  end
] end

## Elegant pairing function by Szudzik
## https://en.wikipedia.org/wiki/Pairing_function#Other_pairing_functions
def pairElegant 2#[
  .0 .1 \/ 2 ^.
    .1 +
    .0  .0 .1 <= *  +
] end

def unpairElegant 1#[
  .0 sqrt
  $0 2 ^. .0 .-
  [ .0 .1 < ] if
    swap
  else
    $1 -.
  end
] end

def mk #{} end
def un 2#[
  .1 # .0 != if throw end
] end

## Encode the integers as
##   0 <- -0, 1 <- +1, 2 <- -1
##   3 <- +2, 4 <- -2, ...
def posZ
  dup if 1-. 1<<. 1+ end
end
def negZ
  1<<.
end
## Action of Z on N
def plusminusNZ 2#[
  .1
    .0 1>>.
    .0 1& if
      1+ +
    else
      -.
    end
] end
def plusminusZN swap plusminusNZ end

alias plusminusNZ +-.
alias plusminusNZ Â±.
alias plusminusZN .+-
alias plusminusZN .Â±

## A custom encoding for pairs, optimized for
## a small index paired with larger data, which
## is embedded in singleton sets at a depth
## larger than the depth of the index.
def entry
  2#[
    .1 .0 depth++ loop {.} end
    .0
  ] 2#{}
end
def unentry
  2un 2#[
    .1 .0 depth++ loop 1un end
    .0
  ]
end

alias cons !>
def cons 2#[
  .0  .1 count entry
  {.} .1 |
] end
def <! swap !> end

alias index !!
def index
  2#[ .1# .0 ]
  âŽ› $1 while
  âŽœ 3#[ .1-- .0  .2 ]
  âŽœ unentry
  âŽœ $2 == if
  âŽœ   $2 3+ #[ .0 ]
  âŽœ   return
  âŽœ end
  âŽ drop
  throw
end

alias index0 !?
def index0
  2#[ .1# .0 ]
  âŽ› $1 while
  âŽœ 3#[ .1-- .0  .2 ]
  âŽœ unentry
  âŽœ $2 == if
  âŽœ   $2 3+ #[ .0 ]
  âŽœ   return
  âŽœ end
  âŽ drop
  2#[ 0 ]
end

def uncons 1#[
  .0  .0 count--  index
  $0  .0 count--  entry
    {.} .0 .\
  swap
] end

def tuple
  {} swap loop swap !> end
end

alias untuple ..
def untuple
  dup count loop uncons swap end drop
end

alias list #..
def list
  {} swap loop swap !> end
end

alias unlist ..#
def unlist
  1#[ .0 untuple .0 count ]
end


## ############### ##
## Turing machines ##
## ############### ##

## Uses global variables for convenience:

## A table of all of the state transitions and actions
## TMtable: Map (Entry TMstate TMsymbol) (Pair (Entry TMstate TMsymbol) TMaction)
{} set TMtable
## The current state of the machine
1  set TMstate
## The symbols written to the tape
{} set TMtape
## The current index of the read/write head on the tape
0  set TMindex
## (Temporary) The last symbol read off the tape
0  set TMsymbol

## Actions
enum TMa(
  N  ## Neutral: -0
  R  ## Right:   +1
  L  ## Left:    -1
  RR ## Right 2: +2
  LL ## Left 2:  -2
  ## Use posZ / negZ for more
)
## States
enum TMs(
  0 Halt
  1 Start
  ## Your states here!
)

## Construct an entry for TMtable
def TMentry 5#[
  ## Recognize state .4, with symbol .3 on the tape
  .3 .4 entry
  ## Transition to state .2, after writing symbol .1,
  ## then move head by posZ/negZ .0
  .1 .2 entry .0 pair
  swap pair
] end
## Alternate constructor, a catchall for symbols
def TMconst 4#[
  ## Recognize state .3 with any symbol on the tape
  .3 {.}
  ## Transition to state .2, after writing symbol .1,
  ## then move head by posZ/negZ .0
  .1 .2 entry .0 pair
  swap pair
] end

def TMreset
  1  set TMstate
  {} set TMtape
  0  set TMindex
  0  set TMsymbol
end

## Take one step, if it is not in the halt state
## and it has an action for the current state
## and symbol on the tape.
def TMstep
  ## Explicit halt state (0)
  TMstate TMsHalt == if 0 ret

  ## Retrieve the symbol on the tape
  ## at the current index
  TMtape TMindex !?
    set TMsymbol

  ## Look it up in the machine table
  ## First try looking up the state and symbol pair
  TMtable  TMsymbol TMstate entry  @?
    0 matched
      ## Fall back to the state as a singleton
      TMtable  {TMstate}  @?
        0 match ret  ## Return 0 if not found
    end
  -< 2#[ .1 unentry .0 ]

  3#[
    ## Enter the new state
    .1 set TMstate
    ## Replace the index in the tape
    TMtape
      { TMsymbol TMindex entry } \.
      { .2       TMindex entry } |
      set TMtape
    ## Move the index by the specified integer
    TMindex .0 Â±. set TMindex
  ]
  ## Continue
  1
end

## Loops until a halt state / unknown symbol
## and returns how many steps it took
def TMloop
  0
    begin TMstep while ++ end
  Dec
end

## Loops with fuel, returns how many steps were taken
def TMsteps
  dup 0 == if ret
  0
    begin TMstep while
      2#[ .1-- .0++ ]
      $1 0 == if break end
    end
  2#[ .0 ]
  Dec
end
