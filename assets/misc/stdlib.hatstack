## Aliases for builtins
## alias <existing> <additionalName>
alias ++ +1
alias -- -1
alias powerset 𝒫


def single
  1#{}
end

def dup
  [.0]
end

def swap
  2#[.0 .1]
end

def rot
  3#[.1 .0 .2]
end

def drop
  1#[]
end

0 set false
1 set true

alias false ⊥
alias true  ⊤

alias not ¬
def not
  0 ==
end

## Unpack a singleton set
def unsingle
  #
  1 != if
    throw
  end
end

## Kuratowski encoding of ordered pairs
alias pair >-
def pair
  2#[ {{.0}, {.0, .1}} ]
end

## Unpack an ordered pair
alias unpair -<
def unpair
  #
  2 match
    drop
    2#[
      .0 .1 .\ unsingle
      .0 unsingle
    ]
  ret
  1 match
    drop
    unsingle
    dup
  ret
  throw
end

## Project out the first element of the pair
## (the top of the stack)
def fst
  unpair 2#[ .0 ]
end

## Project out the second element of the pair
## (just below the top of the stack)
def snd
  unpair 2#[ .1 ]
end

## Maps are (finite) graphs of functions,
## a set of pairs
alias apply @@
def apply
  2#[ .1# .0 ]
  ⎛ $1 while
  ⎜ 3#[ .1-- .0  .2 ]
  ⎜ unpair
  ⎜ $2 == if
  ⎜   $2 3+ #[ .0 ]
  ⎜   return
  ⎜ end
  ⎝ drop
  throw
end

alias apply0 @?
def apply0
  2#[ .1# .0 ]
  ⎛ $1 while
  ⎜ 3#[ .1-- .0  .2 ]
  ⎜ unpair
  ⎜ $2 == if
  ⎜   $2 3+ #[ .0 ]
  ⎜   return
  ⎜ end
  ⎝ drop
  2#[ 0 ]
end

## Domain of a map
def domain
  #
  {}
  begin
    $1 while
    3#[ .1-- , .0 , .2 fst {.} | ]
  end
  swap drop
end

## Range of a map
def range
  #
  {}
  ⎛ $1 while
  ⎝ 3#[ .1-- , .0 , .2 snd {.} | ]
  2#[ .0 ]
end

## The Zermelo encoding of natural numbers
## as nested singleton sets
def Zermelo
  {} swap
  begin
    dup while
    2#[ {.1} , .0-- ]
  end
  drop
end

## The von Neumann ordinals
def vonNeumann
  {} swap
  begin
    dup while
    2#[ .1 {.1} | , .0-- ]
  end
  drop
end

## Truncating integer square root, adapted from
## https://github.com/waldemarhorwat/integer-roots
alias sqrt √
def sqrt
  ## Special case 0
  0 match
    return
  end
  ## Compute the initial estimate
  ## 2 ^ (log2 .0 / 2)
  ## (A lower bound, since both log2
  ## and 1>>. are truncating)
  [ .0 width-- 1>>. 1.<< ]
  ## Apply one step of Newton's method
  ## to get an overapproximation
  1#[ .0 .1 .0 /. + 1>>. ]
  begin
    ## Iterate downwards
    [ .0 .1 .0 /. + 1>>. ]
    [ .0 .1 < ]
    while
    2#[ .0 ]
  end
  ## Take previous approximation,
  ## not the last guess
  3#[ .1 ]
  Dec
end

## The Cantor pairing function
def pairCantor 2#[
  .0 .1 + $0++ * 2 /. .1 +
] end

def unpairCantor 1#[
  .0 8 * ++ sqrt -- 2 /. ## w
  [ .0 2 ^. .0 + 2 /. ] ## t
    .0 .- ## y
  [ .1 .0 -. ] ## x
  3#[ .1 .0 ] ## w y x : y x
] end

## Bit interleaving
def pairBits 2#[
  .1 not .0 not && if
    0
  else
    .1 1>>. .0 1>>. pairBits 2<<.
      .1 1& 1<<. .0 1& | |
  end
] end

def unpairBits 1#[
  .0 if
    .0 2& 1>>.
    .0 1&
    .0 2>>. unpairBits
    4#[
      .1 1<<. .3 |
      .0 1<<. .2 |
    ]
  else
    0 0
  end
] end

## Elegant pairing function by Szudzik
## https://en.wikipedia.org/wiki/Pairing_function#Other_pairing_functions
def pairElegant 2#[
  .0 .1 \/ 2 ^.
    .1 +
    .0  .0 .1 <= *  +
] end

def unpairElegant 1#[
  .0 sqrt
  $0 2 ^. .0 .-
  [ .0 .1 < ] if
    swap
  else
    $1 -.
  end
] end

def mk #{} end
def un 2#[
  .1 # .0 != if throw end
] end

def entry
  2#[
    .1 .0 depth++ loop {.} end
    .0
  ] 2#{}
end
def unentry
  2un 2#[
    .1 .0 depth++ loop 1un end
    .0
  ]
end

alias cons !>
def cons 2#[
  .0  .1 count entry
  {.} .1 |
] end
def <! swap !> end

alias index !!
def index
  2#[ .1# .0 ]
  ⎛ $1 while
  ⎜ 3#[ .1-- .0  .2 ]
  ⎜ unentry
  ⎜ $2 == if
  ⎜   $2 3+ #[ .0 ]
  ⎜   return
  ⎜ end
  ⎝ drop
  throw
end

alias index0 !?
def index0
  2#[ .1# .0 ]
  ⎛ $1 while
  ⎜ 3#[ .1-- .0  .2 ]
  ⎜ unentry
  ⎜ $2 == if
  ⎜   $2 3+ #[ .0 ]
  ⎜   return
  ⎜ end
  ⎝ drop
  2#[ 0 ]
end

def uncons 1#[
  .0  .0 count--  index
  $0  .0 count--  entry
    {.} .0 .\
  swap
] end

def tuple
  {} swap loop swap !> end
end

alias untuple ..
def untuple
  dup count loop uncons swap end drop
end

alias list #..
def list
  {} swap loop swap !> end
end

alias unlist ..#
def unlist
  1#[ dup count loop uncons swap end drop .0 count ]
end


## Turing machines

## TMtable: Map (Pair TMstate TMsymbol) (Pair (Pair TMstate TMsymbol) TMaction)
{} set TMtable
1  set TMstate
{} set TMtape
0  set TMindex

## Actions
enum TMa(
  L ## Left
  N ## Neutral
  R ## Right
  H ## Halt
)
## States
enum TMs(
  0 Halt
  1 Start
)

def TMentry 5#[
  .4 .3 pair
  .2 .1 pair .0 pair
  pair
] end

def TMstep
  TMstate TMsHalt == if 0 ret
  TMtape TMindex !?
    set TMsymbol
  TMtable  TMstate TMsymbol >-  @?
    dup 0 == if ret
  -< 2#[ .1 -< .0 ]
  3#[
    .2 set TMstate
    TMtape
      { TMsymbol TMindex entry } \.
      { .1       TMindex entry } |
      set TMtape
    .0
      TMaL match drop
        TMindex-- set TMindex
      1 ret
      TMaR match drop
        TMindex++ set TMindex
      1 ret
      TMaN match drop
        TMindex set TMindex
      1 ret
      begin ## fallthrough
        TMsHalt set TMstate
      0 ret
  ]
end
