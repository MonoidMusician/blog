# Interactive Parser Explanations

::: {widget="Widget.Control" widget-datakey="main"}
:::

::: {.widget widget="Widget.Query" widget-empty="true" widget-datakey="default" widget-data-keys="grammar" widget-loading="true"}
:::

## Input a grammar
Craft a grammar out of a set of rules. Each rule consists of a nonterminal name, then a colon followed by a sequence of nonterminals and terminals. Each rule must also have a unique name, which will be used to refer to it during parsing and when displaying parse trees. If ommitted, an automatic rule name will be supplied based on the nonterminal name.

The top rule is controlled by the upper input boxes (LR(1) grammars often require a top rule that contains a unique terminal to terminate each input), while the lower input boxes are for adding a new rule. The nonterminals are automatically parsed out of the entered rule, which is otherwise assumed to consist of terminals.

Click “Use grammar” to see the current set of rules in action! It may take a few seconds, depending on the size of the grammar and how many states it produces.

:::: {.widget widget="Parser.Grammar" widget-datakey="default" widget-loading="true" widget-ssr="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::

## Input custom text to see parsing step-by-step
Text entered here (which may also be generated by other widgets below) will be parsed step-by-step, and the final parse tree displayed if the parse succeeded. (Note that the closing terminal is automatically appended, if necessary.) Check the state tables above to see what state the current input ends up in, and the valid next terminals will be highlighted for entry.

:::: {.widget widget="Parser.Input" widget-datakey="default" widget-loading="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::

## Generate random matching inputs

This will randomly generate some inputs that conform to the grammar. Click on one to send it to be tested down below!

:::: {.widget widget="Parser.Random" widget-datakey="default" widget-loading="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::

## Explore building trees in the grammar
Each rule can be read as a transition: “this nonterminal may be replaced with this sequence of terminals and nonterminals”. Build a tree by following these state transitions, and when it consists of only terminals, send it off to be parsed below!

:::: {.widget widget="Parser.Explorer" widget-datakey="default" widget-loading="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::

## List of parsing states
To construct the LR(1) parse table, the possible states are enumerated. Each state represents partial progress of some rules in the grammar. The center dot “•” represents the dividing line between already-parsed and about-to-be-parsed.

Each state starts from a few seed rules, which are then closed by adding all nonterminals that could be parsed next. Then new states are explored by advancing on terminals or nonterminals, each of which generates some new seed items. That is, if multiple rules will advance on the same (non)terminal, they will collectively form the seed items for a state. (This state may have been recorded already, in which case nothing further is done.)

When a full rule is parsed, it is eligible to be reduced, but this is only done when one of its lookaheads come next (highlighted in red).

:::: {.widget widget="Parser.StateTable" widget-datakey="default" widget-loading="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::

## Table of states and parse actions
Once the states are enumerated, the table of parse actions can be read off:

Terminals can be “shifted” onto the stack, transitioning to a new state seeded by pushing through that terminal in all applicable rules in the current state.

Completely parsed rules will be “reduced” when their lookahead appears, popping the values matching the rule off of the stack and replacing it with the corresponding nonterminal, which then is received by the last state not involved in the rule.

Nonterminals received from another state trigger “gotos” to indicate the next state.

Two types of conflicts may occur: if a terminal indicates both a shift and reduce actions (shift–reduce conflict) or multiple reduce actions (reduce–reduce conflict). Note that there cannot be multiple shift actions at once, so most implementations (including this one) choose to do the shift action in the case of shift–reduce conflict.

:::: {.widget widget="Parser.ParseTable" widget-datakey="default" widget-loading="true"}
::: {widget="Widget.Control" widget-datakey="main"}
:::
::::
