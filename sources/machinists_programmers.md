---
title: Machinists, Programmers, and Society
author:
- "[@MonoidMusician](https://blog.veritates.love/)"
---

I follow a bunch of hobby machinist channels on YouTube (people using lathes, mills, CNC routers, plus hacksaws, angle grinders, taps, and the like to build small one-off projects, often with an educational bent), and Iʼve been reflecting on what I find attractive about the discipline of machining and the contrasts with the programming/mathematics industry/culture.

The central theme of my thoughts here is what dealing with metal in the physical world provides, and related historic differences in culture between the disciplines of machining versus programming.

## An Ode to Machining

One thing I love about machining is like&nbsp;… people say math is precise, but with math you still think you can argue with it, and if not argue with it directly, at least argue around it, disclaim itʼs practical implications&nbsp;…– but Steel? not so much.
What is so powerful to me is what occurs when youʼre dealing with physical objects and operations that have physical consequences, on top of the aesthetic and practical considerations – your artistry _and_ your fallability.
The machinists are dealing with thousandths and ten-thousandths of an inch not to show off, but because it matters to how well parts work together, and you cannot argue with steel!!

## Programming vs Machining

I feel like the programmerʼs version of “touch grass”^[I recognize this saying is pretty cringe/ableist/mean, but Iʼm using it as a jumping off point to make a comparison.] should be “touch metal”.

I feel like most programming questions are relatively trivial in that theyʼre mostly a matter of putting in the time to actually write code, try a few things out, and get it working well together.
I mean, perhaps itʼs like 40% talent + 20% hubris on my part, and 40% the paltry state of programming, but I really do believe most programs could largely be reengineered from scratch by someone who wanted to do so.
You need to learn how to program effectively in *some* language, and it takes some experience to discover how to architecture large applications well, but thatʼs mostly about managing data flow and once you know how to program to a high level itʼs not like you need the ultra specialized knowledge of a PhD to accomplish most problems that I see being solved in day to day programming, or indeed most problems that are dying for good solutions.
(I believe thereʼs a huge dearth of actually providing good solutions to common problems, both programmersʼ problems as well as consumersʼ problems.)

In contrast, my perspective as an outsider is that a lot of the simple operations that machinists do every day would take ages, a lot of experimentation, and ingenuity to recreate.
You canʼt just make that stuff up. Gotta respect the tools, the materials, the processes.
[[TODO]{t=}: give specific examples.]

I was reading a Gizmodo article on the state of VFX production studios, how theyʼre overworked and underbidding to Marvel/Disney and such, really horrible conditions, and they mentioned that a lot of the work is basically one-off, reinvented for each film.
(And thus costs a lot of man-hours.)
Thatʼs partly the fault of shelling out to ever-shifting studios for a lot of the work (so there isnʼt a consistent core team of VFX artists), but itʼs also just the horrible state of the tech industry.
The tech industry is optimized more for reinventing the wheel than sharing work, insight, and implementations.

But if youʼre machining components in an industrial setting, you absolutely have to work on the processes you need to do it repeatably.
You have to make the specifications, the diagrams, the tooling to do it over and over.

The tech industry is the one place where economies of scale should apply more readily than anywhere else, because its raw material is free (erm, cheaply scalable) and it contains the power to multiply its own successes, but it seems that itʼs stuck, hampered by the lack of vision beyond “write code to accomplish immediate need before competitor gets to it”.

And arguably it is this cheapness that is its downfall; the code is only in your head, on your computer; itʼs not tangible, so it feels cheap, disposable, and yet alluring and valuable but without real consequences.

### Processes

In both programming and machining, you always need to create the tools youʼre going to use to accomplish the task, as well as the tools to measure that youʼve accomplished the task.
Sometimes the tools are already mostly available, but you canʼt call yourself a professional programmer or a machinist if youʼre not able to make the tools when you need them.

In the machining world, you often need to manufacture the cutting tools youʼre going to use to make specialized cuts, and sometimes specialized fixtures to hold the material youʼre cutting in precise ways.
And then you get out the micrometers, the gauge blocks, the dial indicators to verify that youʼre getting the results you need, and to predict what adjustments you need to make down the line if they didnʼt turn out exactly to spec.

When programming, we engage in similar processes in our respective domain. How many hundreds of commands do you run in the terminal per day to accomplish what you need?
Build commands, git commands, running executables from various languages in different runtimes.
Shuffling files around, converting them.
Making scripts and tests to verify your results are what you expect and remain that way through future code changes.

THE most important distinction, however, is that in the world of machinists, youʼre left with the physical tools as byproducts of the process, and forced to deal with them, whether thatʼs sharpening/hardening or cleaning/optimizing them for reuse or chucking them in the scrap bin.
When youʼre programming, the default is for what youʼve done to get lost – lost in your bash history, a file thatʼs deleted or never checked into git, temporary byproducts placed in /tmp.
But maybe (often!) you do want to look at these things later, to have a chance of repeating what you did, explaining it to another person so the poor soul doesnʼt have to guess and verify for themself what you did and why you did it.

## My convictions in explainability

Part of my work as a programmer is to start documenting my process and sharing the details, the reasons why I make the choices I do, and why I believe in what Iʼm doing.

I send myself an email after every workday containing my notes: specific commands to remember, errors I ran into and what resources I found when googling them, places in the source code that I looked at (especially in external projects).

And of course it is the reason I started this blog, to share my work, my processes, my insights, and even the most mundane stuff with people who might benefit from it.

Itʼs deeply tied to my belief in evidence, explainability, intelligibility. I believe that most things we deal with (as programmers, artsists, whatnot) are *not* so strange, *not* so foreign, *not* so impossibly academic or only for “smart” people speaking from their “ivory tower”.

Of course you are welcome to object that I am exactly this kind of smart person speaking from an ivory tower.
I have attracted a reputation for being smart in most circumstances I find myself in.
But I think the record shows that I care about stopping to explain the things I know to others, helping them find the time, tools, words, and experince to understand things for themselves, in school, online, and in musical contexts.
I donʼt have infinite patience for teaching/sharing/tutoring/explaining, but I do my best to help when I can and in the ways I can.

I reject notions of smartness and dumbness, and certainly reject the way society values people based on that false dichotomy or any other social constructs.
I think most anyone can learn, but the challenge is in approaching what you want to learn from useful perspectives, finding meaningful engagement with it, and putting in the work and effort.
Often these steps require assistance, someone willing to spend time with you and answer questions, plus they also require investment on the learnerʼs part.
Which can be tough, especially in this capitalist society that has such a dysfunctional attitude towards what it means to learn and work and what are socially acceptable ways to do so.
Compounded by all the other oppressions that are felt every day by people in the kyriarchy, which impede their ability to do what they find meaningful and that impede our ability to aspire to positive core values, as well as the artificial time crunch we feel merely trying to survive in this dysfunctional society.

I believe our values are reflected in the code we write, and I seek to clearly articulate my values and vision for a more healthy relationship with code and explainability, here on this blog and elsewhere.

I will write much more in the future about how I believe this attitude of explainability translates into writing rigorous code and providing good errors for programs such as compilers, version solvers, user interfaces.
I think the ugly land of C, system calls, and the history of dealing with unknown foreign APIs in systems programming has rotted away our attitudes towards errors, fooling us into treating them as this unintelligible horror that we can never hope to understand or code for.
I believe itʼs very much the opposite in many common situations we find ourselves writing code for, even complex cases too!

Of course I come at this from a type-theoretic, mathematical, formal proofs perspective, since I believe these are utterly valuable tools to analyzing these situations and dealing with complexity.
But itʼs nothing too strange, nothing too lofty – just sound reasoning that is crystal clear on its own.
And now the challenge is working to understand it together and sharing it with more people, modelling the kinds of effective processes for development, documentation, communication, and community that we want to see in this world – in our world.
